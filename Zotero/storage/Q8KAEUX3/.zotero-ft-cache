Tom Young School of Information and Electronics, Beijing Institute of Technology, Beijing, China
Devamanyu Hazarika School of Computing, National University of Singapore, ­Singapore
Soujanya Poria Temasek Laboratories, Nanyang Technological University, Singapore
Erik Cambria School of Computer Science and Engineering, Nanyang Technological University, Singapore

ReAvriteiwcle

Recent Trends in Deep Learning Based Natural Language Processing

Abstract
Deep learning methods employ multiple processing layers to learn hierarchical representations of data, and have produced state-of-the-art results in many domains. Recently, a variety of model designs and methods have blossomed in the context of natural language processing (NLP). In this paper, we review significant deep learning related models and methods that have been employed for numerous NLP tasks and provide a walk-through of their evolution. We also summarize, compare and contrast the various models and put forward a detailed understanding of the past, present and future of deep learning in NLP.
I. Introduction Natural language processing (NLP) is a theory-motivated range of computational techniques for the automatic analysis and representation of human language. NLP research has evolved from the era of punch cards and batch
Digital Object Identifier 10.1109/MCI.2018.2840738 Date of publication: 18 July 2018

processing, in which the analysis of a creasingly focusing on the use of new deep

sentence could take up to 7 minutes, to learning methods (see Fig. 1). For decades,

the era of Google and the likes of it, in machine learning ap­p­roaches targeting

which millions of webpages can be NLP problems have been based on shal-

low models (e.g., SVM and logistic regres-

sion) trained on very high dimensional and

sparse features. In the last few years, neural

networks based on dense vector represen-

tations have been producing superior

results on various NLP tasks.This

trend is sparked by the success

of word embeddings [2], [3]

and deep learning meth-

ods [4]. Deep learning

enables multi-level auto-

matic feature representa-

tion learning. In contrast,

traditional machine learning

Image licensed by Ingram Publishing

based NLP systems liaise heavily

on hand-crafted features. Such hand-

processed in less than a second [1]. NLP crafted features are time-consuming and

enables computers to perform a wide often incomplete.

range of natural language related tasks at

Collobert et al. [5] demonstrated that

all levels, ranging from parsing and part- a simple deep learning framework

of-speech (POS) tagging, to machine outperforms most state-of-the-art ap­­

translation and dialogue systems.

proaches in several NLP tasks such as

Deep learning architectures and al­­ named-entity recognition (NER), se­­

gorithms have already made impressive mantic role labeling (SRL), and POS

advances in fields such as computer vision tagging. Since then, numerous complex

and pattern recognition. Following this deep learning based algorithms have

trend, recent NLP research is now in­­ been proposed to solve difficult NLP

Corresponding Author: Erik Cambria (cambria@ntu.edu.sg)

1556-603x/18©2018ieee

august 2018 | IEEE Computational intelligence magazine 55

70

ACL

EACL

EMNLP NAACL

60

(%)

50

40

30

2012

2013

2014 2015 2016 Year

2017

Figure 1 Percentage of deep learning papers in ACL, EMNLP, EACL, NAACL over the last 6 years (long papers).

King (–) Man (+) Woman
Queen Figure 2 Distributional vectors exhibits compositionality.

tasks. We review major deep learning related models and methods applied to natural language tasks such as convolutional neural networks (CNNs), recurrent neural networks (RNNs), and recursive neural networks. We also discuss memory-augmenting strategies, attention mechanisms and how unsupervised models, reinforcement learning methods and recently, deep generative models have been employed for language-related tasks.
To the best of our knowledge, this work is the first of its type to comprehensively cover the most popular deep learning methods in NLP research today. The work by Goldberg [6] only presented the basic principles for applying neural networks to NLP in a tutorial manner. We believe this paper will give readers a more comprehensive idea of current practices in this domain. The structure of the paper is as follows: Section II introduces the concept of distributed representation, the basis of sophisticated deep learning models; next, Sections III, IV, and V discuss popular models such as convolutional, recurrent, and recursive neural networks, as well as their use in various NLP tasks; following, Section VI lists recent applications of reinforcement learning in NLP and new developments in unsupervised sentence representation learning; later, Section VII illustrates the recent trend of coupling deep learning models with memory modules; finally, Section VIII summarizes the performance of a series of deep learning meth-

ods on standard datasets about major NLP topics.
II. Distributed Representation Statistical NLP has emerged as the primary option for modeling complex natural language tasks. However, in its beginning, it often used to suffer from the notorious curse of dimensionality while learning joint probability functions of language models.This led to the motivation of learning distributed representations of words existing in lowdimensional space [7].
A. Word Embeddings Distributional vectors or word embeddings (Fig. 2) essentially follow the distributional hypothesis, according to which words with similar meanings tend to occur in similar context. Thus, these vectors try to capture the characteristics of the neighbors of a word. The main advantage of distributional vectors is that they capture similarity between words. Measuring similarity between vectors is possible, using measures such as cosine similarity. Word embeddings are often used as the first data processing layer in a deep learning model. Typically, word embeddings are pre-trained by optimizing an auxiliary objective in a large unlabeled corpus, such as predicting a word based on its context [3], [8], where the learned word vectors can capture general syntactical and semantic information. Thus, these embeddings have proven to be efficient in capturing context similarity, analogies and due to its

smaller dimensionality, are fast and efficient in computing core NLP tasks.
Over the years, the models that create such embeddings have been shallow neural networks and there has not been need for deep networks to create good embeddings. However, deep learning based NLP models invariably represent their words, phrases and even sentences using these embeddings. This is in fact a major difference between traditional word count based models and deep learning based models. Word embeddings have been responsible for state-ofthe-art results in a wide range of NLP tasks [9]–[12]. For example, Glorot et al. [13] used embeddings along with stacked denoising autoencoders for domain adaptation in sentiment classification and Hermann and Blunsom [14] presented combinatory categorial autoencoders to learn the compositionality of sentence. Their wide usage across the recent literature shows their effectiveness and importance in any deep learning model performing a NLP task.
Distributed representations (embeddings) are mainly learned through context. During 1990s, several research developments [15] marked the foundations of research in distributional semantics. A more detailed summary of these early trends is provided in [16], [17]. Later developments were adaptations of these early works, which led to creation of topic models like latent Dirichlet allocation [18] and language models [7]. These works laid out the foundations of representation learning.

56 IEEE Computational intelligence magazine | august 2018

In 2003, Bengio et al. [7] proposed a neural language model which learned distributed representations for words (Fig. 3). Authors argued that these word representations, once compiled into sentence representations using joint probability of word sequences, achieved an exponential number of semantically neighboring sentences. This, in turn, helped in generalization since unseen sentences could now gather higher confidence if word sequences with similar words (in respect to nearby word representation) were already seen.
Collobert and Weston [19] was the first work to show the utility of pretrained word embeddings. The authors proposed a neural network architecture that forms the foundation to many current approaches. The work also establishes word embeddings as a useful tool for NLP tasks. However, the immense popularization of word embeddings was arguably due to [3], who proposed the continuous bag-of-words (CBOW) and skip-gram models to efficiently construct high-quality distributed vector representations. Propelling their popularity was the unexpected side effect of the vectors exhibiting compositionality, i.e., adding two word vectors results in a vector that is a semantic composite of the individual words, e.g., ‘man’ + ‘royal’ = ‘king’. The theoretical justification for this behavior was recently given by Gittens et al. [20], which stated that compositionality is seen only when certain assumptions are held, e.g., the assumption that words need to be uniformly distributed in the embedding space.
Pennington et al. [21] is another famous word embedding method which is essentially a “count-based” model. Here, the word co-occurrence count matrix is preprocessed by normalizing the counts and log-smoothing them. This matrix is then factorized to get lower dimensional representations which is done by minimizing a “reconstruction loss”.
Below, we provide a brief description of the word2vec method proposed by Mikolov et al. [3].
B. Word2vec Word embeddings were revolutionized by Mikolov et al. [3], [8] who proposed

i th Output = P (wt = i | Context)

Softmax Classification

.....

.....

Concatenation

Tanh Activation
.....

C (wt – n +1)
.....
Table Look-Up Using Matrix C

C (wt – 1)
.....

Word Index wt – n +1

Word Index wt – 1

Figure 3 Representation of the Neural Language Model proposed by Bengio et al. [7]. C(i) is the ith word embedding.

the CBOW and skip-gram models. CBOW computes the conditional probability of a target word given the context words surrounding it across a window of size k. On the other hand, the skip-gram model does the exact opposite of the CBOW model, by predicting the surrounding context words given the central target word. The context words are assumed to be located symmetrically to the target words within a distance equal to the window size in both directions. In unsupervised settings, the word embedding dimension is determined by the accuracy of prediction. As the embedding dimension increases, the accuracy of prediction also increases until it converges at some point, which is considered the optimal embedding dimension as it is the shortest without com­promis­ing accuracy.
Let us consider a simplified version of the CBOW model where only one word is considered in the context. This essentially replicates a bigram lan­ guage model.
The CBOW model is a simple fully connected neural network with one hidden layer. The input layer, which takes the one-hot vector of context word has V neurons while the hidden layer has N neurons. The output layer is softmax of all words in the vocabulary. The layers are connected by weight matrix W ! RV#N and Wl! RH #V,

respectively. Each word from the vocabulary is finally represented as two learned vectors vc and vw, corresponding to context and target word representations, respectively. Thus, kth word in the vocabulary will have
vc = W(k,.) and vw = Wl(.,k) .(1)

Overall, for any word wi with given context word c as input,

/ P`

wi c

j

=

yi

=

eui
V

(2)

eui

i= 1

where, ui

=

v

T wi

.v

c

.

The parameters i = {Vw, Vc} are

learned by defining the objective func-

tion as the log-likelihood and finding its

gradient as

/ l (i)

=

log`P`
w ! Vocabulary

w c

jj(3)

2l (i) 2Vw

=

Vc

`

1

-

P`

w c

jj.(4)

In the general CBOW model, all the one-hot vectors of context words are taken as input simultaneously, i.e,
h = WT (x1 + x2 + g + xc).(5)
One limitation of individual word embeddings is their inability to represent phrases, where the combination of two or more words (e.g., idioms like “hot

august 2018 | IEEE Computational intelligence magazine 57

potato” or named entities such as “Boston Globe”) does not represent the combination of meanings of individual words. One solution to this problem, as explored by Mikolov et al. [3], is to identify such phrases based on word co-occurrence and train embeddings for them separately. More recent methods have explored directly learning n-gram embeddings from unlabeled data [22].
Another limitation comes from learning embeddings based only on a small window of surrounding words, sometimes words such as good and bad share almost the same embedding [23], which is problematic if used in tasks such as sentiment analysis [24]. At times these embeddings cluster semanticallysimilar words which have opposing sentiment polarities. This leads the downstream model used for the sentiment analysis task to be unable to identify this contrasting polarities leading to poor performance. Tang et al. [25] addresses this problem by proposing sentiment specific word embedding (SSWE). Authors incorporate the supervised sentiment polarity of text in their loss functions while learning the embeddings.
A general caveat for word embeddings is that they are highly dependent on the applications in which it is used. Labutov and Lipson [26] proposed task specific embeddings which retrain the word embeddings to align them in the current task space. This is very important as training embeddings from scratch requires large amount of time and resource. Mikolov et al. [8] tried to address this issue by proposing negative sampling which is frequencybased sampling of negative terms while training the word2vec model.
Traditional word embedding algorithms assign a distinct vector to each

word. This makes them unable to account for polysemy. In a recent work, Upadhyay et al. [27] provided an innovative way to address this deficit. The authors leveraged multilingual parallel data to learn multi-sense word embeddings. For example, the English word bank, when translated to French provides two different words: banc and banque representing financial and geographical meanings, respectively. Such multilingual distributional information helped them in accounting for polysemy.
Table 1 provides a directory of exi­­sting frameworks that are frequently used for creating embeddings which are further incorporated into deep learning models.
C. Character Embeddings Word embeddings are able to capture syntactic and semantic information, yet for tasks such as POS-tagging and NER, intra-word morphological and shape information can also be very useful. Generally speaking, building natural language understanding systems at the character level has attracted certain research attention [28]–[31]. Better results on morphologically rich languages are reported in certain NLP tasks. Santos and Guimaraes [30] applied character-level representations, along with word embeddings for NER, achieving state-of-the-art results in Portuguese and Spanish corpora. Kim et al. [28] showed positive results on building a neural language model using only character embeddings. Ma et al. [32] exploited several embeddings, including character trigrams, to incorporate prototypical and hierarchical information for learning pre-trained label embeddings in the context of NER.
A common phenomenon for languages with large vocabularies is the

TABLE 1 Frameworks providing embedding tools and methods.

Framework

Language

URL

S-Space

Java

https://github.com/fozziethebeat/S-Space

Semanticvectors

Java

https://github.com/semanticvectors/

Gensim

Python

https://radimrehurek.com/gensim/

Pydsm

Python

https://github.com/jimmycallin/pydsm

Dissect

Python

http://clic.cimec.unitn.it/composes/toolkit/

FastText

Python

https://fasttext.cc/

unknown word issue or out-of-vocabulary word (OOV) issue. Character embeddings naturally deal with it since each word is considered as no more than a composition of individual letters. In languages where text is not composed of separated words but individual characters and the semantic meaning of words map to its compositional characters (such as Chinese), building systems at the character level is a natural choice to avoid word segmentation [33]. Thus, works employing deep learning applications on such languages tend to prefer character embeddings over word vectors [34]. For example, Peng et al. [35] proved that radical-level processing could greatly improve sentiment classification performance. In particular, the authors proposed two types of Chinese radical-based hierarchical embeddings, which incorporate not only semantics at radical and character level, but also sentiment information. Bojanowski et al. [36] also tried to improve the representation of words by using character-level information in morphologically-rich languages. They approached the skip-gram method by representing words as bag-of-characters n-grams. Their work thus had the effectiveness of the skip-gram model along with addressing some persistent issues of word embeddings. The method was also fast, which allowed training models on large corpora quickly. Popularly known as FastText, such a method stands out over previous methods in terms of speed, scalability, and effectiveness.
Apart from character embeddings, other approaches have been proposed for OOV handling. Herbelot and Baroni [37] provided OOV handling on-the-fly by initializing the unknown words as the sum of the context words and refining these words with a high learning rate. However, their approach is yet to be tested on typical NLP tasks. Pinter et al. [38] provided an interesting approach of training a character-based model to recreate pre-trained embeddings. This allowed them to learn a compositional mapping from character to word embedding, thus tackling the OOV problem.
Despite the ever growing popularity of distributional vectors, recent discussions

58 IEEE Computational intelligence magazine | august 2018

on their relevance in the long run have cropped up. For example, Lucy and Gauthier [39] has recently tried to evaluate how well the word vectors capture the necessary facets of conceptual meaning. The authors have discovered severe limitations in perceptual understanding of the concepts behind the words, which cannot be inferred from distributional semantics alone. A possible direction for mitigating these deficiencies will be grounded learning, which has been gaining popularity in this research domain.
III. Convolutional Neural Networks Following the popularization of word embeddings and its ability to represent words in a distributed space, the need arose for an effective feature function that extracts higher-level features from constituting words or n-grams. These abstract features would then be used for numerous NLP tasks such as sentiment analysis, summarization, machine translation, and question answering (QA). CNNs turned out to be the natural choice given their effectiveness in computer vision tasks [40]–[42].
The use of CNNs for sentence modeling traces back to Collobert and Weston [19].This work used multi-task learning to output multiple predictions for NLP tasks such as POS tags, chunks, named-entity tags, semantic roles, semantically-similar words and a language model. A look-up table was used to transform each word into a vector of user-defined dimensions. Thus, an input sequence {s1, s2, ..., sn} of n words was transformed into a series of vectors {ws1, ws2, ..., wsn} by applying the look-up table to each of its words (Fig. 4).
This can be thought of as a primitive word embedding method whose weights were learned in the training of the network. In [5], Collobert extended his work to propose a general CNN-based framework to solve a plethora of NLP tasks. Both these works triggered a huge popularization of CNNs amongst NLP researchers. Given that CNNs had already shown their mettle for computer vision tasks, it was easier for people to believe in their performance.
CNNs have the ability to extract salient n-gram features from the input

sentence to create an informative latent semantic representation of the sentence for downstream tasks. This application was pioneered by Collobert et al. [5], Kalchbrenner et al. [43], Kim [44], which led to a huge proliferation of CNN-based networks in the succeeding literature. Below, we describe the working of a simple CNN-based sentence modeling network:
A. Basic CNN
1) Sentence Modeling For each sentence, let wi ! Rd represent the word embedding for the i th word in the sentence, where d is the dimension of the word embedding. Given that a sentence has n words, the sentence can now be represented as an embedding matrix W ! R n#d . Fig. 5 depicts such a sentence as an input to the CNN framework.

Let wi:i+j refer to the concatenation of vectors wi, wi+1, ..., w j . Convolution is performed on this input embedding layer. It involves a filter k ! Rhd which is applied to a window of h words to produce a new feature. For example, a feature ci is generated using the window of words wi:i+h-1 by
ci = f (wi:i+h-1 .kT + b)(6)
where b ! R is the bias term and f is a non-linear activation function, for example the hyperbolic tangent. The filter k is applied to all possible windows using the same weights to create the feature map.
c = [c1, c2, ..., cn-h+1] .(7)
In a CNN, a number of convolutional filters, also called kernels (typically hundreds), of different widths slide over the entire word embedding matrix. Each kernel extracts a specific pattern of n-gram. A convolution layer is usually

Softmax Classification
Fully Connected Layer
Max-Pool over Time
Convolution Layer

Lookup Table Feature k Feature 1

Input Sentence

wo

w1

wN –1

Figure 4 CNN framework used to perform word-wise class prediction proposed by Collobert and Weston [19].

august 2018 | IEEE Computational intelligence magazine 59

Textual Processing
I Love This Movie Very Much

Softmax

Input Embedding Sequence of Sentence

Convolution with Multiple Filter
Widths and Multiple Feature Maps

Max-Pooling Dense Layer Over Time

Figure 5 CNN modeling on text.

followed by a max-pooling strategy, ct = max {c}, which subsamples the input typically by applying a max operation on each filter. This strategy has two primary reasons.
Firstly, max pooling provides a fixedlength output which is generally req­­ uired for classification. Thus, regardless the size of the filters, max pooling always maps the input to a fixed dimension of outputs. Secondly, it reduces the output’s dimensionality while keeping the most salient n-gram features across the whole sentence.This is done in a translation invariant manner where each filter is now able to extract a particular feature (e.g., negations) from anywhere in the sentence and add it to the final sentence representation.
The word embeddings can be initialized randomly or pre-trained on a large unlabeled corpora (as in Section II). The latter option is sometimes found beneficial to performance, especially when the amount of labeled data is limited [44]. This combination of convolution layer followed by max pooling is often stacked to create deep CNN networks. These sequential convolutions help in improved mining of the sentence to grasp a truly abstract representation comprising rich semantic information.The kernels through deeper convolutions cover a larger part of the sentence until finally covering it fully and creating a global summarization of the sentence features.
2) Window Approach The above-mentioned architecture allows for modeling of complete sentences into sentence representations. However, many

NLP tasks, such as NER, POS tagging, and SRL, require word-based predictions. To adapt CNNs for such tasks, a window approach is used, which assumes that the tag of a word primarily depends on its neighboring words. For each word, thus, a fixed-size window surrounding itself is assumed and the sub-sentence ranging within the window is considered. A standalone CNN is applied to this subsentence as explained earlier and predictions are attributed to the word in the center of the window. Following this approach, Poria et al. [45] em­ployed a multi-level deep CNN to tag each word in a sentence as a possible aspect or nonaspect. Coupled with a set of linguistic patterns, their ensemble classifier managed to perform well in aspect detection.
The ultimate goal of word-level classification is generally to assign a sequence of labels to the entire sentence. In such cases, structured prediction techniques such as conditional random field (CRF) are sometimes employed to better capture dependencies between adjacent class labels and finally generate cohesive label sequence giving maximum score to the whole sentence [46].
To get a larger contextual range, the classic window approach is often coupled with a time-delay neural network (TDNN) [47]. Here, convolutions are performed across all windows throughout the sequence. These convolutions are generally constrained by defining a kernel having a certain width. Thus, while the classic window approach only considers the words in the window around the word to be labeled, TDNN considers all

windows of words in the sentence at the same time. At times, TDNN layers are also stacked like CNN architectures to extract local features in lower layers and global features in higher layers [5].
B. Applications In this section, we present some of the crucial works that employed CNNs on NLP tasks to set state-of-the-art benchmarks in their respective times.
Kim [44] explored using the above architecture for a variety of sentence classification tasks, including sentiment, subjectivity and question type classification, showing competitive results. This work was quickly adapted by researchers given its simple yet effective network. After training for a specific task, the randomly initialized convolutional kernels became specific n-gram feature detectors that were useful for that target task. This simple network, however, had many shortcomings with the CNN’s inability to model long distance dependencies standing as the main issue.
This issue was partly handled by Kalchbrenner et al. [43], who published a prominent paper where they proposed a dynamic convolutional neural network (DCNN) for semantic modeling of sentences. They proposed dynamic k -max pooling strategy which, given a sequence p selects the k most active features. The selection preserved the order of the features but was insensitive to their specific positions (Fig. 6). Built on the concept of TDNN, they added this dynamic k-max pooling strategy to create a sentence model. This combination allowed filters with small width to span across a long range within the input sentence, thus accumulating crucial information across the sentence. In the induced subgraph (Fig. 6), higher order features had highly variable ranges that could be either short and focused or global and long as the input sentence. They applied their model on multiple tasks, including sentiment prediction and question type classification, achieving significant results. Overall, this work commented on the range of individual kernels while trying to model contextual semantics and proposed a way to extend their reach.

60 IEEE Computational intelligence magazine | august 2018

Tasks involving sentiment analysis also require effective extraction of aspects along with their sentiment polarities [48]. Ruder et al. [49] applied a CNN where in the input they concatenated an aspect vector with the word embeddings to get competitive results. CNN modeling approach varies amongst different length of texts. Such differences were seen in many works like Johnson and Zhang [22], where performance on longer text worked well as opposed to shorter texts. Wang et al. [50] proposed the usage of CNN for modeling representations of short texts, which suffer from the lack of available context and, thus, require extra efforts to create meaningful representations. The authors proposed semantic clustering which introduced multi-scale semantic units to be used as external knowledge for the short texts. CNN was used to combine these units and form the overall representation. In fact, this requirement of high context information can be thought of as a caveat for CNNbased models. NLP tasks involving microtexts using CNN-based methods often require the need of additional information and external knowledge to perform as per expectations.This fact was also observed in [51], where authors performed sarcasm detection in Twitter texts using a CNN network.Auxiliary support, in the form of pre-trained networks trained on emotion, sentiment and personality datasets was used to achieve state-of-the-art performance.
CNNs have also been extensively used in other tasks. For example, Denil et al. [52] applied DCNN to map meanings of words that constitute a sentence to that of documents for summarization. The DCNN learned convolution filters at both the sentence and document level, hierarchically learning to capture and compose low-level lexical features into high-level semantic concepts. The focal point of this work was the introduction of a novel visualization technique of the learned representations, which provided insights not only in the learning process but also for automatic summarization of texts.
CNN models are also suitable for certain NLP tasks that require semantic

x1 x2 . . . . . . . . xn

x1 x2 . . . . . . . . xn

Figure 6 Representation of a DCNN subgraph. With dynamic pooling, a filter with small width at the higher layers can relate phrases far apart in the input sentence. DCNN was proposed by Kalchbrenner et al. [43].

matching [53]. A similar model to the above CNN architecture (Fig. 5) was explored in [54] for information retrieval. The CNN was used for projecting queries and documents to a fixed-dimension semantic space, where cosine similarity between the query and documents was used for ranking documents regarding a specific query. The model attempted to extract rich contextual structures in a query or a document by considering a temporal context window in a word sequence. This captured the contextual features at the word n-gram level. The salient word n-grams is then discovered by the convolution and max-pooling layers which are then aggregated to form the overall sentence vector.
In the domain of QA, Yih et al. [55] proposed to measure the semantic similarity between a question and entries in a knowledge base (KB) to determine what supporting fact in the KB to look for when answering a question. To create semantic representations, a CNN similar to the one in Fig. 5 was used. Unlike the classification setting, the supervision signal came from positive or negative text pairs (e.g., query-document), instead of class labels. Subsequently, Dong et al. [56] introduced a multi-column CNN (MCCNN) to analyze and understand questions from multiple aspects and create their representations. MCCNN used multiple column networks to extract information from aspects comprising answer types and

context from the input questions. By representing entities and relations in the KB with low-dimensional vectors, they used question-answer pairs to train the CNN model so as to rank candidate answers. Severyn and Moschitti [57] also used CNN network to model optimal representations of question and answer sentences. They proposed additional features in the embeddings in the form of relational information given by matching words between the question and answer pair. These parameters were tuned by the network. This simple network was able to produce comparable results to state-ofthe-art methods.
CNNs are wired in a way to capture the most important information in a sentence. Traditional max-pooling strategies perform this in a translation invariant form. However, this often misses valuable information present in multiple facts within the sentence. To overcome this loss of information for multiple-event modeling, Chen et al. [58] proposed a modified pooling strategy: dynamic multi-pooling CNN (DMCNN). This strategy used a novel dynamic multipooling layer that, as the name suggests, incorporates event triggers and arguments to reserve more crucial information from the pooling layer.
CNNs inherently provide certain required features like local connectivity, weight sharing, and pooling. This puts forward some degree of invariance which is highly desired in many tasks.

august 2018 | IEEE Computational intelligence magazine 61

Speech recognition also requires such invariance and, thus, Abdel-Hamid et al. [59] used a hybrid CNN-HMM model which provided invariance to frequency shifts along the frequency axis.This variability is often found in speech signals due to speaker differences. They also performed limited weight sharing which led to a smaller number of pooling parameters, resulting in lower computational complexity. Palaz et al. [60] performed extensive analysis of CNNbased speech recognition systems when given raw speech as input.They showed the ability of CNNs to directly model the relationship between raw input and phones, creating a robust automatic speech recognition system.
Tasks like machine translation re­­ quire perseverance of sequential information and long-ter m dependency. Thus, structurally they are not well suited for CNN networks, which lack these features. Nevertheless, Tu et al. [61] addressed this task by considering both the semantic similarity of the translation pair and their respective contexts. Although this method did not address the sequence perseverance problem, it allowed them to get competitive results amongst other benchmarks.
Overall, CNNs are extremely effective in mining semantic clues in contextual windows. However, they are very data heavy models. They include a large number of trainable parameters which require huge training data. This poses a problem when scarcity of data arises. Another persistent issue with CNNs is their inability to model long-distance contextual information and preserving sequential order in their representations [43], [61]. Although CNNs prove an effective way to capture n-gram features, which is approximately sufficient in certain sentence classification tasks, their sensitivity to word order is restricted locally and long-term dependencies are typically ignored.
IV. Recurrent Neural Networks RNNs [62] use the idea of processing sequential information. The term “recurrent” applies as they perform the same computation over each token of the

sequence and each step is dependent on the previous computations and results. Generally, a fixed-size vector is produced to represent a sequence by feeding tokens one by one to a recurrent unit. In a way, RNNs have “memory” over previous computations and use this information in current processing.This template is naturally suited for many NLP tasks such as language modeling [2], [63], [64], machine translation [65]–[67], speech recognition [68]–[71], image captioning [72]. This made RNNs increasingly popular for NLP applications in recent years.
A. Need for Recurrent Networks In this section, we analyze the fundamental properties that favored the popularization of RNNs in a multitude of NLP tasks. Given that an RNN performs sequential processing by modeling units in sequence, it has the ability to capture the inherent sequential nature present in language, where units are characters, words or even sentences. Words in a language develop their semantical meaning based on the previous words in the sentence. A simple example stating this would be the difference in meaning between “dog” and “hot dog”. RNNs are tailor-made for modeling such context dependencies in language and similar sequence modeling tasks, which turned to be a strong motivation for researchers to use RNNs over CNNs in these areas.
Another factor aiding RNN’s suitability for sequence modeling tasks lies in its ability to model variable length of text, including very long sentences, paragraphs and even documents [73]. Unlike CNNs, RNNs have flexible computational steps that provide better modeling capability and create the possibility to capture unbounded context. This ability became one of the selling points of major works using RNNs [74].
Many NLP tasks require semantic modeling over the whole sentence. This involves creating a gist of the sentence in a fixed dimensional hyperspace. RNN’s ability to summarize sentences led to their increased usage for tasks like machine translation [75] where the

whole sentence is summarized to a fixed vector and then mapped back to the variable-length target sequence.
RNN also provides the network support to perform time distributed joint processing. Most of the sequence labeling tasks like POS tagging [31] come under this domain. More specific use cases include applications such as multilabel text categorization [76], multimodal sentiment analysis [77]–[79], and subjectivity detection [80].
The above points enlist some of the focal reasons that motivated researchers to opt for RNNs. However, it would be gravely wrong to make conclusions on the superiority of RNNs over other deep networks. Recently, several works provided contrasting evidence on the superiority of CNNs over RNNs. Even in RNN-suited tasks like language modeling, CNNs achieved competitive performance over RNNs [81]. Both CNNs and RNNs have different objectives when modeling a sentence. While RNNs try to create a composition of an arbitrarily long sentence along with unbounded context, CNNs try to extract the most important n-grams.
Yin et al. [82] provided interesting insights on the comparative performance between RNNs and CNNs. After testing on multiple NLP tasks that included sentiment classification, QA, and POS tagging, they concluded that there is no clear winner: the performance of each network depends on the global semantics required by the task itself.
Below, we discuss some of the RNN models extensively used in the literature.
B. RNN Models
1) Simple RNN In the context of NLP, RNNs are primarily based on Elman network [62] and they are originally three-layer networks. Fig. 7 illustrates a more general RNN which is unfolded across time to accommodate a whole sequence. In the figure, xt is taken as the input to the network at time step t and st represents the hidden state at the same time step. Calculation of st is based as per the equation:

62 IEEE Computational intelligence magazine | august 2018

st = f (Uxt + Wst- 1) .(8)
Thus, st is calculated based on the current input and the previous time step’s hidden state. The function f is taken to be a non-linear transformation such as tanh, ReLU and U, V, W account for weights that are shared across time. In the context of NLP, xt typically comprises of one-hot encodings or embeddings. At times, they can also be abstract representations of textual content. qt illustrates the output of the network which is also often subjected to non-linearity, especially when the network contains further layers downstream.
The hidden state of the RNN is typically considered to be its most crucial element. As stated before, it can be considered as the network’s memory element that accumulates information from other time steps. In practice, however, these simple RNN networks suffer from the infamous vanishing gradient problem, which makes it really hard to learn and tune the parameters of the earlier layers in the network.
This limitation was overcome by various networks such as long shortterm memory (LSTM), gated recurrent units (GRUs), and residual networks (ResNets), where the first two are the most used RNN variants in NLP applications.
2) Long Short-Term Memory LSTM [83], [84] (Fig. 8) has additional “forget” gates over the simple RNN, which allows the error to back-propagate through an unlimited number of time steps. Consisting of three gates: input, forget and output gates, it calculates the hidden state by taking a combi-

o

ot −1

W

W

V

h

V

ht −1 V

Unfold U

U

x

xt −1

Figure 7 Simple RNN network.

ot
W ht V
U xt

ot +1
W ht +1
U xt +1

nation of these three gates as per the equations below:
x = ;hxt-t 1E(9) ft = v (W f . x + b f )(10) it = v (Wi . x + bi)(11) ot = v (Wo . x + bo)(12) ct = ft 9 ct- 1 + it 9 tanh (Wc . x + bc)
(13) ht = ot 9 tanh (ct) .(14)
3) Gated Recurrent Units Another gated RNN variant called GRU [75] (Fig. 8) of lesser complexity was invented with empirically similar performances to LSTM in most tasks. GRU comprises of two gates, reset gate and update gate, and handles the flow of information like an LSTM without a memory unit. Thus, it exposes the whole hidden content without any control. GRU can be a more efficient RNN than LSTM. The working of GRU is as follows:
z = v (Uz . xt + Wz . ht- 1)(15) r = v (Ur . xt + Wr . ht- 1)(16) st = tanh (Uz . xt + Ws . (ht- 1 9 r))(17) ht = (1 - z) 9 st + z 9 ht- 1.(18)

Researchers often face the dilemma of choosing the appropriate RNN. This also extends to developers working in NLP. Throughout the history, most of the choices over the RNN variant tended to be heuristic. Chung et al. [74] did a critical comparative evaluation of the three RNN variants mentioned above, although not on NLP tasks. They evaluated their work on tasks relating to polyphonic music modeling and speech signal modeling. Their evaluation clearly demonstrated the superiority of the gated units (LSTM and GRU) over the traditional simple RNN (in their case, using tanh activation). However, they could not make any concrete conclusion about which of the two gating units was better. This fact has been noted in other works too and, thus, people often leverage on other factors like computing power while choosing between the two.
C. Applications
1) RNN for Word-Level Classification RNNs have had a huge presence in the field of word-level classification. Many of their applications stand as state of the art in their respective tasks. Lample et al. [85] proposed to use bidirectional LSTM for NER. The network captured

r

f

i

o

xt ht –1

C˜

C tanh

ht

xt

s

z

ht

(1) Long Short-Term Memory Figure 8 Illustration of an LSTM and GRU gate.

(2) Gated Recurrent Unit

august 2018 | IEEE Computational intelligence magazine 63

arbitrarily long context information around the target word (curbing the limitation of a fixed window size) resulting in two fixed-size vector, on top of which another fully-connected layer was built. They used a CRF layer at last for the final entity tagging.
RNNs have also shown considerable improvement in language modeling over traditional methods based on count statistics. Pioneering work in this field was done by Graves [86], who introduced the effectiveness of RNNs in modeling complex sequences with long range context structures. He also proposed deep RNNs where multiple layers of hidden states were used to enhance the modeling. This work established the usage of RNNs on tasks beyond the context of NLP. Later, Sundermeyer et al. [87] compared the gain obtained by replacing a feed-forward neural network with an RNN when conditioning the prediction of a word on the words ahead. In their work, they proposed a typical hierarchy in neural network architectures where feed-forward neural networks gave considerable improvement over traditional count-based language models, which in turn were superseded by RNNs and later by LSTMs.An important point that they mentioned was the applicability of their conclusions to a variety of other tasks such as statistical machine translation [88].
2) RNN for Sentence-Level Classification Wang et al. [24] proposed encoding entire tweets with LSTM, whose hidden state is

used for predicting sentiment polarity. This simple strategy proved competitive to the more complex DCNN structure by Kalchbrenner et al. [43] designed to endow CNN models with ability to capture long-term dependencies. In a special case studying negation phrase, the authors also showed that the dynamics of LSTM gates can capture the reversal effect of the word “not”.
Similar to CNN, the hidden state of an RNN can also be used for semantic matching between texts. In dialogue systems, Lowe et al. [89] proposed to match a message with candidate responses with Dual-LSTM, which encodes both the message and response as fixed-size vectors and then measure their inner product as the basis to rank candidate responses.
3) RNN for Generating Language A challenging task in NLP is generating natural language, which is another natural application of RNNs. Conditioned on textual or visual data, deep LSTMs have been shown to generate reasonable taskspecific text in tasks such as machine translation, image captioning, etc.
In [67], the authors proposed a general deep LSTM encoder-decoder framework that maps a sequence to another sequence. One LSTM is used to encode the “source” sequence as a fixedsize vector, which can be text in the original language (machine translation), the question to be answered (QA) or the message to be replied to (dialogue systems). The vector is used as the initial state of another LSTM, named the

Output

p1

p2

pN – 1

Image

CNN

LSTM

LSTM

LSTM

w1

w2

wN – 1

True Image Description

Figure 9 Image captioning using CNN image embedder followed by LSTM decoder. This architecture was proposed by Vinyals et al. [90].

decoder. The decoder generates tokens one by one, while updating its hidden state with the last generated token.
Sutskever et al. [67] experimented with 4-layer LSTM on a machine translation task in an end-to-end fashion, showing competitive results. In [91], the same encoder-decoder framework is employed to model human conversations. When trained on more than 100 million message-response pairs, the LSTM de­­ coder is able to generate very interesting responses in the open domain. It is also common to condition the LSTM de­­ coder on additional signal to achieve certain effects. In [92], the authors proposed to condition the decoder on a constant persona vector that captures the personal information of an individual speaker. In the above cases, language is generated based mainly on the semantic vector representing textual input. Similar frameworks have also been successfully used in image-based language generation, where visual features are used to condition the LSTM decoder (Fig. 9).
Visual QA is another task that requires language generation based on both textual and visual clues. Malinowski et al. [93] were the first to provide an end-to-end deep learning solution where they predicted the answer as a sequence of words conditioned on the input image modeled by a CNN and text modeled by an LSTM.
D. Attention Mechanism One potential problem that the traditional encoder-decoder framework faces is that the encoder at times is forced to encode information which might not be fully relevant to the task at hand. The problem arises also if the input is long or very information-rich and selective encoding is not possible.
For example, the task of text summarization can be cast as a sequence-tosequence learning problem, where the input is the original text and the output is the condensed version. Intuitively, it is unrealistic to expect a fixed-size vector to encode all information in a piece of text whose length can potentially be very long. Similar problems have also been reported in machine translation [94].

64 IEEE Computational intelligence magazine | august 2018

In tasks such as text summarization and machine translation, certain alignment exists between the input text and the output text, which means that each token generation step is highly related to a certain part of the input text.This intuition inspires the attention mechanism. This mechanism attempts to ease the above problems by allowing the decoder to refer back to the input sequence. Specifically during decoding, in addition to the last hidden state and generated token, the decoder is also conditioned on a “context” vector calculated based on the input hidden state sequence.
Bahdanau et al. [94] first applied the attention mechanism to machine translation, which improved the performance especially for long sequences. In their work, the attention signal over the input hidden state sequence is determined with a multi-layer perceptron by the last hidden state of the decoder. By visualizing the attention signal over the input sequence during each decoding step, a clear alignment between the source and target language can be demonstrated.
A similar approach was applied to the task of text summarization by Rush et al. [95] where each output word in the summary was conditioned on the input sentence through an attention mechanism. The authors performed abstractive summarization which is not very conventional as opposed to extractive summarization, but can be scaled up to large data with minimal linguistic input.
In image captioning, Xu et al. [96] conditioned the LSTM decoder on different parts of the input image during each decoding step. Attention signal was determined by the previous hidden state and CNN features. In [97], the authors cast the syntactical parsing problem as a sequence-to-sequence learning task by linearizing the parsing tree. The attention mechanism proved to be more data-efficient in this work. A further step in referring to the input sequence was to directly copy words or sub-sequences of the input onto the output sequence under a certain condition [98], which was useful in tasks such as dialogue generation and text summarization. Copy-

Weighted Combination

Attention

Aspect Embedding

Hidden Representation

h1

LSTM

LSTM

hn LSTM

Input Sentence

w1

w2

wn

Figure 10 Aspect classification using attention. The original attention-based model in this application was proposed by Wang et al. [100].

ing or generation was chosen at each time step during decoding [99].
In aspect-based sentiment analysis, Wang et al. [100] proposed an attentionbased solution where they used aspect embeddings to provide additional support during classification (Fig. 10). The attention module focused on selective regions of the sentence which affected the aspect to be classified. Recently, Ma et al. [101] augmented LSTM with a hierarchical attention mechanism consisting of a target-level attention and a sentence-level attention to exploit commonsense knowledge for targeted aspect-based sentiment analysis.
Given the intuitive applicability of attention modules, they are still being actively investigated by NLP researchers and adopted for an increasing number of applications.

pretations of sentence structure [4]. Specifically, in a recursive neural network, the representation of each non-terminal node in a parsing tree is determined by the representations of all its children.
A. Basic Model In this section, we describe the basic structure of recursive neural networks. As shown in Fig. 11, the network g defines a compositional function on the representations of phrases or words (b, c or a, p1) to compute the representation of a higher-level phrase ( p1 or p2). The representations of all nodes take the same form.
p2 = g (a, p1) (on the mat)

V. Recursive Neural Networks RNNs represent a natural way to model sequences. Arguably, however, language exhibits a natural recursive structure, where words and sub-phrases combine into phrases in a hierarchical manner. Such structure can be represented by a constituency parsing tree. Thus, treestructured models have been used to better make use of such syntactic inter-

p1 = g (b, c) (the mat)

a (on) b (the)

c (mat)

Figure 11 Recursive neural networks iteratively form high-level representation from lower-level representations.

august 2018 | IEEE Computational intelligence magazine 65

Recurrent Neural Networks use the idea of processing sequential information. The term “recurrent” applies as they perform the same computation over each token of the sequence and each step is dependent on the previous computations and results.

In [4], the authors described multiple variations of this model. In its simplest form, g is defined as:
p1 = tanhcW;bc Em, p2 = tanhcW;pa1Em (19)
in which the representation for each node is a d-dimensional vector and W ! RD#2D.
Another variation is the MV-RNN [102]. The idea is to represent every word and phrase as both a matrix and a vector. When two constituents are combined, the matrix of one is multiplied with the vector of the other:
p1 = tanhcW;CBcbEm, P1 = tanhcWM ;CBEm (20)
in which b, c, p1 ! RD, B, C, P1 ! RD#D, and WM ! RD#2D. Compared to the vanilla form, MV-RNN parameterizes the compositional function with matrices corresponding to the constituents.
The recursive neural tensor network (RNTN) is proposed to introduce more interaction between the input vectors without making the number of parameters exceptionally large like MV-RNN. RNTN is defined by:
p1 = tanhc;bc ET V[1:D] ;bc E + W;bc Em (21)
where V ! R2D#2D#D is a tensor that defines multiple bilinear forms.
B. Applications One natural application of recursive neural networks is parsing [10]. A scoring function is defined on the phrase representation to calculate the plausibility of that phrase. Beam search is usually applied for searching the best tree. The

model is trained with the max-margin objective [103].
Based on recursive neural networks and the parsing tree, Socher et al. [4] proposed a phrase-level sentiment an­­ alysis framework, where each node in the parsing tree can be assigned a sentiment label.
Socher et al. [102] classified semantic relationships such as cause-effect or topic-message between nominals in a sentence by building a single compositional semantics for the minimal constituent including both terms. Bowman et al. [104] proposed to classify the logical relationship between sentences with recursive neural networks.The representations for both sentences are fed to another neural network for relationship classification. They show that both vanilla and tensor versions of the recursive unit performed competitively in a textual entailment dataset.
To avoid the gradient vanishing problem, LSTM units have also been applied to tree structures in [105]. The authors showed improved sentence representation over linear LSTM models, as clear improvement in sentiment analysis and sentence relatedness tests was observed.
VI. Deep Reinforced Models and Deep Unsupervised Learning
A. Reinforcement Learning for Sequence Generation Reinforcement learning is a method of training an agent to perform discrete actions before obtaining a reward. In NLP, tasks concerning language generation can sometimes be cast as reinforcement learning problems.
In its original formulation, RNN language generators are typically trained by maximizing the likelihood of each

token in the ground-truth sequence given the current hidden state and the previous tokens. Termed “teacher forcing”, this training scheme provides the real sequence prefix to the generator during each generation (loss evaluation) step. At test time, however, ground-truth tokens are then replaced by a token generated by the model itself. This discrepancy between training and inference, termed “exposure bias” [106], [107], can yield errors that can accumulate quickly along the generated sequence.
Another problem with the wordlevel maximum likelihood strategy, when training auto-regressive language generation models, is that the training objective is different from the test metric. It is unclear how the n-gram overlap based metrics (BLEU, ROUGE) used to evaluate these tasks (machine translation, dialogue systems, etc.) can be optimized with the word-level training strategy. Empirically, dialogue systems trained with word-level maximum likelihood also tend to produce dull and shortsighted responses [108], while text summarization tends to produce incoherent or repetitive summaries [99].
Reinforcement learning offers a prospective to solve the above problems to a certain extent. In order to optimize the non-differentiable evaluation metrics directly, Ranzato et al. [107] applied the REINFORCE algorithm [109] to train RNN-based models for several sequence generation tasks (e.g., text summarization, machine translation and image captioning), leading to improvements compared to previous supervised learning methods. In such a framework, the generative model (RNN) is viewed as an agent, which interacts with the external environment (the words and the context vector it sees as input at every time step). The parameters of this agent defines a policy, whose execution results in the agent picking an action, which refers to predicting the next word in the sequence at each time step. After taking an action the agent updates its internal state (the hidden units of RNN). Once the agent has reached the end of a sequence, it observes a reward.This reward can be any developer-defined metric

66 IEEE Computational intelligence magazine | august 2018

tailored to a specific task. For example, Li et al. [108] defined 3 rewards for a generated sentence based on ease of answering, information flow, and semantic coherence.
There are two well-known shortcomings of reinforcement learning. To make reinforcement learning tractable, it is desired to carefully handle the state and action space [110], [111], which in the end may restrict expressive power and learning capacity of the model. Secondly, the need for training the reward functions makes such models hard to design and measure at run time [112], [113].
Another approach for sequence-level supervision is to use the adversarial training technique [114], where the training objective for the language generator is to fool another discriminator trained to distinguish generated sequences from real sequences.The generator G and the discriminator D are trained jointly in a min-max game which ideally leads to G, generating sequences indistinguishable from real ones. This approach can be seen as a variation of generative adversarial networks in [114], where G and D are conditioned on certain stimuli (for example, the source image in the task of image captioning). In practice, the above scheme can be realized under the reinforcement learning paradigm with policy gradient. For dialogue systems, the discriminator is analogous to a human Turing tester, who discriminates between human and machine-produced dialogues [115].
B. Unsupervised Sentence Representation Learning Similar to word embeddings, distributed representation for sentences can also be learned in an unsupervised fashion. The result of such unsupervised learning are “sentence encoders”, which map arbitrary sentences to fixed-size vectors that can capture their semantic and syntactic properties. Usually an auxiliary task has to be defined for the learning process.
Similar to the skip-gram model [8] for learning word embeddings, the skipthought model [116] was proposed for learning sentence representation, where

Recent success in generating realistic images has driven a series of efforts on applying deep generative models to text data. The promise of such research is to discover rich structure in natural language while generating realistic sentences from a latent code space.

the auxiliary task was to predict two adjacent sentences (before and after) based on the given sentence. The seq2seq model was employed for this learning task. One LSTM encoded the sentence to a vector (distributed representation). Two other LSTMs decoded such representation to generate the target sequences. The standard seq2seq training process was used. After training, the encoder could be seen as a generic feature extractor (word embeddings were also learned in the same time).
Kiros et al. [116] verified the quality of the learned sentence encoder on a range of sentence classification tasks, showing competitive results with a simple linear model based on the static feature vectors. However, the sentence encoder can also be fine-tuned in the supervised learning task as part of the classifier. Dai and Le [117] investigated the use of the decoder to reconstruct the encoded sentence itself, which resembled an autoencoder [118].
Language modeling could also be used as an auxiliary task when training LSTM encoders, where the supervision signal came from the prediction of the next token. Dai and Le [117] conducted experiments on initializing LSTM models with learned parameters on a variety of tasks. They showed that pre-training the sentence encoder on a large unsupervised corpus yielded better accuracy than only pre-training word embeddings. Also, predicting the next token turned out to be a worse auxiliary objective than reconstructing the sentence itself, as the LSTM hidden state was only responsible for a rather short-term objective.
C. Deep Generative Models Recent success in generating realistic images has driven a series of efforts on applying deep generative models to text

data. The promise of such research is to discover rich structure in natural language while generating realistic sentences from a latent code space. In this section, we review recent research on achieving this goal with variational autoencoders (VAEs) [119] and generative adversarial networks (GANs) [114].
Standard sentence autoencoders, as in the last section, do not impose any constraint on the latent space, as a result, they fail when generating realistic sentences from arbitrary latent representations [120]. The representations of these sentences may often occupy a small region in the hidden space and most of regions in the hidden space do not necessarily map to a realistic sentence [121]. They cannot be used to assign probabilities to sentences or to sample novel sentences [120].
The VAE imposes a prior distribution on the hidden code space which makes it possible to draw proper samples from the model. It modifies the autoencoder architecture by replacing the deterministic encoder function with a learned posterior recognition model. The model consists of encoder and generator networks which encode data examples to latent representation and generate samples from the latent space, respectively. It is trained by maximizing a variational lower bound on the loglikelihood of observed data under the generative model.
Bowman et al. [120] proposed an RNN-based variational autoencoder generative model that incorporated distributed latent representations of entire sentences (Fig. 12). Unlike vanilla RNN language models, this model worked from an explicit global sentence representation. Samples from the prior over these sentence representations produced diverse and well-formed sentences.

august 2018 | IEEE Computational intelligence magazine 67

A generative neural network decodes latent representation to a data instance, while the discriminative network is simultaneously taught to discriminate between instances from the true data distribution and synthesized instances produced by the generator.

Hu et al. [122] proposed generating sentences whose attributes are controlled by learning disentangled latent representations with designated semantics. The authors augmented the latent code in the VAE with a set of structured variables, each targeting a salient and independent semantic feature of sentences. The model incorporated VAE and attribute discriminators, in which the VAE component trained the generator to reconstruct real sentences for generating plausible text, while the discriminators forced the generator to produce attributes coherent with the structured code. When trained on a large number of unsupervised sentences and a small number of labeled sentences, Hu et al. [122] showed that the model was able to generate plausible sentences conditioned on two major attributes of English: tense and sentiment.
GAN is another class of generative model composed of two competing networks. A generative neural network decodes latent representation to a data instance, while the discriminative network is simultaneously taught to dis-

criminate between instances from the true data distribution and synthesized instances produced by the generator. GAN does not explicitly represent the true data distribution p (x).
Zhang et al. [121] proposed a framework for employing LSTM and CNN for adversarial training to generate realistic text. The latent code z was fed to the LSTM generator at every time step. CNN acted as a binary sentence classifier which discriminated between real data and generated samples. One problem with applying GAN to text is that the gradients from the discriminator cannot properly back-propagate through discrete variables. In [121], this problem was solved by making the word prediction at every time “soft” at the word embedding space. Yu et al. [123] proposed to bypass this problem by modeling the generator as a stochastic policy. The reward signal came from the GAN discriminator judged on a complete sequence, and was passed back to the intermediate stateaction steps using Monte Carlo search.
The evaluation of deep generative models has been challenging. For text, it

z

µ

Linear

Linear

Decoder

y1

y2

<EOS>

LSTM

LSTM

LSTM

<EOS>

y1

y2

LSTM

LSTM

LSTM

x1

x2

x3

Encoder

Figure 12 RNN-based VAE network for sentence generation proposed by Bowman et al. [120].

is possible to create oracle training data from a fixed set of grammars and then evaluate generative models based on whether (or how well) the generated samples agree with the predefined grammar [124]. Another strategy is to evaluate BLEU scores of samples on a large amount of unseen test data. The ability to generate similar sentences to unseen real data is considered a measurement of quality [123].
VII. Memory-Augmented Networks The attention mechanism stores a series of hidden vectors of the encoder, which the decoder is allowed to access during the generation of each token. Here, the hidden vectors of the encoder can be seen as entries of the model’s “internal memory”. Recently, there has been a surge of interest in coupling neural networks with a form of memory, which the model can interact with.
In [135], the authors proposed memory networks for QA tasks. In synthetic QA, a series of statements (memory entries) were provided to the model as potential supporting facts to the question. The model learned to retrieve one entry at a time from memory based on the question and previously retrieved memory. In large-scale realistic QA, a large set of commonsense knowledge in the form of (subject, relation, object) triples were used as memory.
Sukhbaatar et al. [136] extended this work and proposed end-to-end memory networks, where memory entries were retrieved in a “soft” manner with attention mechanism, thus enabling endto-end training. Multiple rounds (hops) of information retrieval from memory were shown to be essential to good performance and the model was able to retrieve and reason about several supporting facts to answer a specific question. They also showed a special use of the model for language modeling, where each word in the sentence was seen as a memory entry.With multiple hops, the model yielded results comparable to deep LSTM models.
Furthermore, dynamic memory networks (DMN) [128] improved upon previous memory-based models by

68 IEEE Computational intelligence magazine | august 2018

TABLE 2 POS tagging. Paper Giménez and Marquez [125] Collobert et al. [5] Santos and Zadrozny [31] Huang et al. [126] Huang et al. [126] Huang et al. [126] Huang et al. [126] Andor et al. [127] Kumar et al. [128]

Model SVM with manual feature pattern MLP with word embeddings + CRF MLP with character + word embeddings LSTM Bidirectional LSTM LSTM-CRF Bidirectional LSTM-CRF Transition-based neural network DMN

WSJ-PTB (per-token accuracy %) 97.16 97.29 97.32 97.29 97.40 97.54 97.55 97.45 97.56

TABLE 3 Parsing (UAS/LAS = Unlabeled/labeled Attachment Score; WSJ = The Wall Street Journal Section of Penn Treebank).

Parsing type

Paper

Model

WSJ

Dependency Parsing Chen and Manning [129] Fully-connected NN with features including POS

91.8/89.6 (UAS/LAS)

Weiss et al. [130]

Deep fully-connected NN with features including POS 94.3/92.4 (UAS/LAS)

Dyer et al. [131]

Stack-LSTM

93.1/90.9 (UAS/LAS)

Zhou et al. [132]

Beam contrastive model

93.31/92.37 (UAS/LAS)

Constituency Parsing Petrov et al. [133]

Probabilistic context-free grammars (PCFG)

91.8 (F1 Score)

Socher et al. [10]

Recursive neural networks

90.29 (F1 Score)

Zhu et al. [134]

Feature-based transition parsing

91.3 (F1 Score)

Vinyals et al. [97]

seq2seq learning with LSTM+Attention

93.5 (F1 Score)

employing neural network models for input representation, attention, and answer mechanisms. The resulting model was applicable to a wide range of NLP tasks (QA, POS tagging, and sentiment analysis), as every task could be cast to the <memory, question, answer> triple format. Xiong et al. [137] applied the same model to visual QA and proved that the memory module was applicable to visual signals.
VIII. Performance of Different Models on Different NLP Tasks We summarize the performance of a series of deep learning methods on standard datasets developed in recent years on 7 major NLP topics in Tables 2–7. Our goal is to show the readers common datasets used in the community and state-of-the-art results along with different models.
A. POS Tagging The WSJ-PTB (the Wall Street Journal part of the Penn Treebank Dataset) corpus contains 1.17 million tokens and has

TABLE 4 Named-Entity Recognition.

Paper

Model

Collobert et al. [5]

MLP with word embeddings+gazetteer

Passos et al. [138]

Lexicon Infused Phrase Embeddings

Chiu and Nichols [139] Bi-LSTM with word+char+lexicon embeddings

Luo et al. [140]

Semi-CRF jointly trained with linking

Lample et al. [85]

Bi-LSTM-CRF with word+char ­embeddings

Lample et al. [85]

Bi-LSTM with word+char embeddings

Strubell et al. [141]

Dilated CNN with CRF

CoNLL 2003 (F1%) 89.59
90.90 90.77
91.20 90.94
89.15 90.54

been widely used for developing and evaluating POS tagging systems. Giménez and Marquez [125] employed one-against-all SVM based on manually-defined features within a sevenword window, in which some basic n-gram patterns were evaluated to form binary features such as:“previous word is the”, “two preceding tags are DT NN”, etc. One characteristic of the POS tagging problem was the strong dependen-

cy between adjacent tags. With a simple left-to-right tagging scheme, this method modeled dependencies between adjacent tags only by feature engineering. In an effort to reduce feature engineering, Collobert et al. [5] relied on only word embeddings within the word window with a multi-layer perceptron. Incorporating CRF was proven useful in [5]. Santos and Zadrozny [31] concatenated word embeddings with character

august 2018 | IEEE Computational intelligence magazine 69

TABLE 5 Semantic Role Labeling.

Paper

Model

Collobert et al. [5]

CNN with parsing features

Täckström et al. [142]

Manual features with DP for inference

Zhou and Xu [143]

Bidirectional LSTM

He et al. [144]

Bidirectional LSTM with highway connections

CoNLL2005 (F1%) 76.06 78.6 81.07 83.2

CoNLL2012 (F1%)
79.4 81.27 83.4

TABLE 6 Sentiment Classification (SST-1 = Stanford Sentiment Treebank, fine-grained 5 classes Socher et al. [4]; SST-2: the binary version of SST-1; Numbers are accuracies (%)).

Paper

Model

SST-1

Socher et al. [4]

Recursive Neural Tensor Network 45.7

Kim [44]

Multichannel CNN

47.4

Kalchbrenner et al. [43] DCNN with k-max pooling

48.5

Tai et al. [105]

Bidirectional LSTM

48.5

Le and Mikolov [145]

Paragraph Vector

48.7

Tai et al. [105]

Constituency Tree-LSTM

51.0

Yu et al. [146]

Tree-LSTM with refined word

54.0

­embeddings

Kumar et al. [128]

DMN

52.1

SST-2 85.4 88.1 86.8 87.2 87.8 88.0 90.3
88.6

embeddings to better exploit morphological clues. In [31], the authors did not consider CRF, but since word-level decision was made on a context window, dependencies between adjacent tags were modeled implicitly. Huang et al. [126] concatenated word embeddings and manually-designed word-level features and employed bidirectional LSTM to model arbitrarily long context. A series of ablative analysis suggested that bi-directionality and CRF both boosted performance.Andor et al. [127] showed a transition-based approach that produces competitive result with a simple feedforward neural network. When applied to sequence tagging tasks, DMNs [128] essentially allowed for attending over the

context multiple times by treating each RNN hidden state as a memory entry, each time focusing on different parts of the context.
B. Parsing There are two types of parsing: dependency parsing, which connects individual words with their relations, and constituency parsing, which iteratively breaks text into sub-phrases. Transitionbased methods are a popular choice since they are linear in the length of the sentence. The parser makes a series of decisions that read words sequentially from a buffer and combine them incrementally into the syntactic structure [129]. At each time step, the decision is

made based on a stack containing available tree nodes, a buffer containing unread words and the obtained set of dependency arcs. Chen and Manning [129] modeled the decision making at each time step with a neural network with one hidden layer. The input layer contained embeddings of certain words, POS tags and arc labels, which came from the stack, the buffer and the set of arc labels.
Tu et al. [61] extended the work of Chen and Manning [129] by employing a deeper model with 2 hidden layers. However, both Tu et al. [61] and Chen and Manning [129] relied on manual feature selecting from the parser state, and they only took into account a limited number of latest tokens. Dyer et al. [131] proposed stack-LSTMs to model arbitrarily long history. The end pointer of the stack changed position as the stack of tree nodes could be pushed and popped. Zhou et al. [132] integrated beam search and contrastive learning for better optimization.
Transition-based models were applied to constituency parsing as well. Zhu et al. [134] based each transition action on features such as the POS tags and constituent labels of the top few words of the stack and the buffer. By uniquely representing the parsing tree with a linear sequence of labels, Vinyals et al. [97]

TABLE 7 Machine translation (Numbers are BLEU scores).

Paper Cho et al. [75] Sutskever et al. [67] Wu et al. [147] Gehring et al. [148] Vaswani et al. [149]

Model Phrase table with neural features Reranking phrase-based SMT best list with LSTM seq2seq Residual LSTM seq2seq + Reinforcement learning refining seq2seq with CNN Attention mechanism

WMT2014 ­English2German
26.30 26.36 28.4

WMT2014 ­English2French 34.50 36.5 41.16 41.29 41.0

70 IEEE Computational intelligence magazine | august 2018

applied the seq2seq learning method to this problem.
C. Named-Entity Recognition CoNLL 2003 has been a standard English dataset for NER, which concentrates on four types of named entities: people, locations, organizations and miscellaneous entities. NER is one of the NLP problems where lexicons can be very useful. Collobert et al. [5] first achieved competitive results with neural structures augmented by gazetteer features. Chiu and Nichols [139] concatenated lexicon features, character embeddings and word embeddings and fed them as input to a bidirectional LSTM. On the other hand, Lample et al. [85] only relied on character and word embeddings, with pre-training embeddings on large unsupervised corpora, they achieved competitive results without using any lexicon. Similar to POS tagging, CRF also boosted the performance of NER, as demonstrated by the comparison in [85]. Overall, we see that bidirectional LSTM with CRF acts as a strong model for NLP problems related to structured prediction.
Passos et al. [138] proposed to modify skip-gram models to better learn entitytype related word embeddings that can leverage information from relevant lexicons. Luo et al. [140] jointly optimized the entities and the linking of entities to a KB. Strubell et al. [141] proposed to use dilated convolutions, defined over a wider effective input width by skipping over certain inputs at a time, for better parallelization and context modeling. The model showed significant speedup while retaining accuracy.
D. Semantic Role Labeling Semantic role labeling (SRL) aims to discover the predicate-argument structure of each predicate in a sentence. For each target verb (predicate), all constituents in the sentence which take a semantic role of the verb are recognized. Typical semantic arguments include Agent, Patient, Instrument, etc., and also adjuncts such as Locative, Temporal, Manner, Cause, etc. [143]. Table 5 shows the performance of different models on the CoNLL 2005&2012 datasets.

Recently, there has been a surge of interest in coupling neural networks with a form of memory, which the model can interact with.

Traditional SRL systems consist of several stages: producing a parse tree, identifying which parse tree nodes represent the arguments of a given verb, and finally classifying these nodes to determine the corresponding SRL tags. Each classification process usually entails extracting numerous features and feeding them into statistical models [5].
Given a predicate, Täckström et al. [142] scored a constituent span and its possible role to that predicate with a series of features based on the parse tree. They proposed a dynamic programming algorithm for efficient inference. Collobert et al. [5] achieved comparable results with a convolution neural networks augmented by parsing information provided in the form of additional look-up tables. Zhou and Xu [143] proposed to use bidirectional LSTM to model arbitrarily long context, which proved to be successful without any parsing tree information. He et al. [144] further extended this work by introducing highway connections [150], more advanced regularization and ensemble of multiple experts.
E. Sentiment Classification The Stanford Sentiment Treebank (SST) dataset contains sentences taken from the movie review website Rotten Tomatoes. It was proposed by Pang and Lee [151] and subsequently extended by Socher et al. [4]. The annotation scheme has inspired a new dataset for sentiment analysis, called CMU-MOSI, where sentiment is studied in a multimodal setup [152].
Socher et al. [4] and Tai et al. [105] were both recursive networks that relied on constituency parsing trees. Their difference shows the effectiveness of LSTM over vanilla RNN in modeling sentences. On the other hand, treeLSTM performed better than linear bidirectional LSTM, implying that tree structures can potentially better capture the syntactical property of natural sen-

tences.Yu et al. [146] proposed to refine pre-trained word embeddings with a sentiment lexicon, observing improved results based on [105].
Kim [44] and Kalchbrenner et al. [43] both used convolutional layers. The model [44] was similar to the one in Fig. 5, while Kalchbrenner et al. [43] constructed the model in a hierarchical manner by interweaving k-max pooling layers with convolutional layers.
F. Machine Translation The phrase-based SMT framework [160] factorized the translation model into the translation probabilities of matching phrases in the source and target sentences. Cho et al. [75] proposed to learn the translation probability of a source phrase to a corresponding target phrase with an RNN encoder-decoder. Such a scheme of scoring phrase pairs improved translation performance. Sutskever et al. [67], on the other hand, re-scored the top 1000 best candidate translations produced by an SMT system with a 4-layer LSTM seq2seq model. Dispensing the traditional SMT system entirely, Wu et al. [147] trained a deep LSTM network with 8 encoder and 8 decoder layers with residual connections as well as attention connections. Wu et al. [147] then refined the model by using reinforcement learning to directly optimize BLEU scores, but they found that the improvement in BLEU scores by this method did not reflect in human evaluation of translation quality. Recently, Gehring et al. [148] proposed a CNN-based seq2seq learning model for machine translation. The representation for each word in the input is computed by CNN in a parallelized style for the attention mechanism. The decoder state is also determined by CNN with words that are already produced. Vaswani et al. [149] proposed a self-attention-based model and dispensed convolutions and recurrences entirely.

august 2018 | IEEE Computational intelligence magazine 71

We expect to see more deep learning models whose internal memory (bottom-up knowledge learned from the data) is enriched with an external memory (top-down knowledge inherited from a knowledge base).

G. Question Answering QA problems take many forms. Some rely on large KBs to answer opendomain questions, while others answer a question based on a few sentences or a paragraph (reading comprehension). For the former, we list (see Table 8) several experiments conducted on a large-scale QA dataset introduced by [153], where 14 M commonsense knowledge triples are considered as the KB. Each question can be answered with a single-relation query. For the latter, we consider (see Table 8) the synthetic dataset of bAbI, which requires the model to reason over multiple related facts to produce the right answer. It contains 20 synthetic tasks that test a model’s ability to retrieve relevant facts and reason over them. Each task focuses on a different skill such as basic coreference and size reasoning.
The central problem of learning to answer single-relation queries is to find

the single supporting fact in the database. Fader et al. [153] proposed to tackle this problem by learning a lexicon that maps natural language patterns to database concepts (entities, relations and question patterns) based on a question paraphrasing dataset. Bordes et al. [154] embedded both questions and KB triples as dense vectors and scored them with inner product.
Weston et al. [135] took a similar approach by treating the KB as longterm memory, while casting the problem in the framework of a memory network. On the bAbI dataset, Sukhbaatar et al. [136] improved upon the original memory networks model [135] by making the training procedure agnostic of the actual supporting fact, while Kumar et al. [128] used neural sequence models (GRU) instead of neural bag-ofwords models as in [136] and [135] to embed memories.

H. Dialogue Systems Two types of dialogue systems have been developed: generation-based models and retrieval-based models.
In Table 9, the Twitter Conversation Triple Dataset is typically used for evaluating generation-based dialogue ­systems, containing 3-turn Twitter conversation instances. One commonly used evaluation metric is BLEU [161], al­t­hough it is commonly acknowledged that most automatic evaluation metrics are not completely reliable for dialogue evaluation and additional human evaluation is often necessary. Ritter et al. [155] employed the phrase-based statistical machine translation (SMT) framework to “translate” the message to its appropriate response. Sordoni et al. [156] reranked the 1000 best responses produced by SMT with a context-sensitive RNN encoder-decoder framework, observing substantial gains. Li et al. [157] reported results on replacing the traditional maximum log likelihood training objective with the maximum mutual information training objective, in an effort to produce interesting and diverse responses, both of which are tested on a 4-layer LSTM encoderdecoder framework.

TABLE 8 Question answering.

Paper

Model

Fader et al. [153]

Paraphrase-driven lexicon learning

Bordes et al. [154]

Weekly supervised embedding

Weston et al. [135]

Memory networks

Sukhbaatar et al. [136]

End-to-end memory networks

Kumar et al. [128]

DMN

bAbI (Mean accuracy %)
93.3 88.4 93.6

Farbes (Accuracy %) 0.54 0.73 0.83

TABLE 9 Dialogue systems.

Paper Ritter et al. [155] Sordoni et al. [156] Li et al. [157] Li et al. [157] Lowe et al. [89] Dodge et al. [158] Zhou et al. [159]

Model SMT SMT+neural reranking LSTM seq2seq LSTM seq2seq with MMI objective Dual LSTM encoders for semantic matching Memory networks Sentence-level CNN-LSTM encoder

Twitter Conversation ­Triple Dataset (BLEU) 3.60 4.44 4.51 5.22

Ubuntu Dialogue Dataset (recall 1@10%)
55.22 63.72 66.15

72 IEEE Computational intelligence magazine | august 2018

The response retrieval task is defined as selecting the best response from a repository of candidate responses. Such a model can be evaluated by the recall1@k metric, where the ground-truth response is mixed with k - 1 random responses. The Ubuntu dialogue dataset was constructed by scraping multi-turn Ubuntu trouble-shooting dialogues from an online chatroom [89]. Lowe et al. [89] used LSTMs to encode the message and response, and then inner product of the two sentence embeddings is used to rank candidates.
Zhou et al. [159] proposed to better exploit the multi-turn nature of human conversation by employing the LSTM encoder on top of sentence-level CNN embeddings, similar to [162]. Dodge et al. [158] cast the problem in the framework of a memory network, where the past conversation was treated as memory and the latest utterance was considered as a “question” to be responded to. The authors showed that using simple neural bag-of-word embedding for sentences can yield competitive results.
IX. Conclusion Deep learning offers a way to harness large amount of computation and data with little engineering by hand [163]. With distributed representation, various deep models have become the new state-of-the-art methods for NLP problems. Supervised learning is the most popular practice in recent deep learning research for NLP. In many real-world scenarios, however, we have unlabeled data which require advanced unsupervised or semi-supervised approaches. In cases where there is lack of labeled data for some particular classes or the appearance of a new class while testing the model, strategies like zero-shot learning should be employed. These learning schemes are still in their developing phase but we expect deep learning based NLP research to be driven in the direction of making better use of unlabeled data. We expect such trend to continue with more and better model designs. We expect to see more NLP applications that employ reinforcement learning methods, e.g., dialogue systems.

We also expect to see more research on
multimodal learning [164] as, in the real
world, language is often grounded on
(or correlated with) other signals.
Finally, we expect to see more deep
learning models whose internal mem-
ory (bottom-up knowledge learned
from the data) is enriched with an
external memory (top-down knowledge
inherited from a KB). Coupling sym-
bolic and sub-symbolic AI will be key
for stepping forward in the path from
NLP to natural language understanding.
Relying on machine learning, in fact, is
good to make a ‘good guess’ based on
past experience, because sub-symbolic
methods encode correlation and their
decision-making process is probabilistic.
Natural language understanding, how-
ever, requires much more than that. To
use Noam Chomsky’s words, “you do
not get discoveries in the sciences by
taking huge amounts of data, throwing
them into a computer and doing statisti-
cal analysis of them: that’s not the way
you understand things, you have to have
theoretical insights”.
References
[1] E. Cambria and B. White, “Jumping NLP curves: A review of natural language processing research,” IEEE Comput. Intell. Mag., vol. 9, no. 2, pp. 48–57, May 2014. [2] T. Mikolov, M. Karafiát, L. Burget, J. Cernocký, and S. Khudanpur, “Recurrent neural network based language model,” in Proc. Interspeech, vol. 2, p. 3, 2010. [3] T. Mikolov, I. Sutskever, K. Chen, G. S. Corrado, and J. Dean, “Distributed representations of words and phrases and their compositionality,” in Proc. Advances Neural Information Processing Systems, 2013, pp. 3111–3119. [4] R. Socher, A. Perelygin, J. Wu, J. Chuang, C. D. Manning, A. Ng, and C. Potts, “Recursive deep models for semantic compositionality over a sentiment treebank,” in Proc. Conf. Empirical Methods Natural Language Processing, 2013, pp. 1631–1642. [5] R. Collobert, J. Weston, L. Bottou, M. Karlen, K. Kavukcuoglu, and P. Kuksa, “Natural language processing (almost) from scratch,” J. Mach. Learn. Res., vol. 12, pp. 2493–2537, Aug. 2011. [6] Y. Goldberg, “A primer on neural network models for natural language processing,” J. Artif. Intell. Res., vol. 57, pp. 345–420, Nov. 2016. [7] Y. Bengio, R. Ducharme, P. Vincent, and C. Jauvin, “A neural probabilistic language model,” J. Mach. Learn. Res., vol. 3, pp. 1137–1155, Feb. 2003. [8] T. Mikolov, K. Chen, G. Corrado, and J. Dean, “Efficient estimation of word representations in vector space,” arXiv Preprint, arXiv:1301.3781, 2013. [9] J. Weston, S. Bengio, and N. Usunier, “Wsabie: Scaling up to large vocabulary image annotation,” Proc. Int. Joint Conf. Artificial Intelligence., 2011, vol. 11, pp. 2764– 2770. [10] R. Socher, C. C. Lin, C. Manning, and A. Y. Ng, “Parsing natural scenes and natural language with recursive neural networks,” in Proc. 28th Int. Joint Conf. Machine Learning, 2011, pp. 129–136. [11] P. D. Turney and P. Pantel, “From frequency to meaning: Vector space models of semantics,” J. Artif. Intell. Res., vol. 37, pp. 141–188, Nov. 2010.

[12] E. Cambria, S. Poria, A. Gelbukh, and M. Thelwall, “Sentiment analysis is a big suitcase,” IEEE Intell. Syst., vol. 32, no. 6, pp. 74–80, Nov. 2017. [13] X. Glorot, A. Bordes, and Y. Bengio, “Domain adaptation for large-scale sentiment classification: A deep learning approach,” in Proc. 28th Int. Conf. Machine Learning, 2011, pp. 513–520. [14] K. M. Hermann and P. Blunsom, “The role of syntax in vector space models of compositional semantics,” in Proc. 51st Annu. Meeting Association Computational Linguistics, 2013, vol. 1, pp. 894–904. [15] J. L. Elman, “Distributed representations, simple recurrent networks, and grammatical structure,” Mach. Learn., vol. 7, no. 2–3, pp. 195–225, 1991. [16] A. M. Glenberg and D. A. Robertson, “Symbol grounding and meaning: A comparison of high-dimensional and embodied theories of meaning,” J. Memory Lang., vol. 43, no. 3, pp. 379–401, Oct. 2000. [17] S. T. Dumais, “Latent semantic analysis,” Annu. Rev. Inf. Sci. Tech., vol. 38, no. 1, pp. 188–230, Nov. 2004. [18] D. M. Blei, A. Y. Ng, and M. I. Jordan, “Latent dirichlet allocation,” J. Mach. Learn. Res., vol. 3, pp. 993–1022, 2003. [19] R. Collobert and J. Weston, “A unified architecture for natural language processing: Deep neural networks with multitask learning,” in Proc. 25th Int. Conf. Machine Learning, 2008, pp. 160–167. [20] A. Gittens, D. Achlioptas, and M. W. Mahoney, “Skip-gram-zipf + uniform = vector additivity,” in Proc. 55th Annu. Meeting Association Computational Linguistics, 2017, vol. 1, pp. 69–76. [21] J. Pennington, R. Socher, and C. D. Manning, “Glove: Global vectors for word representation,” in Proc. Conf. Empirical Methods Natural Language Processing, 2014, vol. 14, pp. 1532–1543. [22] R. Johnson and T. Zhang, “Semi-supervised convolutional neural networks for text categorization via region embedding,” in Proc. Advances Neural Information Processing Systems, 2015, pp. 919–927. [23] R. Socher, J. Pennington, E. H. Huang, A. Y. Ng, and C. D. Manning, “Semi-supervised recursive autoencoders for predicting sentiment distributions,” in Proc. Conf. Empirical Methods Natural Language Processing, 2011, pp. 151–161. [24] X. Wang, Y. Liu, C. Sun, B. Wang, and X. Wang, “Predicting polarities of tweets by composing word embeddings with long short-term memory,” in Proc. Annu. Meeting Association Computational Linguistics, 2015, pp. 1343–1353. [25] D. Tang, F. Wei, N. Yang, M. Zhou, T. Liu, and B. Qin, “Learning sentiment-specific word embedding for twitter sentiment classification,” in Proc. Annu. Meeting Association Computational Linguistics, 2014, pp. 1555–1565. [26] I. Labutov and H. Lipson, “Re-embedding words,” in Proc. Annu. Meeting Association Computational Linguistics, 2013, pp. 489–493. [27] S. Upadhyay, K. Chang, M. Taddy, A. Kalai, and J. Zou, “Beyond bilingual: Multi-sense word embeddings using multilingual context,” arXiv Preprint, arXiv:1706.08160, 2017. [28] Y. Kim, Y. Jernite, D. Sontag, and A. M. Rush, “Character-aware neural language models,” in Proc. Association Advancement Artificial Intelligence Conf., 2016, pp. 2741–2749. [29] C. N. Dos Santos and M. Gatti, “Deep convolutional neural networks for sentiment analysis of short texts,” in Proc. Int. Conf. Computational Linguistics, 2014, pp. 69–78. [30] C. N d Santos and V. Guimaraes, “Boosting named entity recognition with neural character embeddings,” arXiv Preprint, arXiv:1505.05008, 2015. [31] C. D. Santos and B. Zadrozny, “Learning characterlevel representations for part-of-speech tagging,” in Proc. 31st Int. Conf. Machine Learning, 2014, pp. 1818–1826. [32] Y. Ma, E. Cambria, and S. Gao, “Label embedding for zero-shot fine-grained named entity typing,” in Proc. Int. Conf. Computational Linguistics, Osaka, 2016, pp. 171–180. [33] X. Chen, L. Xu, Z. Liu, M. Sun, and H. Luan, “Joint learning of character and word embeddings,” in Proc. Int. Joint Conf. Artificial Intelligence, 2015, pp. 1236–1242. [34] X. Zheng, H. Chen, and T. Xu, “Deep learning for chinese word segmentation and pos tagging,” in Proc.

august 2018 | IEEE Computational intelligence magazine 73

Conf. Empirical Methods Natural Language Processing, 2013, pp. 647–657. [35] H. Peng, E. Cambria, and X. Zou, “Radical-based hierarchical embeddings for chinese sentiment analysis at sentence level,” in Proc. Int. Florida Artificial Intelligence Research Society Conf., 2017, pp. 347–352. [36] P. Bojanowski, E. Grave, A. Joulin, and T. Mikolov, “Enriching word vectors with subword information,” arXiv Preprint, arXiv:1607.04606, 2016. [37] A. Herbelot and M. Baroni, “High-risk learning: Acquiring new word vectors from tiny data,” arXiv Preprint, arXiv:1707.06556, 2017. [38] Y. Pinter, R. Guthrie, and J. Eisenstein, “Mimicking word embeddings using subword rnns,” arXiv Preprint, arXiv:1707.06961, 2017. [39] L. Lucy and J. Gauthier, “Are distributional representations ready for the real world? Evaluating word vectors for grounded perceptual meaning,” arXiv Preprint, arXiv:1705.11168, 2017. [40] A. Krizhevsky, I. Sutskever, and G. E. Hinton, “Imagenet classification with deep convolutional neural networks,” in Proc. Advances Neural Information Processing Systems, 2012, pp. 1097–1105. [41] A. Sharif Razavian, H. Azizpour, J. Sullivan, and S. Carlsson, “CNN features off-the-shelf: An astounding baseline for recognition,” in Proc. IEEE Conf. Computer Vision and Pattern Recognition Workshops, 2014, pp. 806–813. [42] Y. Jia, E. Shelhamer, J. Donahue, S. Karayev, J. Long, R. Girshick, S. Guadarrama, and T. Darrell, “Caffe: Convolutional architecture for fast feature embedding,” in Proc. 22nd ACM Int. Conf. Multimedia, 2014, pp. 675–678. [43] N. Kalchbrenner, E. Grefenstette, and P. Blunsom, “A convolutional neural network for modelling sentences,” in Proc. 52nd Annu. Meeting Association Computational Linguistics, 2014, vol. 1, pp. 655–665. [44] Y. Kim, “Convolutional neural networks for sentence classification,” arXiv Preprint, arXiv:1408.5882, 2014. [45] S. Poria, E. Cambria, and A. Gelbukh, “Aspect extraction for opinion mining with a deep convolutional neural network,” Knowl.-Based Syst., vol. 108, pp. 42–49, June 2016. [46] A. Kirillov, D. Schlesinger, W. Forkel, A. Zelenin, S. Zheng, P. Torr, and C. Rother, “Efficient likelihood learning of a generic CNN-CRF model for semantic segmentation,” arXiv Preprint, arXiv:1511.05067, 2015. [47] A. Waibel, T. Hanazawa, G. Hinton, K. Shikano, and K. J. Lang, “Phoneme recognition using time-delay neural networks,” IEEE Trans. Acoust., Speech, Signal Process., vol. 37, no. 3, pp. 328–339, Mar. 1989. [48] A. Mukherjee and B. Liu, “Aspect extraction through semi-supervised modeling,” in Proc. 50th Annu. Meeting Association Computational Linguistics, 2012, pp. 339–348. [49] S. Ruder, P. Ghaffari, and J. G. Breslin, “Insight-1 at semeval-2016 task 5: Deep learning for multilingual aspect-based sentiment analysis,” arXiv Preprint, arXiv:1609.02748, 2016. [50] P. Wang, J. Xu, B. Xu, C. Liu, H. Zhang, F. Wang, and H. Hao, “Semantic clustering and convolutional neural network for short text categorization,” in Proc. Annu. Meeting Association Computational Linguistics, 2015, pp. 352–357. [51] S. Poria, E. Cambria, D. Hazarika, and P. Vij, “A deeper look into sarcastic tweets using deep convolutional neural networks,” in Proc. Int. Conf. Computational Linguistics, 2016, pp. 1601–1612. [52] M. Denil, A. Demiraj, N. Kalchbrenner, P. Blunsom, and N. de Freitas, “Modelling, visualising and summarising documents with a single convolutional neural network,” 26th Int. Conf. Computational Linguistics, 2014, pp. 1601–1612. [53] B. Hu, Z. Lu, H. Li, and Q. Chen, “Convolutional neural network architectures for matching natural language sentences,” in Proc. Advances Neural Information Processing Systems, 2014, pp. 2042–2050. [54] Y. Shen, X. He, J. Gao, L. Deng, and G. Mesnil, “A latent semantic model with convolutional-pooling structure for information retrieval,” in Proc. 23rd ACM Int. Conf. Information and Knowledge Management, 2014, pp. 101–110.

[55] W. Yih, X. He, and C. Meek, “Semantic parsing for single-relation question answering,” in Proc. Annu. Meeting Association Computational Linguistics, 2014, pp. 643–648. [56] L. Dong, F. Wei, M. Zhou, and K. Xu, “Question answering over freebase with multi-column convolutional neural networks,” in Proc. Annu. Meeting Association Computational Linguistics, 2015, pp. 260–269. [57] A. Severyn and A. Moschitti, “Modeling relational information in question-answer pairs with convolutional neural networks,” arXiv Preprint, arXiv:1604.01178, 2016. [58] Y. Chen, L. Xu, K. Liu, D. Zeng, and J. Zhao, “Event extraction via dynamic multi-pooling convolutional neural networks,” in Proc. Annu. Meeting Association Computational Linguistics, 2015, pp. 167–176. [59] O. Abdel-Hamid, A.-R. Mohamed, H. Jiang, L. Deng, G. Penn, and D. Yu, “Convolutional neural networks for speech recognition,” IEEE Trans. Acoust., Speech, Signal Process., vol. 22, no. 10, pp. 1533–1545, Oct. 2014. [60] D. Palaz, M. Magimai.-Doss, and R. Collobert, “Analysis of CNN-based speech recognition system using raw speech as input,” Idiap, Tech. Rep, 2015. [61] Z. Tu, B. Hu, Z. Lu, and H. Li, “Context-dependent translation selection using convolutional neural network,” arXiv Preprint, arXiv:1503.02357, 2015. [62] J. L. Elman, “Finding structure in time,” Cogn. Sci., vol. 14, no. 2, pp. 179–211, 1990. [63] T. Mikolov, S. Kombrink, L. Burget, J. Cˇ ernocký, and S. Khudanpur, “Extensions of recurrent neural network language model,” in Proc. Int. Conf. Acoustics, Speech and Signal Processing, 2011, pp. 5528–5531. [64] I. Sutskever, J. Martens, and G. E. Hinton, “Generating text with recurrent neural networks,” in Proc. 28th Int. Conf. Machine Learning, 2011, pp. 1017–1024. [65] S. Liu, N. Yang, M. Li, and M. Zhou, “A recursive recurrent neural network for statistical machine translation,” in Proc. 52nd Annu. Meeting Association Computational Linguistics, 2014, pp. 1491–1500. [66] M. Auli, M. Galley, C. Quirk, and G. Zweig, “Joint language and translation modeling with recurrent neural networks,” in Proc. Conf. Empirical Methods Natural Language Processing, 2013, pp. 1044–1054. [67] I. Sutskever, O. Vinyals, and Q. V. Le, “Sequence to sequence learning with neural networks,” in Proc. Advances Neural Information Processing Systems, 2014, pp. 3104–3112. [68] T. Robinson, M. Hochberg, and S. Renals, “The use of recurrent neural networks in continuous speech recognition,” in Proc. Automatic Speech and Speaker Recognition, 1996, pp. 233–258. [69] A. Graves, A.-r. Mohamed, and G. Hinton, “Speech recognition with deep recurrent neural networks,” in Proc. Int. Conf. Acoustics, Speech and Signal Processing, 2013, pp. 6645–6649. [70] A. Graves and N. Jaitly, “Towards end-to-end speech recognition with recurrent neural networks,” in Proc. 31st Int. Conf. Machine Learning, 2014, pp. 1764–1772. [71] H. Sak, A. Senior, and F. Beaufays, “Long short-term memory based recurrent neural network architectures for large vocabulary speech recognition,” arXiv Preprint, arXiv:1402.1128, 2014. [72] A. Karpathy and L. Fei-Fei, “Deep visual-semantic alignments for generating image descriptions,” in Proc. IEEE Conf. Computer Vision and Pattern Recognition, 2015, pp. 3128–3137. [73] D. Tang, B. Qin, and T. Liu, “Document modeling with gated recurrent neural network for sentiment classification,” in Proc. Conf. Empirical Methods Natural Language Processing, 2015, pp. 1422–1432. [74] J. Chung, C. Gulcehre, K. Cho, and Y. Bengio, “Empirical evaluation of gated recurrent neural networks on sequence modeling,” arXiv Preprint, arXiv:1412.3555, 2014. [75] K. Cho, B. Van Merriënboer, C. Gulcehre, D. Bahdanau, F. Bougares, H. Schwenk, and Y. Bengio, “Learning phrase representations using RNN encoder-decoder for statistical machine translation,” arXiv Preprint, arXiv:1406.1078, 2014. [76] G. Chen, D. Ye, E. Cambria, J. Chen, and Z. Xing, “Ensemble application of convolutional and recurrent

neural networks for multi-label text categorization,” in Proc. Int. Joint Conf. Neural Networks, 2017, pp. 2377–2383. [77] S. Poria, E. Cambria, D. Hazarika, N. Mazumder, A. Zadeh, and L. Morency, “Context-dependent sentiment analysis in user-generated videos,” in Proc. Annu. Meeting Association Computational Linguistics, 2017, pp. 873–883. [78] A. Zadeh, M. Chen, S. Poria, E. Cambria, and L. Morency, “Tensor fusion network for multimodal sentiment analysis,” in Proc. Conf. Empirical Methods Natural Language Processing, 2017, pp. 1114–1125. [79] E. Tong, A. Zadeh, C. Jones, and L.-P. Morency, “Combating human trafficking with deep multimodal models,” arXiv Preprint, arXiv:1705.02735, 2017. [80] I. Chaturvedi, E. Ragusa, P. Gastaldo, R. Zunino, and E. Cambria, “Bayesian network based extreme learning machine for subjectivity detection,” J. Franklin Inst., vol. 355, no. 4, pp. 1780–1797, July 2018. [81] Y. N. Dauphin, A. Fan, M. Auli, and D. Grangier, “Language modeling with gated convolutional networks,” arXiv Preprint, arXiv:1612.08083, 2016. [82] W. Yin, K. Kann, M. Yu, and H. Schütze, “Comparative study of CNN and RNN for natural language processing,” arXiv Preprint, arXiv:1702.01923, 2017. [83] S. Hochreiter and J. Schmidhuber, “Long short-term memory,” Neural Comput., vol. 9, no. 8, pp. 1735–1780, 1997. [84] F. A. Gers, J. Schmidhuber, and F. Cummins, “Learning to forget: Continual prediction with LSTM,” in Proc. 9th Int. Conf. Artificial Neural Networks, pp. 850–855, 1999. [85] G. Lample, M. Ballesteros, S. Subramanian, K. Kawakami, and C. Dyer, “Neural architectures for named entity recognition,” arXiv Preprint, arXiv:1603.01360, 2016. [86] A. Graves, “Generating sequences with recurrent neural networks,” arXiv Preprint, arXiv:1308.0850, 2013. [87] M. Sundermeyer, H. Ney, and R. Schlüter, “From feedforward to recurrent LSTM neural networks for language modeling,” IEEE Trans. Audio, Speech, Language Process., vol. 23, no. 3, pp. 517–529, Mar. 2015. [88] M. Sundermeyer, T. Alkhouli, J. Wuebker, and H. Ney, “Translation modeling with bidirectional recurrent neural networks,” in Proc. Conf. Empirical Methods Natural Language Processing, 2014, pp. 14–25. [89] R. Lowe, N. Pow, I. Serban, and J. Pineau, “The ubuntu dialogue corpus: A large dataset for research in unstructured multi-turn dialogue systems,” arXiv Preprint, arXiv:1506.08909, 2015. [90] O. Vinyals, A. Toshev, S. Bengio, and D. Erhan, “Show and tell: A neural image caption generator,” in Proc. IEEE Conf. Computer Vision and Pattern Recognition, 2015, pp. 3156–3164. [91] O. Vinyals and Q. Le, “A neural conversational model,” arXiv Preprint arXiv:1506.05869, 2015. [92] J. Li, M. Galley, C. Brockett, G. P. Spithourakis, J. Gao, and B. Dolan, “A persona-based neural conversation model,” arXiv Preprint, arXiv:1603.06155, 2016. [93] M. Malinowski, M. Rohrbach, and M. Fritz, “Ask your neurons: A neural-based approach to answering questions about images,” in Proc. IEEE Int. Conf. Computer Vision, 2015, pp. 1–9. [94] D. Bahdanau, K. Cho, and Y. Bengio, “Neural machine translation by jointly learning to align and translate,” arXiv Preprint, arXiv:1409.0473, 2014. [95] A. M. Rush, S. Chopra, and J. Weston, “A neural attention model for abstractive sentence summarization,” arXiv Preprint, arXiv:1509.00685, 2015. [96] K. Xu, J. Ba, R. Kiros, K. Cho, A. Courville, R. Salakhudinov, R. Zemel, and Y. Bengio, “Show, attend and tell: Neural image caption generation with visual attention,” in Proc. Int. Conf. Machine Learning, 2015, pp. 2048–2057. [97] O. Vinyals, Ł. Kaiser, T. Koo, S. Petrov, I. Sutskever, and G. Hinton, “Grammar as a foreign language,” in Proc. Advances Neural Information Processing Systems, 2015, pp. 2773–2781. [98] O. Vinyals, M. Fortunato, and N. Jaitly, “Pointer networks,” in Proc. Advances Neural Information Processing Systems, 2015, pp. 2692–2700. [99] R. Paulus, C. Xiong, and R. Socher, “A deep reinforced model for abstractive summarization,” arXiv Preprint, arXiv:1705.04304, 2017.

74 IEEE Computational intelligence magazine | august 2018

[100] Y. Wang, M. Huang, X. Zhu, and L. Zhao, “Attention-based LSTM for aspect-level sentiment classification,” in Proc. Conf. Empirical Methods Natural Language Processing, 2016, pp. 606–615. [101] Y. Ma, H. Peng, and E. Cambria, “Targeted aspectbased sentiment analysis via embedding commonsense knowledge into an attentive LSTM,” in Proc. Association Advancement Artificial Intelligence Conf., 2018, pp. 5876– 5883. [102] R. Socher, B. Huval, C. D. Manning, and A. Y. Ng, “Semantic compositionality through recursive matrixvector spaces,” in Proc. Joint Conf. Empirical Methods Natural Language Processing and Computational Natural Language Learning, 2012, pp. 1201–1211. [103] B. Taskar, C. Guestrin, and D. Koller, “Max-margin Markov networks,” in Proc. Advances Neural Information Processing Systems, 2004, pp. 25–32. [104] S. R. Bowman, C. Potts, and C. D. Manning, “Recursive neural networks can learn logical semantics,” arXiv Preprint, arXiv:1406.1827, 2014. [105] K. S. Tai, R. Socher, and C. D. Manning, “Improved semantic representations from tree-structured long short-term memory networks,” arXiv Preprint, arXiv:1503.00075, 2015. [106] S. Bengio, O. Vinyals, N. Jaitly, and N. Shazeer, “Scheduled sampling for sequence prediction with recurrent neural networks,” in Proc. Advances Neural Information Processing Systems, 2015, pp. 1171–1179. [107] M. Ranzato, S. Chopra, M. Auli, and W. Zaremba, “Sequence level training with recurrent neural networks,” arXiv Preprint, arXiv:1511.06732, 2015. [108] J. Li, W. Monroe, A. Ritter, M. Galley, J. Gao, and D. Jurafsky, “Deep reinforcement learning for dialogue generation,” arXiv Preprint, arXiv:1606.01541, 2016. [109] R. J. Williams, “Simple statistical gradient-following algorithms for connectionist reinforcement learning,” Mach. Learn., vol. 8, no. 3–4, pp. 229–256, 1992. [110] S. Young, M. Gašicˇ, S. Keizer, F. Mairesse, J. Schatzmann, B. Thomson, and K. Yu, “The hidden information state model: A practical framework for POMDP-based spoken dialogue management,” Comput. Speech Lang., vol. 24, no. 2, pp. 150–174, June 2010. [111] S. Young, M. Gašicˇ, B. Thomson, and J. D. Williams, “POMDP-based statistical spoken dialog systems: A review,” Proc. IEEE, vol. 101, no. 5, pp. 1160–1179, 2013. [112] P.-h. Su, V. David, D. Kim, T.-h. Wen, and S. Young, “Learning from real users: Rating dialogue success with neural networks for reinforcement learning in spoken dialogue systems,” in Proc. Interspeech Conf., 2015, pp. 2007–2011. [113] P.-H. Su, M. Gasic, N. Mrksic, L. Rojas-Barahona, S. Ultes, D. Vandyke, T. Wen, and S. Young, “On-line active reward learning for policy optimisation in spoken dialogue systems,” arXiv Preprint, arXiv:1605.07669, 2016. [114] I. Goodfellow, J. Pouget-Abadie, M. Mirza, B. Xu, D. Warde-Farley, S. Ozair, A. Courville, and Y. Bengio, “Generative adversarial nets,” in Proc. Advances Neural Information Processing Systems, 2014, pp. 2672–2680. [115] J. Li, W. Monroe, T. Shi, A. Ritter, and D. Jurafsky, “Adversarial learning for neural dialogue generation,” arXiv Preprint, arXiv:1701.06547, 2017. [116] R. Kiros, Y. Zhu, R. R. Salakhutdinov, R. Zemel, R. Urtasun, A. Torralba, and S. Fidler, “Skip-thought vectors,” in Proc. Advances Neural Information Processing Systems, 2015, pp. 3294–3302. [117] A. M. Dai and Q. V. Le, “Semi-supervised sequence learning,” in Proc. Advances Neural Information Processing Systems, 2015, pp. 3079–3087. [118] D. E. Rumelhart, G. E. Hinton, and R. J. Williams, “Learning internal representations by error propagation,” DTIC Document, Tech. Rep, 1985. [119] D. P. Kingma and M. Welling, “Auto-encoding variational bayes,” arXiv Preprint, arXiv:1312.6114, 2013. [120] S. R. Bowman, L. Vilnis, O. Vinyals, A. M. Dai, R. Jozefowicz, and S. Bengio, “Generating sentences from a continuous space,” arXiv Preprint, arXiv:1511.06349, 2015. [121] Y. Zhang, Z. Gan, and L. Carin, “Generating text via adversarial training,” in Proc. Neural Information Processing Systems Workshop Adversarial Training, 2016.

[122] Z. Hu, Z. Yang, X. Liang, R. Salakhutdinov, and E. P. Xing, “Controllable text generation,” arXiv Preprint, arXiv:1703.00955, 2017. [123] L. Yu, W. Zhang, J. Wang, and Y. Yu, “Seqgan: sequence generative adversarial nets with policy gradient,” in Proc. Association Advancement Artificial Intelligence Conf., 2017, pp. 2852–2858. [124] S. Rajeswar, S. Subramanian, F. Dutil, C. Pal, and A. Courville, “Adversarial generation of natural language,” arXiv Preprint, arXiv:1705.10929, 2017. [125] J. Giménez and L. Marquez, “Fast and accurate part-of-speech tagging: The SVM approach revisited,” Recent Adv. Natural Lang. Process., pp. 153–162, 2004. [126] Z. Huang, W. Xu, and K. Yu, “Bidirectional LSTM-CRF models for sequence tagging,” arXiv Preprint, arXiv:1508.01991, 2015. [127] D. Andor, C. Alberti, D. Weiss, A. Severyn, A. Presta, K. Ganchev, S. Petrov, and M. Collins, “Globally normalized transition-based neural networks,” arXiv Preprint, arXiv:1603.06042, 2016. [128] A. Kumar, O. Irsoy, P. Ondruska, M. Iyyer, J. Bradbury, I. Gulrajani, V. Zhong, R. Paulus, and R. Socher, “Ask me anything: Dynamic memory networks for natural language processing,” in Proc. Int. Conf. Machine Learning, 2016, pp. 1378–1387. [129] D. Chen and C. D. Manning, “A fast and accurate dependency parser using neural networks,” in Proc. Conf. Empirical Methods Natural Language Processing, 2014, pp. 740–750. [130] D. Weiss, C. Alberti, M. Collins, and S. Petrov, “Structured training for neural network transition-based parsing,” arXiv Preprint, arXiv:1506.06158, 2015. [131] C. Dyer, M. Ballesteros, W. Ling, A. Matthews, and N. A. Smith, “Transition-based dependency parsing with stack long short-term memory,” arXiv Preprint, arXiv:1505.08075, 2015. [132] H. Zhou, Y. Zhang, C. Cheng, S. Huang, X. Dai, and J. Chen, “A neural probabilistic structured-prediction method for transition-based natural language processing,” J. Artif. Intell. Res., vol. 58, pp. 703–729, Mar. 2017. [133] S. Petrov, L. Barrett, R. Thibaux, and D. Klein, “Learning accurate, compact, and interpretable tree annotation,” in Proc. 21st Int. Conf. Computational Linguistics, 2006, pp. 433–440. [134] M. Zhu, Y. Zhang, W. Chen, M. Zhang, and J. Zhu, “Fast and accurate shift-reduce constituent parsing,” in Proc. Annu. Meeting Association Computational Linguistics, 2013, pp. 434–443. [135] J. Weston, S. Chopra, and A. Bordes, “Memory networks,” arXiv Preprint, arXiv:1410.3916, 2014. [136] S. Sukhbaatar, A. Szlam, J. Weston, and R. Fergus, “End-to-end memory networks,” in Proc. Advances Neural Information Processing Systems, 2015, pp. 2440–2448. [137] C. Xiong, S. Merity, and R. Socher, “Dynamic memory networks for visual and textual question answering,” in Proc. Int. Conf. Machine Learning, 2016, pp. 2397–2406. [138] A. Passos, V. Kumar, and A. McCallum, “Lexicon infused phrase embeddings for named entity resolution,” arXiv Preprint, arXiv:1404.5367, 2014. [139] J. P. Chiu and E. Nichols, “Named entity recognition with bidirectional LSTM-CNNs,” arXiv Preprint, arXiv:1511.08308, 2015. [140] G. Luo, X. Huang, C. Lin, and Z. Nie, “Joint named entity recognition and disambiguation,” in Proc. Conf. Empirical Methods Natural Language Processing, 2015, pp. 879–880. [141] E. Strubell, P. Verga, D. Belanger, and A. McCallum, “Fast and accurate sequence labeling with iterated dilated convolutions,” arXiv Preprint, arXiv:1702.02098, 2017. [142] O. Täckström, K. Ganchev, and D. Das, “Efficient inference and structured learning for semantic role labeling,” Trans. Assoc. Comput. Linguistics, vol. 3, pp. 29–41, Jan. 2015. [143] J. Zhou and W. Xu, “End-to-end learning of semantic role labeling using recurrent neural networks,” in Proc. Annu. Meeting Association Computational Linguistics, 2015, pp. 1127–1137. [144] L. He, K. Lee, M. Lewis, and L. Zettlemoyer, “Deep semantic role labeling: What works and what’s

next,” in Proc. Annu. Meeting Association for Computational Linguistics, 2017, pp. 473–483. [145] Q. Le and T. Mikolov, “Distributed representations of sentences and documents,” in Proc. 31st Int. Conf. Machine Learning, 2014, pp. 1188–1196. [146] L. Yu, J. Wang, K. R. Lai, and X. Zhang, “Refining word embeddings for sentiment analysis,” in Proc. Conf. Empirical Methods Natural Language Processing, 2017, pp. 545–550. [147] Y. Wu, M. Schuster, Z. Chen, Q. V. Le, M. Norouzi, W. Macherey, M. Krikun, Y. Cao, Q. Gao, K. Macherey, et al., “Google’s neural machine translation system: Bridging the gap between human and machine translation,” arXiv Preprint, arXiv:1609.08144, 2016. [148] J. Gehring, M. Auli, D. Grangier, D. Yarats, and Y. N. Dauphin, “Convolutional sequence to sequence learning,” arXiv Preprint, arXiv:1705.03122, 2017. [149] A. Vaswani, N. Shazeer, N. Parmar, and J. Uszkoreit, “Attention is all you need,” arXiv Preprint, arXiv:1706.03762, 2017. [150] R. K. Srivastava, K. Greff, and J. Schmidhuber, “Training very deep networks,”in Proc. Advances Neural Information Processing Systems, 2015, pp. 2377–2385. [151] B. Pang and L. Lee, “Seeing stars: Exploiting class relationships for sentiment categorization with respect to rating scales,” in Proc. 43rd Annu. Meeting Association Computational Linguistics, 2005, pp. 115–124. [152] A. Zadeh, R. Zellers, E. Pincus, and L. Morency, “Multimodal sentiment intensity analysis in videos: Facial gestures and verbal messages,” IEEE Intell. Syst., vol. 31, no. 6, pp. 82–88, Nov. 2016. [153] A. Fader, L. S. Zettlemoyer, and O. Etzioni, “Paraphrase-driven learning for open question answering,” in Proc. Annu. Meeting Association Computational Linguistics, 2013, pp. 1608–1618. [154] A. Bordes, J. Weston, and N. Usunier, “Open question answering with weakly supervised embedding models,” in Proc. Joint European Conf. Machine Learning and Knowledge Discovery Databases, 2014, pp. 165–180. [155] A. Ritter, C. Cherry, and W. B. Dolan, “Data-driven response generation in social media,” in Proc. Conf. Empirical Methods Natural Language Processing, 2011, pp. 583–593. [156] A. Sordoni, M. Galley, M. Auli, C. Brockett, Y. Ji, M. Mitchell, J.-Y. Nie, J. Gao, and B. Dolan, “A neural network approach to context-sensitive generation of conversational responses,” arXiv Preprint, arXiv:1506.06714, 2015. [157] J. Li, M. Galley, C. Brockett, J. Gao, and B. Dolan, “A diversity-promoting objective function for neural conversation models,” arXiv Preprint, arXiv:1510.03055, 2015. [158] J. Dodge, A. Gane, X. Zhang, A. Bordes, S. Chopra, A. Miller, A. Szlam, and J. Weston, “Evaluating prerequisite qualities for learning end-to-end dialog systems,” arXiv Preprint, arXiv:1511.06931, 2015. [159] X. Zhou, D. Dong, H. Wu, S. Zhao, D. Yu, H. Tian, X. Liu, and R. Yan, “Multi-view response selection for human-computer conversation,” in Proc. Conf. Empirical Methods Natural Language Processing, 2016, pp. 372–381. [160] P. Koehn, F. J. Och, and D. Marcu, “Statistical phrase-based translation,” in Proc. Conf. North American Chapter Association Computational Linguistics, 2003, pp. 48–54. [161] K. Papineni, S. Roukos, T. Ward, and W. Zhu, “Bleu: A method for automatic evaluation of machine translation,” in Proc. 40th Annu. Meeting Association Computational Linguistics, 2002, pp. 311–318. [162] I. V. Serban, A. Sordoni, Y. Bengio, A. C. Courville, and J. Pineau, “Building end-to-end dialogue systems using generative hierarchical neural network models,” in Proc. Association Advancement Artificial Intelligence Conf., 2016, pp. 3776–3784. [163] Y. LeCun, Y. Bengio, and G. Hinton, “Deep learning,” Nature, vol. 521, no. 7553, pp. 436–444, May 2015. [164] T. Baltrušaitis, C. Ahuja, and L. Morency, “Multimodal machine learning: A survey and taxonomy,” arXiv Preprint, arXiv:1705.09406, 2017.


august 2018 | IEEE Computational intelligence magazine 75

