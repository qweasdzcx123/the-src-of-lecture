හਁᇇ๦्ก
图灵社区的电子书没有采用专有客 户端，您可以在任意设备上，用自 己喜欢的浏览器和PDF阅读器进行 阅读。 但您购买的电子书仅供您个人使用， 未经授权，不得进行传播。 我们愿意相信读者具有这样的良知 和觉悟，与我们共同保护知识产权。
如果购买者有侵权行为，我们可能 对该用户实施包括但不限于关闭该 帐号等维权措施，并可能追究法律 责任。

表 1.2.14 一种能够累加数据的抽象数据类型（可视版本）

API public class VisualAccumulator VisualAccumulator(int trials, double max)
void addDataValue(double val) double mean() String toString()

添加一个新的数据值 所有数据的平均值 对象的字符串表示

典型的用例

public class TestVisualAccumulator {
public static void main(String[] args) {
int T = Integer.parseInt(args[0]); VisualAccumulator a = new VisualAccumulator(T, 1.0); for (int t = 0; t < T; t++)
a.addDataValue(StdRandom.random()); StdOut.println(a); } }

数据类型的实现

public class VisualAccumulator {
private double total; private int N; public VisualAccumulator(int trials, double max) {
StdDraw.setXscale(0, trials); StdDraw.setYscale(0, max); StdDraw.setPenRadius(.005); } public void addDataValue(double val) { N++; total += val; StdDraw.setPenColor(StdDraw.DARK_GRAY); StdDraw.point(N, val); StdDraw.setPenColor(StdDraw.RED); StdDraw.point(N, total/N); } public double mean() public String toString() // 和 Accumulator 相同 }

　
左起第N个红点的高度为最 靠左的N个灰点的平均高度

一个装有 弹子球的 背包

灰点的高度 即数据点的值 % java TestVisualAccumulator 2000
Mean (2000 values): 0.509789
图 1.2.8 可视化累加器图像

add( )

add( )
for (Marble m : bag) 处理任意弹子球 m（任意顺序）
图 1.3.1 背包的操作

256

成本（数组引用）

每个灰点表

128

示一次操作 64

红点表示的是累计平均

5

0

0

add()操作的数量

128

图 1.4.7　向一个 RandomBag 对象中添加元素时的 均摊成本

01234 56789

43

38

65

94

21

89

50

72

不用打印

出已知相

连的整数对

61

10

67

2个连通分量 图 1.5.1 动态连通性问题

灰色的元素 没有被移动

quick-find算法 1300
union()操作至 少访问数组625次

每个灰点都表 示用例处理过 的一条连接

访问数组的次数

每个红点都表

458

示一个累计平均

connected()操作 只会访问数组2次

0

0

连接总数

900

quick-union算法

find()操作变

100

得越来越昂贵

20

0

加权quick-union算法

没有任何昂贵的操作

8

20

0

图 1.5.10 所有操作的总成本

黑色的元素 参与了比较

插入排序

选择排序

图 2.1.1 初级排序算法的可视轨迹图

输入
第一次切 分的结果

切分元素

左子数组 部分有序
两个子数组 都已部分有序
结果 图 2.3.3 使用了三取样切分和插入排序转换的快速排序
和切分元素相等的元素
图 2.3.5 三向切分的快速排序的可视轨迹

输入 堆有序

红色的条目 是下沉的元素

灰色的元 素不会移动
黑色的元素 正在进行交换

lo

i

hi

中位数
排序 结果

图 2.4.8 堆排序的可视轨迹

图 2.5.2 用切分找出中位数

键 值 首结点 S 0 S0 E 1 E1 A 2 A2 R 3 R3 C 4 C4 H 5 H5 E 6 H5 X 7 X7 A 8 X7 M 9 M9 P 10 P 10 L 11 L 11 E 12 L 11

红色为新 加入的结点 S0 E1 S0 A2 E1 R3 A2 C4 R3 C4 R3 H5 C4 H5 C4 X7 H5 M9 X7 P 10 M 9 P 10 M 9

S0 E1 A2 A2 R3 R3 C4 H5 X7 X7

黑色是在查找 中被遍历的结点

S0 E1 E6 A2 A8 R3 C4 H5 H5

S0 S0 E6 E6 A8 R3 C4 C4

圈中是被 修改过的值

S0 S0 E6 A8 R3 R3

灰色结点没 有被访问过 S0 E6 S0 A8 E6 A 8 E 12

S0 S0

图 3.1.2　使用基于链表的符号表的索引用例的轨迹

20 16
1.39 lgN −1.85

平均路径长度

0 100

节点数量N

10 000

图 3.2.14　一棵随机构造的二叉查找树中由根到达任意结点的平均路径长度

3-结点

ab

小于a ...

介于a 和b之间
...

b

a

大于b ...

小于a ...

介于a 和b之间
...

大于b ...

图 3.3.12　由一条红色左链接相连的两个 2- 结点表示一个 3- 结点

图 3.3.13　将红链接画平时，一棵红黑树就是一棵 2-3 树

红黑树

M

J

E

L

C

H

A

R

P

X

S

将红链接画平 M

E

J

AC

H

L

R P SX

2-3树

EJ AC H

M R
L P SX

图 3.3.14　红黑树和 2-3 树的一一对应关系

h.left.color

的值是RED

E

C

A

D

h
J G

h.right.color 的值是BLACK

private static final boolean RED = true; private static final boolean BLACK = false;

private class Node

{

Key key;

// 键

Value val;

// 相关联的值

Node left, right; // 左右子树

int N;

// 这棵子树中的结点总数

boolean color; // 由其父结点指向它的链接的颜色

Node(Key key, Value val, int N, boolean color)

{

this.key = key;

this.val = val;

this.N

= N;

this.color = color;

}

}

private boolean isRed(Node x) {
if (x == null) return false; return x.color == RED; }

图 3.3.15　红黑树的结点表示

h E

可能是左链接也可能是 右链接，颜色可红可黑
x S

小于E

介于E 和S之间

大于S

Node rotateLeft(Node h)

{

Node x = h.right;

h.right = x.left;

x.left = h;

x.color = h.color;

h.color = RED;

x.N = h.N;

h.N = 1 + size(h.left)

+ size(h.right);

return x;

}

x

h

S

E

小于E

介于E 和S之间

大于S

图 3.3.16　左旋转 h 的右链接

x E

h S

小于E

介于E 和S之间

大于S

Node rotateRight(Node h) {
Node x = h.left; h.left = x.right; x.right = h; x.color = h.color; h.color = RED; x.N = h.N; h.N = 1 + size(h.left)
+ size(h.right); return x; }x

E

h

S

小于E

介于E 和S之间

大于S

图 3.3.17　右旋转 h 的左链接

向左插入 根结点 b

查找结束 于该空链接

根结点

b 指向含有a的

a

新结点的红链

接将这个2-结点

变为一个3-结点

向右插入

根结点

a

查找结束

于该空链接

a

用红链接和

新结点相连

b

根结点

b

a

左旋转得到一

个正常的3-结点

图 3.3.18　向单个 2- 结点中插入一个新键

插入C E

A

S

R 在此处插 入新结点

出现红色右链接， 进行左旋转
E

A

S

CR

E

C

S

A

R

图 3.3.19　向树底部的 2- 结点插入一个新键

新键最大 b
a

新键最小

查找结束

c

于该空链接 b

查找结束

于该空链接

新键介于两者之间 c
a 查找结束 于该空链接
c

用红链接和

c

b

新结点相连 b

a b

用红链接和 新结点相连

a

c

a

用红链接和

新结点相连

c

b

b

将链接颜 色变为黑

a

c

b

旋转后变为 a 红色右链接

旋转后变为红色左链接

a

c

旋转后变为

b

红色右链接

将链接颜

b

色变为黑

a

c

a

c

将链接颜

b

色变为黑

a

c

图 3.3.20　向一棵双键树（即一个 3- 结点）中插入一个新键的三种情况

h E

可能是左链接， 也可能是右链接

A

S

小于A

介于A

介于E

和E之间 和S之间

大于S

void flipColors(Node h) {
h.color = RED; h.left.color = BLACK; h.right.color = BLACK; }
用红链接将中间
结点和父结点相连
E

A 黑色链接分

S

别指向两个

2-结点

小于A

介于A

介于E

和E之间 和S之间

大于S

图 3.3.21　通过转换链接的颜色来分解 4- 结点

插入H E
AC RS

E

C

S

A

R

E AC HRS

在此插 入新结点
出现两条连续的左 链接，需要右旋转
E

C

S

A

R

H

拥有两个红色子链接， 需要进行颜色转换

E

C

R

A

HS

出现红色右链 接，需要左旋转

ER AC H S

E C A

R HS

R

E

S

CH

A

图 3.3.22　向树底部的 3- 结点插入一个新键

h h
右旋转

h 左旋转
颜色转换

图 3.3.23　红黑树中红链接向上传递

插入 S

S

S E
E

A

E

AS

E

R

A

S

R

E

C

C

S

A

R

R

H

E

S

CH

A

R

X

E

X

CHS

A

R

M

E

X

C

MS

A

H

M

P

E

R

CHP

X

A

S

M

L

E

C

L

A

H

R

P

X

S

标准索引测试用例

插入 A C E H L
M

A
C A

C AE

C

A

H

E

H

C

L

AE

H

C

M

A EL

H

P

C

M

A EL P

H

C

M

R

A EL

R

P

H

C S
AE

R

M

S

LP

H

X

C

AE

R

M

X

LPS

用同一组键按照升序插入来构造一棵红黑树

图 3.3.24　红黑树的构造轨迹

图 3.3.27　使用随机键构造的典型红黑树，没有画出空链接

图 3.3.28　使用升序键列构造的一棵红黑树，没有画出空链接 20
13 lgN − 0.5

成本

0 100

操作 图 3.3.30　随机构造的红黑树中到达一个随机结点的平均路径长度

10 000

110 10679/97

频率

0

键值

96

图 3.4.2　《双城记》中每个单词的散列值的出现频率（10 679 个键，即单词，M=97）

α =10.711... 125
αke-α k!

频率

0

0

10

20

30

链表的长度（10 679个键，M = 997）

图 3.4.4　使用 SeparateChainingHashST，运行 java FrequencyCounter 8 < tale.txt 时所有链表 的长度

键 散列值 值

S6

0

E 10

1

A4

2

R 14

3

C5

4

H4

5

E 10

6

X 15

7

A4

8

M1

9

P 14 10

L 6 11

E 10 12

0123
红色的是 新插入的键
黑色的 是探针键
M 9 PM 10 9 PM 10 9 PM 10 9

456789

S 0

S 0

A

S

2

0

A

S

2

0

AC S 240

A C SH 2405

ACSH 240 5

ACSH 240 5

ACSH 840 5

ACSH 840 5

ACSH 840 5

ACSHL 8 4 0 5 11

ACSHL 8 4 0 5 11

10 11 12 13 14 15

E

1

灰色的键

E

未被访问

1

E

R

1

3

E

R

1

3

E

R

1

3

E

R

6

3

E

RX

6

37

E

RX

6

37

E

RX

6

37

E

RX

6

37

E

RX

6

37

E

RX

12

37

探测序列 折回到0
keys[] vals[]

图 3.4.6　标准索引用例使用的基于线性探测的符号表的轨迹

0 7

3 4

10 11

图 4.1.7 二分图

tinyG.txt

V

13

E

13

05

43

01

9 12

64

54

02

11 12

9 10

06

78

9 11

53

% java Graph tinyG.txt

13 vertices, 13 edges

0: 6 2 1 5

1: 0

2: 0 3: 5 4 4: 5 6 3 5: 3 4 0

输入的第一个 相邻顶点在链表 中排在最后

6: 0 4

7: 8

8: 7

9: 11 10 12

10: 9

每条边在第

11: 9 12 二次出现时

12: 11 9 都被标记为红色

图 4.1.10 由边得到的邻接表

图 4.1.12 Tremaux 搜索

dfs(0)

dfs(0)

marked[] adj[]

0T 1 2 3 4 5

0 215 1 02 2 0134 3 542 4 32 5 30

dfs(2) 检查 0

edgeTo[]
0 1 2 3 4 5
0 1 20 3 4 5

dfs(2) 检查 0

0T 1 2T 3 4 5

0 215 1 02 2 0134 3 542 4 32 5 30

dfs(1) 检查 0 检查 2
1 完成

0 12 20 3 4 5

dfs(1) 检查 0 检查 2
1 完成

0T 1T 2T 3 4 5

0 215 1 02 2 0134 3 542 4 32 5 30

dfs(3)

0 12 20 32 4 5

dfs(3)

0T 1T 2T 3T 4 5

0 215 1 02 2 0134 3 542 4 32 5 30

dfs(5) 检查 3 检查 0
5 完成

0 12 20 32 4 53

dfs(5) 检查 3 检查 0
5 完成
dfs(4) 检查 3 检查 2
4 完成 检查 2 3 完成 检查 4 2 完成 检查 1 检查 5 0 完成

0T 1T 2T 3T 4 5T

0 215 1 02 2 0134 3 542 4 32 5 30

0T 1T 2T 3T 4T 5T

0 215 1 02 2 0134 3 542 4 32 5 30

dfs(4) 检查 3 检查 2
4 完成 检查 2 3 完成 检查 4 2 完成 检查 1 检查 5 0 完成

0 12 20 32 43 53
0 12 20 32 43 53

图 4.1.14　使用深度优先搜索的轨迹，寻找所有和顶点 0 图 4.1.15　使用深度优先搜索的轨迹，寻找所有

连通的顶点

起点为 0 的路径

queue 0
2 1 5
1 5 3 4
5 3 4
3 4
4

marked[] edgeTo[]

0T

0

1

1

2

2

3

3

4

4

5

5

adj[]
0 215 1 02 2 0134 3 542 4 32 5 30

0T 1T 2T 3 4 5T

0 10 20 3 4 50

0 215 1 02 2 0134 3 542 4 32 5 30

0T 1T 2T 3T 4T 5T

0 10 20 32 42 50

0 215 1 02 2 0134 3 542 4 32 5 30

0T 1T 2T 3T 4T 5T

0 10 20 32 42 50

0 215 1 02 2 0134 3 542 4 32 5 30

0T 1T 2T 3T 4T 5T

0 10 20 32 42 50

0 215 1 02 2 0134 3 542 4 32 5 30

0T 1T 2T 3T 4T 5T

0 10 20 32 42 50

0 215 1 02 2 0134 3 542 4 32 5 30

图 4.1.18　使用广度优先搜索的轨迹，寻找所有起点为 0 的路径

将灰色和白色顶点区别 开来的横切边为红色
f e 权重最小的横切边肯 定属于最小生成树
图 4.3.4 切分定理
最小生成树中的边
切分生成的权 重最小的边

0 1 2 3 4 5 6 7 8 9 10 11 12

0TTTTTT

1

T

2T TTT T T

3 T TTT TT

4 T TT TT T

5 T T T T TT

原始有向图
中的边（红色）顶点12是从 顶点6可达的
自环（灰色）

6T T T TT TT

TTTT

7 T T T T T TTTT T T T T

8 T T T T T T TTTT T T T

9TTTTTT

TTTT

10 T T T T T T

TT TT

11 T T T T T T

T TTT

12 T T T T T T

T T TT

图 4.2.18 传递闭包

图 4.3.6 贪心最小生成树算法

失效的边 横切边 （灰色） （红色）

将要添加到最

小生成树中的

树中的边 权重最小的横

（黑色加粗）

切边

图 4.3.9 最小生成树的 Prim 算法

* 表示新 加入的边
* 1-7 0.19 0-2 0.26
* 5-7 0.28 * 2-7 0.34 * 4-7 0.37
0-4 0.38 6-0 0.58
* 2-3 0.17 5-7 0.28 1-3 0.29 1-5 0.32 2-7 0.34 1-2 0.36 4-7 0.37 0-4 0.38
* 6-2 0.40 6-0 0.58
1-3 0.29 1-5 0.32 2-7 0.34 * 4-5 0.35 1-2 0.36 4-7 0.37 0-4 0.38 6-2 0.40 3-6 0.52 6-0 0.58
3-6 0.52 6-0 0.58 6-4 0.93

* 0-7 0.16 * 0-2 0.26 * 0-4 0.38 * 6-0 0.58
所有横切边 （按照权重排序）
0-2 0.26 5-7 0.28 * 1-3 0.29 * 1-5 0.32 2-7 0.34 * 1-2 0.36 4-7 0.37 0-4 0.38 6-0 0.58
失效的边 5-7 0.28 （灰色） 1-3 0.29
1-5 0.32 2-7 0.34 1-2 0.36 4-7 0.37 0-4 0.38 6-2 0.40 * 3-6 0.52 6-0 0.58
1-2 0.36 4-7 0.37 0-4 0.38 6-2 0.40 3-6 0.52 6-0 0.58 * 6-4 0.93

图 4.3.10 Prim 算法的轨迹

黑色：最小 生成树中的边
红色：优先队 列（pq）中的边
灰色：非最小 生成树中的边
红色加粗：优先 队列（pq）中的最 小边，即将被加 入最小生成树

edgeTo[] distTo[]
0 1 2 0-2 0.26 3 4 0-4 0.38 5 6 6-0 0.58 7 0-7 0.16
0 1 1-7 0.19 2 0-2 0.26 3 4 4-7 0.37 5 5-7 0.28 6 6-0 0.58 7 0-7 0.16
0 1 1-7 0.19 2 0-2 0.26 3 1-3 0.29 4 4-7 0.37 5 5-7 0.28 6 6-0 0.58 7 0-7 0.16
0 1 1-7 0.19 2 0-2 0.26 3 2-3 0.17 4 4-7 0.37 5 5-7 0.28 6 6-2 0.40 7 0-7 0.16
0 1 1-7 0.19 2 0-2 0.26 3 2-3 0.17 4 4-7 0.37 5 5-7 0.28 6 6-2 0.40 7 0-7 0.16
0 1 1-7 0.19 2 0-2 0.26 3 2-3 0.17 4 4-5 0.35 5 5-7 0.28 6 6-2 0.40 7 0-7 0.16
0 1 1-7 0.19 2 0-2 0.26 3 2-3 0.17 4 4-5 0.35 5 5-7 0.28 6 6-2 0.40 7 0-7 0.16
0 1 1-7 0.19 2 0-2 0.26 3 2-3 0.17 4 4-5 0.35 5 5-7 0.28 6 6-2 0.40 7 0-7 0.16

4.3.12  Prim 算法的轨迹图

下一条将要被加入最 小生成树中的边为红色
按权重排 序的所有边 最小生成树 的边（黑色）
0-7 0.16 2-3 0.17 1-7 0.19 0-2 0.26 5-7 0.28 1-3 0.29 1-5 0.32 2-7 0.34 4-5 0.35 1-2 0.36 4-7 0.37 0-4 0.38 6-2 0.40 3-6 0.52 6-0 0.58 6-4 0.93 无用的 边（灰色）
灰色的顶点是由和所 有红色边的顶点相邻 的顶点所构成的一个切分
图 4.3.14 Kruskal 算法的轨迹

父链接数组

0 6->0 1 null 2 6->2 3 1->3 4 6->4 5 7->5 6 3->6 7 2->7
0 6->0 1 5->1 2 6->2 3 null 4 6->4 5 7->5 6 3->6 7 2->7

0 1
2 3

4
0 6->1 1 5->1 2 6->2 5 3 1->3 4 5->4 5 null 6 3->6 7 5->7

0 6->0

1 5->1

2 6->2

3 7->3

7

4 5->4

5 7->5

6 3->6

7 null

0 null 1 5->1 2 0->2 3 7->3 4 0->4 5 4->5 6 3->6 7 2->7
0 6->0 1 5->1 2 null 3 7->3 4 5->4 5 7->5 6 3->6 7 2->7
起点
0 6->0 1 5->1 2 6->2 3 7->3 4 null 5 4->5 6 3->6 7 4->7
0 6->0 1 5->1 2 6->2 3 7->3 4 6->4 5 7->5 6 6 null 7 2->7

图 4.4.2 最短路径树

v→w失效
s 在edgeTo[] 中的黑色边
s

distTo[v]

v→w是有效的

v 3.1 v→w的权重为1.3

s

w 3.3

distTo[w]

v 不更新数据 s
w

图 4.4.6 边的松弛的两种情况

v 3.1
w 7.2
v 3.1 edgeTo[w]
w 4.4 不再存放于最 短路径树中

最短路径树 的边（黑色）
s v

横切边（红色）
w
从s到w的最短路径 上的横切边，只有 一条横切边必然在 最短路径树中

图 4.4.9 Dijkstra 的最短路径算法

红色顶点： 已被加入优 先队列（pq） 0
1
2 3 4 5 6 7
黑色顶点：已被加 入最短路径树 0
1 2 3 4 5 6 7

edgeTo[] 0->2 0.26 0->4 0.38
索引
0->2 0.26 0->4 0.38 2->7 0.34

distTo[] 0.00 0.26 0.38
优先级 0.00 0.26 0.38
0.60

0 1 2 0->2 0.26 3 4 0->4 0.38 5 4->5 0.35 6 7 2->7 0.34

0.00
0.26
0.38 0.73
0.60

0 1 2 0->2 0.26 3 7->3 0.39 4 0->4 0.38 5 4->5 0.35 6 7 2->7 0.34

0.00
0.26 0.99 0.38 0.73
0.60

0 1 5->1 0.32 2 0->2 0.26 3 7->3 0.39 4 0->4 0.38 5 4->5 0.35 6 7 2->7 0.34

0.00 1.05 0.26 0.99 0.38 0.73
0.60

0 1 5->1 0.32 2 0->2 0.26 3 7->3 0.39 4 0->4 0.38 5 4->5 0.35 6 3->6 0.52 7 2->7 0.34
0 1 5->1 0.32 2 0->2 0.26 3 7->3 0.39 4 0->4 0.38 5 4->5 0.35 6 3->6 0.52 7 2->7 0.34
0 1 5->1 0.32 2 0->2 0.26 3 7->3 0.39 4 0->4 0.38 5 4->5 0.35 6 3->6 0.52 7 2->7 0.34

0.00 1.05 0.26 0.99 0.38 0.73 1.51 0.60
0.00 1.05 0.26 0.99 0.38 0.73 1.51 0.60
0.00 1.05 0.26 0.99 0.38 0.73 1.51 0.60

图 4.4.10 Dijkstra 算法的轨迹

拓扑排序
51364702

edgeTo[] 0 1 5->1 2 3 4 5->4 5 6 7 5->7

黑色加粗：树中的边
0 1 2 3 4 5 6 7
红色：正在被添
加到树中的边 0
1 2 3 4 5 6 7

5->1 1->3 5->4
5->7
5->1 1->3 5->4 3->6 5->7

0 6->0 1 5->1 2 6->2 3 1->3 4 5->4 5 6 3->6 7 5->7

灰色：失 效的边

0 4->0 1 5->1 2 6->2 3 1->3 4 5->4 5 6 3->6 7 5->7
0 4->0 1 5->1 2 7->2 3 1->3 4 5->4 5 6 3->6 7 5->7

0 4->0 1 5->1 2 7->2 3 1->3 4 5->4 5 6 3->6 7 5->7

图 4.4.13　寻找无环加权有向图中的 最短路径的算法轨迹

拓扑排序
51364702
刚刚失效

edgeTo[] 0 1 5->1 2 3 4 5->4 5 6 7 5->7
0 1 5->1 2 3 1->3 4 5->4 5 6 7 5->7
0 1 5->1 2 3 1->3 4 5->4 5 6 3->6 7 3->7
0 6->0 1 5->1 2 6->2 3 1->3 4 6->4 5 6 3->6 7 3->7
0 4->0 1 5->1 2 6->2 3 1->3 4 6->4 5 6 3->6 7 4->7
0 4->0 1 5->1 2 7->2 3 1->3 4 6->4 5 6 3->6 7 4->7
0 4->0 1 5->1 2 7->2 3 1->3 4 6->4 5 6 3->6 7 4->7

图 4.4.14 无环图中的最长路径算法

tinyEWDnc.txt

V

8 15

E

4 5 0.35

5 4 -0.66

4 7 0.37

5 7 0.28

7 5 0.28

5 1 0.32

0 4 0.38

0 2 0.26

7 3 0.39

1 3 0.29

2 7 0.34

6 2 0.40

3 6 0.52

6 0 0.58

6 4 0.93

从顶点0到顶点6的最短路径 0->4->7->5->4->7->5…->1->3->6

图 4.4.20　含有负权重环的加权有向图

灰色：从s不可达的顶点

白色：从s可达的顶点

黑色轮廓：存

s

在从s到达该顶

点的最短路径

负权重环

红边轮廓：不存在从s到达该顶点的最短路径 图 4.4.21 最短路径问题的各种可能性

queue queue
1 31 3

起点 起点
1 1

每一轮队列中的有

效每顶一点轮均队为列红中色的有

效顶点均为红色

3

3

63

3

6

红色：本轮的有效顶点

红色：本轮的有效顶点
6

46 04 20

2

6

黑色：下一轮的有效顶点6

黑色：下一轮的有效顶点

4
04 20 27
57 4 54

2

02

0

6

为边重新着色 6

为边重新着色

75

57

5

7

5

7

edgeTo[]
0 edgeTo[] 01 21 32 1->3 43 1->3 45 65 76
7
edgeTo[]
0 edgeTo[] 01 21 32 1->3 43 1->3 45 65 3->6 67 3->6
7
edgeTo[]
0 ed6g-e>T0o[] 01 6->0 21 6->2 32 16-->>32 34 16-->>34 54 6->4 65 3->6 76 3->6
7
edgeTo[]
0 ed6g-e>T0o[] 01 6->0 21 6->2 32 16-->>32 43 61-->>43 54 46-->>54 56 43-->>56 76 23-->>76
7 2->7
edgeTo[]
0 ed6g-e>T0o[] 01 6->0 21 6->2 32 16-->>32 43 61-->>43 54 76-->>54 56 73-->>56 76 23-->>76
7 2->7
edgeTo[]
0 ed6g-e>T0o[] 01 6->0 21 6->2 32 16-->>32 43 61-->>43 54 76-->>54 65 37-->>65 76 23-->>76
7 2->7

图 4.4.22 Bellman-Ford 算法的轨迹

轮数 4
红色表示的是队列中的边 7
10
13
最短 路径树
图 4.4.23 Bellman-Ford 算法（250 个顶点）

tinyEWDn.txt
4->5 0.35 5->4 0.35 4->7 0.37 5->7 0.28 7->5 0.28 5->1 0.32 0->4 0.38 0->2 0.26 7->3 0.39 1->3 0.29 2->7 0.34 6->2 -1.20 3->6 0.52 6->0 -1.40 6->4 -1.25

queue

2

4

7

2

5

4 起点

7

5

5

3

7

1

3

1

3

1

6

6 4

4 5

5 1

edgeTo[] distTo[]

0

1

2 0->2

0.26

3

4 0->4

0.38

5 4->5

0.73

6

7 2->7

0.60

edgeTo[] distTo[]

0

1 5->1

1.05

2 0->2

0.26

3 7->3

0.99

4 0->4

0.38

5 4->5

0.73

6

7 2->7

0.60

edgeTo[] distTo[]

0

1 5->1

1.05

2 0->2

0.26

3 7->3

0.99

4 0->4

0.38

5 4->5

0.73

6 3->6

1.51

7 2->7

0.60

edgeTo[] distTo[]

0

1 5->1

1.05

2 0->2

0.26

3 7->3

0.99

4 6->4

0.26

不再有效！

5 4->5

0.73

6 6 3->6 7 2->7

1.51 0.60

edgeTo[] distTo[]

0

1 5->1

1.05

2 0->2

0.26

3 7->3

0.99

4 6->4

0.26

5 4->5

0.61

6 6 3->6

1.51

7 2->7

0.60

edgeTo[] distTo[]

0

1 5->1

0.93

2 0->2

0.26

3 7->3

0.99

4 6->4

0.26

5 4->5

0.61

6 6 3->6 7 2->7

1.51 0.60

图 4.4.24 Bellman-Ford 算法的轨迹（图中含有负权重边）

tinyEWDnc.txt
4->5 0.35 5->4 -0.66 4->7 0.37 5->7 0.28 7->5 0.28 5->1 0.32 0->4 0.38 0->2 0.26 7->3 0.39 1->3 0.29 2->7 0.34 6->2 0.40 3->6 0.52 6->0 0.58 6->4 0.93

queue
2 4 7 5

2
4 起点

7

5

5

3

7

1

4

3 1

1

3

4

6

7

5

4

edgeTo[] distTo[]

0

1

2 0->2

0.26

3

4 0->4

0.38

5 4->5

0.73

6

7 2->7

0.60

edgeTo[] distTo[]

0

1 5->1

1.05

2 0->2

0.26

3 7->3

0.99

4 5->4

0.07

5 4->5

0.73

6

7 2->7

0.60

edgeTo[] distTo[]

0

1 5->1

1.05

2 0->2

0.26

3 7->3

0.99

4 5->4

0.07

5 4->5

0.42

6 3->6

1.51

7 4->7

0.44

路径0→4→5→4 的长度

图 4.4.25 Bellman-Ford 算法的轨迹

i j i+j 0 1 2 3 4 5 6 7 8 9 10

txt A B A C A D A B R A C

0 2 2 A B R A pat

101 213 303 415 505 6 4 10

ABRA

红色的元素

A B R A 表示匹配失败

ABRA

灰色的元素 有待匹配

AB R A

黑色的元素

和文本匹配

ABRA

ABRA

当j和M相等时返回i

匹配成功

图 5.3.2 暴力子字符串查找

0

1

2

3

4

5

6

7

8

9

(

(

A

*

B

|

A

C

)

D

起始状态

图 5.4.1 模式 ((A*B|AC)D) 所对应的 NFA

10

11

)

接受状态

A

A

A

A

B

D

0 1 2 3 2 3 2 3 2 3 4 5 8 9 10 11

匹配转换：继续扫描下 一个字符并改变状态

-转换：无匹配 时的状态转换

扫描了所有文本字符 并达到接受状态：NFA 识别了文本

图 5.4.2 找到与 ((A*B | AC)D)NFA 相匹配的模式

（2018.5重印）

内容提要
本书作为算法领域经典的参考书，全面介绍了关于算法和数据结构的必备知识，并特别针对排序、 搜索、图处理和字符串处理进行了论述。第 4 版具体给出了每位程序员应知应会的 50 个算法，提供了实 际代码，而且这些 Java 代码实现采用了模块化的编程风格，读者可以方便地加以改造。配套网站提供了 本书内容的摘要及更多的代码实现、测试数据、练习、教学课件等资源。
本书适合用做大学教材或从业者的参考书。

◆ 著　　　　[美] Robert Sedgewick　Kevin Wayne

译　　　　谢路云

责任编辑　朱　巍

执行编辑　丁晓昀　刘美英

◆ 人民邮电出版社出版发行　　北京市丰台区成寿寺路11号 邮编　100164　　电子邮件　315@ptpress.com.cn 网址　http://www.ptpress.com.cn 北京　　　　　　印刷

◆ 开本：787×1092　1/16 印张：40.5 字数：1115千字 印数：113 001 — 118 000册
著作权合同登记号

彩插：12 2012年 10 月第 1 版 2018年 5 月北京第 29 次印刷 图字：01-2011-5236号

定价：99.00元 读者服务热线：(010)51095186转600　印装质量热线：(010)81055316
反盗版热线：(010)81055315 广告经营许可证：京东工商广登字 20170147 号

版权声明
Authorized translation from the English language edition, entitled Algorithms, Fourth Edition, 978-0-32157351-3 by Robert Sedgewick, Kevin Wayne, published by Pearson Education, Inc., publishing as Addison Wesley, Copyright © 2011 by Pearson Education, Inc.
All rights reserved. No part of this book may be reproduced or transmitted in any form or by any means, electronic or mechanical, including photocopying, recording or by any information storage retrieval system, without permission from Pearson Education, Inc.
CHINESE SIMPLIFIED language edition published by PEARSON EDUCATION ASIA LTD. and POSTS & TELECOM PRESS Copyright © 2012.
本书中文简体字版由Pearson Education Asia Ltd.授权人民邮电出版社独家出版。未经出版者书面 许可，不得以任何方式复制或抄袭本书内容。
本书封面贴有Pearson Education（培生教育出版集团）激光防伪标签，无标签者不得销售。 版权所有，侵权必究。

谨以此书献给Adam、Andrew、Brett、Robbie，并特别感谢Linda。 ——Robert Sedgewick
献给Jackie和Alex。 ——Kevin Wayne

译　者　序
在计算机领域，算法是一个永恒的主题。即使仅把算法入门方面的书都摆出来，国内外的加起 来怕是能铺满整个天安门广场。在这些书中，有几本尤其与众不同，本书就是其中之一。
本书是学生的良师。在翻译的过程中我曾无数次感叹：“要是当年我能拥有这本书那该多好！” 应该说本书是为在校学生量身打造的。没有数学基础？没关系，只要你在高中学过了数学归纳法，那 么书中95%以上的数学内容你都可以看得懂，更何况书中还辅以大量图例。没学过编程？没关系，第 1章会给大家介绍足够多的Java知识，即使你不是计算机专业的学生，也不会遇到困难。整本书的内 容编排循序渐进，由易到难，前后呼应，足见作者的良苦用心。没有比本书更专业的算法教科书了。
本书是老师的好帮手。如果老师们还只能照本宣科，只能停留在算法本身一二三四的阶段， 那就已经大大落后于这个时代了。算法并不仅仅是计算的方法，探究算法的过程反映出的是我们对 这个世界的认知方法：是唯唯诺诺地将课本当做圣经，还是通过“实验—失败—再实验”循环的锤 炼？数学是保证，数据是验证。本书通过各种算法，从各个角度，多次说明了这个道理，这也正是 第1章是全书内容最多的一章的原因。希望每一位读者都不要错过第1章。无论你有没有编程基础， 都会从中得到有益的启示。
本书是程序员的益友。在工作了多年之后，快速排序、霍夫曼编码、KMP等曾经熟悉的概念在你 脑中是不是已经凋零成了一个个没有内涵的名词？是时候重新拾起它们了。无论是为手头的工作寻找 线索，还是为下一份工作努力准备，这些算法基础知识都是你不能跳过的。本书强调软件工程中的最 佳实践，特别适合已有工作经验的程序员朋友。所有的算法都是先有API，再有实现，之后是证明，最 后是数据。这种先接口后实现、强调测试的做法，无疑是在工作中摸爬滚打多年的程序员最熟悉的。
本书也有一些遗憾，比如没有介绍动态规划这样重要的思想。但是瑕不掩瑜，它仍然是最好的 入门级算法书。我强烈地希望能够把本书翻译成中文，但同时也诚惶诚恐，如履薄冰，担心自己的 水平不足以准确传达原文的意思。翻译的过程虽然辛苦，但我觉得非常值得。感谢人民邮电出版社 图灵公司给了我这个机会，感谢编辑和审稿专家的细心检查。同时感谢我的妻子朱天的全力支持。 译者水平有限，bug在所难免，还请读者批评指正。
谢路云 2012.9.17

前　　言
本书力图研究当今最重要的计算机算法并将一些最基础的技能传授给广大求知者。它适合用做 计算机科学进阶教材，面向已经熟悉了计算机系统并掌握了基本编程技能的学生。本书也可用于自 学，或是作为开发人员的参考手册，因为书中实现了许多实用算法并详尽分析了它们的性能特点和 用途。这本书取材广泛，很适合作为该领域的入门教材。
算法和数据结构的学习是所有计算机科学教学计划的基础，但它并不只是对程序员和计算机 系的学生有用。任何计算机使用者都希望计算机能运行得更快一些或是能解决更大规模的问题。本 书中的算法代表了近50年来的大量优秀研究成果，是人们工作中必备的知识。从物理中的N体模拟 问题到分子生物学中的基因序列问题，我们描述的基本方法对科学研究而言已经必不可少；从建筑 建模系统到模拟飞行器，这些算法已经成为工程领域极其重要的工具；从数据库系统到互联网搜索 引擎，算法已成为现代软件系统中不可或缺的一部分。这仅是几个例子而已，随着计算机应用领域 的不断扩张，这些基础方法的影响也会不断扩大。
在开始学习这些基础算法之前，我们先要熟悉全书中都将会用到的栈、队列等低级抽象的数据 类型。然后依次研究排序、搜索、图和字符串方面的基础算法。最后一章将会从宏观角度总结全书 的内容。
独特之处
本书致力于研究有实用价值的算法。书中讲解了多种算法和数据结构，并提供了大量相关的信 息，读者应该能有信心在各种计算环境下实现、调试并应用它们。本书的特点涉及以下几个方面。
算法　书中均有算法的完整实现，并讨论了程序在多个样例上的运行状况。书中的代码都是可 以运行的程序而非伪代码，因此非常便于投入使用。书中程序是用Java语言编写的，但其编程风格 方便读者使用其他现代编程语言重用其中的大部分代码来实现相同算法。
数据类型　我们在数据抽象上采用了现代编程风格，将数据结构和算法封装在了一起。
应用　每一章都会给出所述算法起到关键作用的应用场景。这些场景多种多样，包括物理模拟 与分子生物学、计算机与系统工程学，以及我们熟悉的数据压缩和网络搜索等。
学术性　我们非常重视使用数学模型来描述算法的性能。我们用模型预测算法的性能，然后在 真实的环境中运行程序来验证预测。
广度　本书讨论了基本的抽象数据类型、排序算法、搜索算法、图及字符串处理。我们在算法

前　　言 VII
的讨论中研究数据结构、算法设计范式、归纳法和解题模型。这将涵盖20世纪60年代以来的经典方 法以及近年来产生的新方法。
我们的主要目标是将今天最重要的实用算法介绍给尽可能广泛的群体。这些算法一般都十分巧 妙奇特，20行左右的代码就足以表达。它们展现出的问题解决能力令人叹为观止。没有它们，创造 计算智能、解决科学问题、开发商业软件都是不可能的。
本书网站
本书的一个亮点是它的配套网站algs4.cs.princeton.edu。这一网站面向教师、学生和专业人士， 免费提供关于算法和数据结构的丰富资料。
一份在线大纲　包含了本书内容的结构并提供了链接，浏览起来十分方便。 全部实现代码　书中所有的代码均可以在这里找到，且其形式适合用于程序开发。此外，还包 括算法的其他实现，例如高级的实现、书中提及的改进的实现、部分习题的答案以及多个应用场景的 客户端代码。我们的重点是用真实的应用环境来测试算法。 习题与答案　网站还提供了一些附加的选择题（只需要一次单击便可获取答案）、很多算法应 用的例子、编程练习和答案以及一些有挑战性的难题。 动态可视化　书是死的，但网站是活的，在这里我们充分利用图形类演示了算法的应用效果。 课程资料　网站包含和本书及网上内容对应的一整套幻灯片，以及一系列编程作业、核对表、 测试数据和备课手册。 相关资料链接　网站包含大量的链接，提供算法应用的更多背景知识以及学习算法的其他资源。
我们希望这个站点和本书互为补充。一般来说，建议读者在第一次学习某种算法或是希望获得 整体概念时看书，并把网站作为编程时的参考或是在线查找更多信息的起点。
作为教材
本书为计算机科学专业进阶的教材，涵盖了这门学科的核心内容，并能让学生充分锻炼编程、 定量推理和解决问题等方面的能力。一般来说，此前学过一门计算机方面的先导课程就足矣，只要 熟悉一门现代编程语言并熟知现代计算机系统，就都能够阅读本书。
虽然本书使用Java实现算法和数据结构，但其代码风格使得熟悉其他现代编程语言的人也能看 懂。我们充分利用了Java的抽象性（包括泛型），但不会依赖这门语言的独门特性。
书中涉及的多数数学知识都有完整的讲解（少数会有延伸阅读），因此阅读本书并不需要准备 太多数学知识，不过有一定的数学基础当然更好。应用场景都来自其他学科的基础内容，同样也在 书中有完整介绍。
本书涉及的内容是任何准备主修计算机科学、电气工程、运筹学等专业的学生应了解的基础知 识，并且对所有对科学、数学或工程学感兴趣的学生也十分有价值。

VIII 前　　言
背景介绍
这本书意在接续我们的一本基础教材《Java程序设计：一种跨学科的方法》，那本书对计算机 领域做了概括性介绍。这两本书合起来可用做两到三个学期的计算机科学入门课程教材，为所有学 生在自然科学、工程学和社会科学中解决计算问题提供必备的基础知识。
本书大部分内容来自Sedgewick的算法系列图书。本质上，本书和该系列的第1版和第2版最接 近，但还包含了作者多年教学和学习的经验。Sedgewick的《C算法（第3版）》、《C++算法（第3版）》、 《Java算法（第3版）》更适合用做参考书或是高级课程的教材，而本书则是专门为大学一、二年级 学生设计的一学期教材，也是最新的基础入门书或从业者的参考书。
致谢
本书的编写花了近40年时间，因此想要一一列出所有参与人是不可能的。本书的前几版一共列出 了好几十人，其中包括（按字母顺序）Andrew Appel、Trina Avery、Marc Brown、Lyn Dupré、Philippe Flajolet、Tom Freeman、Dave Hanson、Janet Incerpi、Mike Schidlowsky、Steve Summit和Chris Van Wyk。我要感谢他们所有人，尽管其中有些人的贡献要追溯到几十年前。至于第4版，我们要感谢 试用了本书样稿的普林斯顿及其他院校的数百名学生，以及通过本书网站发表意见和指出错误的世 界各地的读者。
我们还要感谢普林斯顿大学对于高质量教学的坚定支持，这是本书得以面世的基础。
Peter Gordon几乎从本书写作之初就提出了很多有用的建议，这一版奉行的“归本溯源”的指导 思想也是他最早提出的。关于第4版，我们要感谢Barbara Wood认真又专业的编辑工作，Julie Nahil对 生产过程的管理，以及Pearson出版公司中为本书的付梓和营销辛勤工作的朋友。所有人都在积极地 追赶进度，而本书的质量并没有受到丝毫影响。

目　　录

第1章 基础 ...........................................................1
1.1　基础编程模型 ............................................4 1.1.1　Java程序的基本结构 .....................4 1.1.2　原始数据类型与表达式 ................6 1.1.3 语句 ................................................8 1.1.4 简便记法 ........................................9 1.1.5 数组 ..............................................10 1.1.6 静态方法 ......................................12 1.1.7 API................................................16 1.1.8 字符串 ..........................................20 1.1.9 输入输出 ......................................21 1.1.10 二分查找 ....................................28 1.1.11 展望 ............................................30
1.2 数据抽象 ..................................................38 1.2.1 使用抽象数据类型 ......................38 1.2.2 抽象数据类型举例 ......................45 1.2.3 抽象数据类型的实现 ..................52 1.2.4 更多抽象数据类型的实现 ..........55 1.2.5 数据类型的设计 ..........................60
1.3 背包、队列和栈 ......................................74 1.3.1 API................................................74 1.3.2 集合类数据类型的实现 ..............81 1.3.3 链表 ..............................................89 1.3.4 综述 ..............................................98
1.4 算法分析 ................................................108 1.4.1 科学方法 ....................................108 1.4.2 观察 ............................................108 1.4.3 数学模型 ....................................112 1.4.4 增长数量级的分类 ....................117 1.4.5 设计更快的算法 ........................118 1.4.6 倍率实验 ....................................121 1.4.7 注意事项 ....................................123 1.4.8 处理对于输入的依赖 ................124 1.4.9 内存 ............................................126

1.4.10 展望 ..........................................129 1.5 案例研究：union-ﬁnd算法 ...................136
1.5.1 动态连通性 ................................136 1.5.2 实现 ............................................140 1.5.3 展望 ............................................148
第2章 排序 .......................................................152
2.1 初级排序算法 ........................................153 2.1.1 游戏规则 ....................................153 2.1.2 选择排序 ....................................155 2.1.3 插入排序 ....................................157 2.1.4 排序算法的可视化 ....................159 2.1.5 比较两种排序算法 ....................159 2.1.6 希尔排序 ....................................162
2.2 归并排序 ................................................170 2.2.1 原地归并的抽象方法 ................170 2.2.2 自顶向下的归并排序 ................171 2.2.3 自底向上的归并排序 ................175 2.2.4 排序算法的复杂度 ....................177
2.3 快速排序 ................................................182 2.3.1 基本算法 ....................................182 2.3.2 性能特点 ....................................185 2.3.3 算法改进 ....................................187
2.4 优先队列 ................................................195 2.4.1 API..............................................195 2.4.2 初级实现 ....................................197 2.4.3 堆的定义 ....................................198 2.4.4 堆的算法 ....................................199 2.4.5 堆排序 ........................................205
2.5 应用 ........................................................214 2.5.1 将各种数据排序 ........................214 2.5.2 我应该使用哪种排序算法 ........218 2.5.3 问题的归约 ................................219 2.5.4 排序应用一览 ............................221

X 目　　录

第3章　查找 .......................................................227
3.1　符号表 ....................................................228 3.1.1　API ..............................................228 3.1.2　有序符号表 ................................230 3.1.3　用例举例 ....................................233 3.1.4　无序链表中的顺序查找 ............235 3.1.5　有序数组中的二分查找 ............238 3.1.6　对二分查找的分析 ....................242 3.1.7　预览 ............................................244
3.2　二叉查找树 ............................................250 3.2.1　基本实现 ....................................250 3.2.2　分析 ............................................255
3.2.3　有序性相关的方法与删除 操作 ............................................257
3.3　平衡查找树 ............................................269 3.3.1　2-3查找树 ...................................269 3.3.2　红黑二叉查找树 ........................275 3.3.3　实现 ............................................280 3.3.4　删除操作 ....................................282 3.3.5　红黑树的性质 ............................284
3.4　散列表 ....................................................293 3.4.1　散列函数 ....................................293 3.4.2　基于拉链法的散列表 ................297 3.4.3　基于线性探测法的散列表 ........300 3.4.4　调整数组大小 ............................304 3.4.5　内存使用 ....................................306
3.5　应用 ........................................................312
3.5.1　我应该使用符号表的哪种 实现 ............................................312
3.5.2　集合的API ..................................313 3.5.3　字典类用例 ................................315 3.5.4　索引类用例 ................................318 3.5.5　稀疏向量 ....................................322
第4章 图 ...........................................................329
4.1 无向图 ....................................................331 4.1.1 术语表 ........................................331 4.1.2 表示无向图的数据类型 ............333 4.1.3 深度优先搜索 ............................338 4.1.4 寻找路径 ....................................342 4.1.5 广度优先搜索 ............................344 4.1.6 连通分量 ....................................349 4.1.7 符号图 ........................................352 4.1.8 总结 ............................................358

4.2 有向图 ....................................................364 4.2.1 术语 ............................................364 4.2.2 有向图的数据类型 ....................365 4.2.3 有向图中的可达性 ....................367 4.2.4 环和有向无环图 ........................369 4.2.5 有向图中的强连通性 ................378 4.2.6 总结 ............................................385
4.3 最小生成树 ............................................390 4.3.1 原理 ............................................391 4.3.2 加权无向图的数据类型 ............393
4.3.3 最小生成树的API和测试 用例 ............................................396
4.3.4 Prim算法 ....................................398 4.3.5 Prim算法的即时实现 ................401 4.3.6 Kruskal算法 ...............................404 4.3.7 展望 ............................................407 4.4 最短路径 ................................................412 4.4.1 最短路径的性质 ........................413 4.4.2 加权有向图的数据结构 ............414 4.4.3 最短路径算法的理论基础 ........420 4.4.4 Dijkstra算法 ...............................421
4.4.5 无环加权有向图中的最短 路径算法 ....................................425
4.4.6 一般加权有向图中的最短 路径问题 ....................................433
4.4.7 展望 ............................................445
第5章 字符串...................................................451
5.1 字符串排序 ............................................455 5.1.1 键索引计数法 ............................455 5.1.2 低位优先的字符串排序 ............458 5.1.3 高位优先的字符串排序 ............461 5.1.4 三向字符串快速排序 ................467 5.1.5 字符串排序算法的选择 ............470
5.2 单词查找树 ............................................474 5.2.1 单词查找树 ................................475 5.2.2 单词查找树的性质 ....................483 5.2.3 三向单词查找树 ........................485 5.2.4 三向单词查找树的性质 ............487
5.2.5 应该使用字符串符号表的 哪种实现 ....................................489
5.3 子字符串查找 ........................................493 5.3.1 历史简介 ....................................493 5.3.2 暴力子字符串查找算法 ............494

目　　录 XI

5.3.3 Knuth-Morris-Pratt子字符串 查找算法 ....................................496
5.3.4 Boyer-Moore字符串查找算 法 ................................................502
5.3.5 Rabin-Karp指纹字符串查找 算法 ............................................505
5.3.6 总结 ............................................509 5.4 正则表达式 ............................................514
5.4.1 使用正则表达式描述模式 ........514 5.4.2 缩略写法 ....................................516 5.4.3 正则表达式的实际应用 ............517 5.4.4 非确定有限状态自动机 ............518 5.4.5 模拟NFA的运行 ........................520

5.4.6 构造与正则表达式对应的 NFA ............................................522
5.5 数据压缩 ................................................529 5.5.1 游戏规则 ....................................529 5.5.2 读写二进制数据 ........................530 5.5.3 局限 ............................................533 5.5.4 热身运动：基因组 ....................534 5.5.5 游程编码 ....................................537 5.5.6 霍夫曼压缩 ................................540
第6章 背景 .......................................................558
索引 ......................................................................611

第1章 基 础

~

本书的目的是研究多种重要而实用的算法，即适合用计算机实现的解决问题的方法。和算法关

系最紧密的是数据结构，即便于算法操作的组织数据的方法。本章介绍的就是学习算法和数据结构

所需要的基本工具。

首先要介绍的是我们的基础编程模型。本书中的程序只用到了 Java 语言的一小部分，以及我们

自己编写的用于封装输入输出以及统计的一些库。1.1 节总结了相关的语法、语言特性和书中将会

用到的库。

接下来我们的重点是数据抽象并定义抽象数据类型（ADT）以进行模块化编程。在 1.2 节中我

们介绍了用 Java 实现抽象数据类型的过程，包括定义它的应用程序编程接口（API）然后通过 Java

的类机制来实现它以供各种用例使用。

之后，作为重要而实用的例子，我们将学习三种基础的抽象数据类型：背包、队列和栈。1.3

节用数组、变长数组和链表实现了背包、队列和栈的 API，它们是全书算法实现的起点和样板。

性能是算法研究的一个核心问题。1.4 节描述了分析算法性能的方法。我们的基本做法是科学

式的，即先对性能提出假设，建立数学模型，然后用多种实验验证它们，必要时重复这个过程。

我们用一个连通性问题作为例子结束本章，它的解法所用到的算法和数据结构可以实现经典的 1

union-ﬁnd 抽象数据结构。

3

算法

编写一段计算机程序一般都是实现一种 已有的方法来解决某个问题。这种方法大多 和使用的编程语言无关——它适用于各种计 算机以及编程语言。是这种方法而非计算机 程序本身描述了解决问题的步骤。在计算机 科学领域，我们用算法这个词来描述一种有 限、确定、有效的并适合用计算机程序来实 现的解决问题的方法。算法是计算机科学的 基础，是这个领域研究的核心。
要定义一个算法，我们可以用自然语言 描述解决某个问题的过程或是编写一段程序 来实现这个过程。如发明于 2300 多年前的欧 几里得算法所示，其目的是找到两个数的最 大公约数：

自然语言描述
计算两个非负整数 p 和 q 的最大公约数：若 q 是 0，则最大公约数为 p。否则，将 p 除以 q 得到余数 r，p 和 q 的最大公约数即为 q 和 r 的最大公约数。
Java 语言描述
public static int gcd(int p, int q) {
if (q == 0) return p; int r = p % q; return gcd(q, r); }
欧几里得算法

2 第 1 章　基　　础

如果你不熟悉欧几里得算法，那么你应该在学习了 1.1 节之后完成练习 1.1.24 和练习 1.1.25。

在本书中，我们将用计算机程序来描述算法。这样做的重要原因之一是可以更容易地验证它们是否

如所要求的那样有限、确定和有效。但你还应该意识到用某种特定语言写出一段程序只是表达一个

算法的一种方法。数十年来本书中许多算法都曾被表达为多种编程语言的程序，这正说明每种算法

都是适合于在任何计算机上用任何编程语言实现的方法。

我们关注的大多数算法都需要适当地组织数据，而为了组织数据就产生了数据结构，数据结构

也是计算机科学研究的核心对象，它和算法的关系非常密切。在本书中，我们的观点是数据结构是

算法的副产品或是结果，因此要理解算法必须学习数据结构。简单的算法也会产生复杂的数据结构，

相应地，复杂的算法也许只需要简单的数据结构。本书中我们将会研讨许多数据结构的性质，也许

4 本书就应该叫《算法与数据结构》。

当用计算机解决一个问题时，一般都存在多种不同的方法。对于小型问题，只要管用，方法的

不同并没有什么关系。但是对于大型问题（或者是需要解决大量小型问题的应用），我们就需要设

计能够有效利用时间和空间的方法了。

学习算法的主要原因是它们能节约非常多的资源，甚至能够让我们完成一些本不可能完成的任

务。在某些需要处理上百万个对象的应用程序中，设计优良的算法甚至可以将程序运行的速度提高

数百万倍。在本书中我们将在多个场景中看到这样的例子。与此相反，花费金钱和时间去购置新的

硬件可能只能将速度提高十倍或是百倍。无论在任何应用领域，精心设计的算法都是解决大型问题

最有效的方法。

在编写庞大或者复杂的程序时，理解和定义问题、控制问题的复杂度和将其分解为更容易解决

的子问题需要大量的工作。很多时候，分解后的子问题所需的算法实现起来都比较简单。但是在大

多数情况下，某些算法的选择是非常关键的，因为大多数系统资源都会消耗在它们身上。本书的焦

点就是这类算法。我们所研究的基础算法在许多应用领域都是解决困难问题的有效方法。

计算机程序的共享已经变得越来越广泛，尽管书中涉及了许多算法，我们也只实现了其中的一

小部分。例如，Java 库包含了许多重要算法的实现。但是，实现这些基础算法的简化版本有助于我

们更好地理解、使用和优化它们在库中的高级版本。更重要的是，我们经常需要重新实现这些基础

算法，因为在全新的环境中（无论是硬件的还是软件的），原有的实现无法将新环境的优势完全发

挥出来。在本书中，我们的重点是用最简洁的方式实现优秀的算法。我们会仔细地实现算法的关键

部分，并尽最大努力揭示如何进行有效的底层优化工作。

5

为一项任务选择最合适的算法是困难的，这可能会需要复杂的数学分析。计算机科学中研究这

种问题的分支叫做算法分析。通过分析，我们将要学习的许多算法都有着优秀的理论性能；而另一

些我们则只是根据经验知道它们是可用的。我们的主要目标是学习典型问题的各种有效算法，但也

会注意比较不同算法之间的性能差异。不应该使用资源消耗情况未知的算法，因此我们会时刻关注

算法的期望性能。

本书框架
接下来概述一下全书的主要内容，给出涉及的主题以及本书大致的组织结构。这组主题触及了 尽可能多的基础算法，其中的某些领域是计算机科学的核心内容，通过对这些领域的深入研究，我 们找出了应用广泛的基本算法，而另一些算法则来自计算机科学和相关领域比较前沿的研究成果。 总之，本书讨论的算法都是数十年来研发的重要成果，它们将继续在快速发展的计算机应用中扮演 重要角色。

第 1 章　基　　础 3

第 1 章　基础

它讲解了在随后的章节中用来实现、分析和比较算法的基本原则和方法，包括 Java 编程模型、

数据抽象、基本数据结构、集合类的抽象数据类型、算法性能分析的方法和一个案例分析。

第 2 章　排序

有序地重新排列数组中的元素是非常重要的基础算法。我们会深入研究各种排序算法，包括插

入排序、选择排序、希尔排序、快速排序、归并排序和堆排序。同时我们还会讨论另外一些算法，

它们用于解决几个与排序相关的问题，例如优先队列、选举以及归并。其中许多算法会成为后续章

节中其他算法的基础。

第 3 章　查找

从庞大的数据集中找到指定的条目也是非常重要的。我们将会讨论基本的和高级的查找算法，

包括二叉查找树、平衡查找树和散列表。我们会梳理这些方法之间的关系并比较它们的性能。

第 4 章　图

图的主要内容是对象和它们的连接，连接可能有权重和方向。利用图可以为大量重要而困难的

问题建模，因此图算法的设计也是本书的一个主要研究领域。我们会研究深度优先搜索、广度优先

搜索、连通性问题以及若干其他算法和应用，包括 Kruskal 和 Prim 的最小生成树算法、Dijkstra 和

Bellman-Ford 的最短路径算法。

6

第 5 章　字符串

字符串是现代应用程序中的重要数据类型。我们将会研究一系列处理字符串的算法，首先是对

字符串键的排序和查找的快速算法，然后是子字符串查找、正则表达式模式匹配和数据压缩算法。

此外，在分析一些本身就十分重要的基础问题之后，这一章对相关领域的前沿话题也作了介绍。

第 6 章　背景

这一章将讨论与本书内容有关的若干其他前沿研究领域，包括科学计算、运筹学和计算理论。

我们会介绍性地讲一下基于事件的模拟、B 树、后缀数组、最大流量问题以及其他高级主题，以帮

助读者理解算法在许多有趣的前沿研究领域中所起到的巨大作用。最后，我们会讲一讲搜索问题、

问题转化和 NP 完全性等算法研究的支柱理论，以及它们和本书内容的联系。

学习算法是非常有趣和令人激动的，因为这是一个历久弥新的领域（我们学习的绝大多数算法

都还不到“五十岁”，有些还是最近才发明的，但也有一些算法已经有数百年的历史）。这个领域

不断有新的发现，但研究透彻的算法仍然是少数。本书中既有精巧、复杂和高难度的算法，也有优雅、

朴素和简单的算法。在科学和商业应用中，我们的目标是理解前者并熟悉后者，这样才能掌握这些

有用的工具并学会算法式思考，以迎接未来计算任务的挑战。

7

4 第 1 章　基　　础
1.1　基础编程模型
我们学习算法的方法是用 Java 编程语言编写的程序来实现算法。这样做是出于以下原因：  程序是对算法精确、优雅和完全的描述；  可以通过运行程序来学习算法的各种性质；  可以在应用程序中直接使用这些算法。 相比用自然语言描述算法，这些是重要而巨大的优势。 这样做的一个缺点是我们要使用特定的编程语言，这会使分离算法的思想和实现细节变得困难。 我们在实现算法时考虑到了这一点，只使用了大多数现代编程语言都具有且能够充分描述算法所必 需的语法。 我们仅使用了 Java 的一个子集。尽管我们没有明确地说明这个子集的范围，但你也会看到我们 只使用了很少的 Java 特性，而且会优先使用大多数现代编程语言所共有的语法。我们的代码是完整 的，因此希望你能下载这些代码并用我们的测试数据或是你自己的来运行它们。 我们把描述和实现算法所用到的语言特性、软件库和操作系统特性总称为基础编程模型。本 节以及 1.2 节会详细说明这个模型，相关内容自成一体，主要是作为文档供读者查阅，以便理解本 书的代码。我们的另一本入门级的书籍 An Introduction to Programming in Java: An Interdisciplinary Approach 也使用了这个模型。 作为参考，图 1.1.1 所示的是一个完整的 Java 程序。它说明了我们的基础编程模型的许多基本 特点。在讨论语言特性时我们会用这段代码作为例子，但可以先不用考虑代码的实际意义（它实现 了经典的二分查找算法，并在白名单过滤应用中对算法进行了检验，请见 1.1.10 节）。我们假设你 具备某种主流语言编程的经验，因此你应该知道这段代码中的大多数要点。图中的注释应该能够解 答你的任何疑问。因为图中的代码某种程度上反映了本书代码的风格，而且对各种 Java 编程惯例和 8 语言构造，在用法上我们都力求一致，所以即使是经验丰富的 Java 程序员也应该看一看。
1.1.1　Java 程序的基本结构
一段 Java 程序（类）或者是一个静态方法（函数）库，或者定义了一个数据类型。要创建静态 方法库和定义数据类型，会用到下面七种语法，它们是 Java 语言的基础，也是大多数现代语言所共有的。
 原始数据类型：它们在计算机程序中精确地定义整数、浮点数和布尔值等。它们的定义包括 取值范围和能够对相应的值进行的操作，它们能够被组合为类似于数学公式定义的表达式。
 语句：语句通过创建变量并对其赋值、控制运行流程或者引发副作用来进行计算。我们会使 用六种语句：声明、赋值、条件、循环、调用和返回。
 数组：数组是多个同种数据类型的值的集合。  静态方法：静态方法可以封装并重用代码，使我们可以用独立的模块开发程序。  字符串：字符串是一连串的字符，Java 内置了对它们的一些操作。  标准输入 / 输出：标准输入输出是程序与外界联系的桥梁。  数据抽象：数据抽象封装和重用代码，使我们可以定义非原始数据类型，进而支持面向对象编程。 我们将在本节学习前六种语法，数据抽象是下一节的主题。 运行 Java 程序需要和操作系统或开发环境打交道。为了清晰和简洁，我们把这种输入命令执行 程序的环境称为虚拟终端。请登录本书的网站去了解如何使用虚拟终端，或是现代系统中许多其他 高级的编程开发环境的使用方法。 在例子中，BinarySearch 类有两个静态方法 rank() 和 main()。第一个方法 rank() 含有四条 语句：两条声明语句，一条循环语句（该语句中又有一条赋值语句和两条条件语句）和一条返回语句。

1.1　基础编程模型 5

第二个方法 main() 包含三条语句：一条声明语句、一条调用语句和一个循环语句（该语句中又包 含一条赋值语句和一条条件语句）。
要执行一个 Java 程序，首先需要用 javac 命令编译它，然后再用 java 命令运行它。例如，要 运行 BinarySearch，首先要输入 javac BinarySearch.java（这将生成一个叫 BinarySearch.class 的文件，其中含有这个程序的 Java 字节码）；然后再输入 java BinarySearch（接着是一个白名 单文件名）把控制权移交给这段字节码程序。为了理解这段程序，我们接下来要详细介绍原始数据 类型和表达式，各种 Java 语句、数组、静态方法、字符串和输入输出。

导入一个Java库（请见1.1.6.8节） import java.util.Arrays;

代码文件名必须是BinarySearch.java （请见1.1.6.5节）

public class BinarySearch {

参数变量 静态方法（请见1.1.6.1节）

public static int rank(int key, int[] a)

{

初始化声明语句

int lo = 0;

返回值

（请见1.1.4.1节）

int hi = a.length - 1;

参数类型

while (lo <= hi)

{

表达式（请见1.1.2节）

int mid = lo + (hi - lo) / 2;

循环语句（请 见1.1.3.4节）

if

(key < a[mid]) hi = mid - 1;

else if (key > a[mid]) lo = mid + 1;

else

return mid;

}

return -1;

}

返回语句

条件语句（请 见1.1.3.3节）

系统调用：main()

单元测试用例（请见1.1.6.7节）

public static void main(String[] args) { 没有返回值，只有副作用（请见1.1.6.3节）
int[] whitelist = In.readInts(args[0]);

Arrays.sort(whitelist);

调用Java库中的一个 方法（请见1.1.6.8节）

while (!StdIn.isEmpty()) {

调用我们的标准库中的 一个方法，需要下载相 应的代码（请见1.1.6.8节）

int key = StdIn.readInt(); if (rank(key, whitelist) == -1)
StdOut.println(key);

调用本地方法 （请见1.1.6.8节）

}

}

}

系统将"Largew.txt"作 为参数传递给main()

命令行（请见1.1.9.1节）

文件名，即args[0]

% java BinarySearch largeW.txt < largeT.txt

StdOut的输出 （请见1.1.9.2节）

499569 984875

重定向后向StdIn输入

...

的文件（请见1.1.9.5节）
9

~

图 1.1. 1 Java 程序及其命令行的调用

10

6 第 1 章　基　　础

1.1.2　原始数据类型与表达式

数据类型就是一组数据和对其所能进行的操作的集合。首先考虑以下 4 种 Java 语言最基本的原 始数据类型：
 整型，及其算术运算符（int）；  双精度实数类型，及其算术运算符（double）；  布尔型，它的值 {true, false} 及其逻辑操作（boolean）；  字符型，它的值是你能够输入的英文字母数字字符和符号（char）。 接下来我们看看如何指明这些类型的值和对这些类型的操作。 Java 程序控制的是用标识符命名的变量。每个变量都有自己的类型并存储了一个合法的值。在 Java 代码中，我们用类似数学表达式的表达式来实现对各种类型的操作。对于原始类型来说，我们 用标识符来引用变量，用 +、-、*、/ 等运算符来指定操作，用字面量，例如 1 或者 3.14 来表示 值，用形如 (x+2.236)/2 的表达式来表示对值的操作。表达式的目的就是计算某种数据类型的值。 表 1.1.1 对这些基本内容进行了说明。

表 1.1.1 Java 程序的基本组成

术语

例子

定义

原始数据类型 int double boolean char

一组数据和对其所能进行的操作的集合（Java 语言内置）

标识符

a abc Ab$ a_b ab123 lo hi

由字母、数字、下划线和 $ 组成的字符串，首字符不能是 数字

变量

［任意标识符］

表示某种数据类型的值

运算符

+－*/

表示某种数据类型的运算

字面量

int　　　　　　1　0 － 42 double 　　2.0 1.0e-15 3.14 boolean　 　　true false char 　　 'a'　'+'　'9'　'\n'

值在源代码中的表示

表达式 11

int 　　　lo + (hi – lo) / 2 double 　　　1.0e-15 * t boolean 　　 　lo <= hi

字面量、变量或是能够计算出结果的一串字面量、变量和 运算符的组合

只要能够指定值域和在此值域上的操作，就能定义一个数据类型。表 1.1.2 总结了 Java 的 int、double、boolean 和 char 类型的相关信息。许多现代编程语言中的基本数据类型和它们都 很相似。对于 int 和 double 来说，这些操作是我们熟悉的算术运算；对于 boolean 来说则是逻辑 运算。需要注意的重要一点是，+、-、 *、/ 都是被重载过的——根据上下文，同样的运算符对不 同类型会执行不同的操作。这些初级运算的关键性质是运算产生的数据的数据类型和参与运算的数 据的数据类型是相同的。这也意味着我们经常需要处理近似值，因为很多情况下由表达式定义的准 确值并非参与表达式运算的值。例如，5/3 的值是 1 而 5.0/3.0 的值是 1.66666666666667，两者 都很接近但并不准确地等于 5/3。下表并不完整，我们会在本节最后的答疑部分中讨论更多运算符 和偶尔需要考虑到的各种异常情况。

表 1.1.2 Java 中的原始数据类型

类　　型

值　　域

运　算　符

典型表达式 表　达　式

值

int

-231 至 +231-1 之间的整

+（加）

5+3

8

数（32 位，二进制补码）

-（减）

5–3

2

*（乘）

5*3

15

/（除）

5/3

1

%（求余）

5%3

2

1.1　基础编程模型 7

（续）

类　　型

值　　域

运　算　符

典型表达式 表　达　式

值

double

双 精 度 实 数（64 位， IEEE 754 标准）

+（加） -（减） *（乘） /（除）

3.141 + 0.03 2.0 - 2.0e-7 100 * 0.015 6.02e23 / 2.0

3.171 1.9999998 1.5 3.01e23

boolean

true 或 false

&& （与） || （或） ! （非） ^ （异或）

true && false false || true !false true ^ true

false true true false

char

字符（16 位）

（算术运算符，但很少使用）

12

1.1.2.1 表达式 如表 1.1.2 所示，Java 使用的是中缀表达式：一个字面量（或是一个表达式），紧接着是一个运算符，
再接着是另一个字面量（或者另一个表达式）。当一个表达式包含一个以上的运算符时，运算符的 作用顺序非常重要，因此 Java 语言规范约定了如下的运算符优先级：运算符 * 和 /（以及 %）的优 先级高于 + 和 -（优先级越高，越早运算）；在逻辑运算符中，! 拥有最高优先级，之后是 &&，接 下来是 ||。一般来说，相同优先级的运算符的运算顺序是从左至右。与在正常的算数表达式中一样， 使用括号能够改变这些规则。因为不同语言中的优先级规则会有些许不同，我们在代码中会使用括 号并用各种方法努力消除对优先级规则的依赖。 1.1.2.2 类型转换
如果不会损失信息，数值会被自动提升为高级的数据类型。例如，在表达式 1+2.5 中，1 会被 转换为浮点数 1.0，表达式的值也为 double 值 3.5。转换指的是在表达式中把类型名放在括号里 将其后的值转换为括号中的类型。例如，(int)3.7 的值是 3 而 (double)3 的值是 3.0。需要注意 的是将浮点型转换为整型将会截断小数部分而非四舍五入，在复杂的表达式中的类型转换可能会很 复杂，应该小心并尽量少使用类型转换，最好是在表达式中只使用同一类型的字面量和变量。 1.1.2.3 比较
下列运算符能够比较相同数据类型的两个值并产生一个布尔值：相等（==）、不等（!=）、小 于（<）、小于等于（<=）、大于（>）和大于等于（>=）。这些运算符被称为混合类型运算符，因 为它们的结果是布尔型，而不是参与比较的数据类型。结果是布尔型的表达式被称为布尔表达式。 我们将会看到这种表达式是条件语句和循环语句的重要组成部分。 1.1.2.4 其他原始类型
Java 的 int 型能够表示 232 个不同的值，用一个字长 32 位的机器字即可表示（虽然现在的许多 计算机有字长 64 位的机器字，但 int 型仍然是 32 位）。与此相似，double 型的标准规定为 64 位。 这些大小对于一般应用程序中使用的整数和实数已经足够了。为了提供更大的灵活性，Java 还提供 了其他五种原始数据类型：
 64 位整数，及其算术运算符 (long)；  16 位整数，及其算术运算符 (short)；  16 位字符，及其算术运算符 (char)；  8 位整数，及其算术运算符 (byte)；  32 位单精度实数，及其算术运算符 (float)。

8 第 1 章　基　　础

13

在本书中我们大多使用 int 和 double 进行算术运算，因此我们在此不会再详细讨论其他类似

的数据类型。

1.1.3 语句

Java 程序是由语句组成的。语句能够通过创建和操作变量、对变量赋值并控制这些操作的执行 流程来描述运算。语句通常会被组织成代码段，即花括号中的一系列语句。
 声明语句：创建某种类型的变量并用标识符为其命名。  赋值语句：将（由表达式产生的）某种类型的数值赋予一个变量。Java 还有一些隐式赋值的
语法可以使某个变量的值相对于当前值发生变化，例如将一个整型值加 1。  条件语句：能够简单地改变执行流程——根据指定的条件执行两个代码段之一。  循环语句：更彻底地改变执行流程——只要条件为真就不断地反复执行代码段中的语句。  调用和返回语句：和静态方法有关（见 1.1.6 节），是改变执行流程和代码组织的另一种方式。 程序就是由一系列声明、赋值、条件、循环、调用和返回语句组成的。一般来说代码的结构都 是嵌套的：一个条件语句或循环语句的代码段中也能包含条件语句或是循环语句。例如，rank() 中的 while 循环就包含一个 if 语句。接下来，我们逐个说明各种类型的语句。 1.1.3.1 声明语句 声明语句将一个变量名和一个类型在编译时关联起来。Java 需要我们用声明语句指定变量的名 称和类型。这样，我们就清楚地指明了能够对其进行的操作。Java 是一种强类型的语言，因为 Java 编译器会检查类型的一致性（例如，它不会允许将布尔类型和浮点类型的变量相乘）。变量可以声 明在第一次使用之前的任何地方——一般我们都在首次使用该变量的时候声明它。变量的作用域就 是定义它的地方，一般由相同代码段中声明之后的所有语句组成。 1.1.3.2 赋值语句 赋值语句将（由一个表达式定义的）某个数据类型的值和一个变量关联起来。在 Java 中，当我 们写下 c=a+b 时，我们表达的不是数学等式，而是一个操作，即令变量 c 的值等于变量 a 的值与变 量 b 的值之和。当然，在赋值语句执行后，从数学上来说 c 的值必然会等于 a+b，但语句的目的是 改变 c 的值（如果需要的话）。赋值语句的左侧必须是单个变量，右侧可以是能够得到相应类型的 14 值的任意表达式。 1.1.3.3 条件语句 大多数运算都需要用不同的操作来处理不同的输入。在 Java 中表达这种差异的一种方法是 if 语句：

if (<boolean expression>) { <block statements> }
这种描述方式是一种叫做模板的形式记法，我们偶尔会使用这种格式来表示 Java 的语法。尖括号 （<>）中的是我们已经定义过的语法，这表示我们可以在指定的位置使用该语法的任意实例。在这 里，<boolean expression> 表示一个布尔表达式，例如一个比较操作。<block statements> 表 示一段 Java 语句。我们也可以给出 <boolean expression> 和 <block statements> 的形式定义， 不过我们不想深入这些细节。if 语句的意义不言自明：当且仅当布尔表达式的值为真 (true) 时代 码段中的语句才会被执行。以下 if-else 语句能够在两个代码段之间作出选择：

if (<boolean expression>) { <block statements> }

else

{ <block statements> }

1.1　基础编程模型 9

1.1.3.4 循环语句 许多运算都需要重复。Java 语言中处理这种计算的基本语句的格式是：

while (<boolean expression>) { <block statements> }

while 语句和 if 语句的形式相似（只是用 while 代替了 if），但意义大有不同。当布尔表达式的

值为假（false）时，代码什么也不做；当布尔表达式的值为真（true）时，执行代码段（和 if 一样），

然后再次检查布尔表达式的值，如果仍然为真，再次执行代码段。如此这般，只要布尔表达式的值

为真，就继续执行代码段。我们将循环语句中的代码段称为循环体。

1.1.3.5 break 与 continue 语句

有些情况下我们也会需要比基本的 if 和 while 语句更加复杂的流程控制。相应地，Java 支持

在 while 循环中使用另外两条语句：

 break 语句，立即从循环中退出；

 continue 语句，立即开始下一轮循环。

本书很少在代码中使用它们（许多程序员从来都不用），但在某些情况下它们的确能够大大简

化代码。

15

1.1.4 简便记法
程序有很多种写法，我们追求清晰、优雅和高效的代码。这样的代码经常会使用以下这些广为 流传的简便写法（不仅仅是 Java，许多语言都支持它们）。 1.1.4.1 声明并初始化
可以将声明语句和赋值语句结合起来，在声明（创建）一个变量的同时将它初始化。例如， int i = 1; 创建了名为 i 的变量并赋予其初始值 1。最好在接近首次使用变量的地方声明它并将 其初始化（为了限制它的作用域）。 1.1.4.2 隐式赋值
当希望一个变量的值相对于其当前值变化时，可以使用一些简便的写法。  递 增 / 递 减 运 算 符，++i; 等 价 于 i=i+1; 且 表 达 式 为 i+1;。 类 似 地，--i; 等 价 于 i=i-
1;。i++; 和 i--; 的意思分别与上述的 ++i; 和 --i; 相同。  其他复合运算符，在赋值语句中将一个二元运算符写在等号之前，等价于将左边的变量放在
等号右边并作为第一个操作数。例如，i/=2; 等价于 i=i/2;。注意，i += 1; 等价于 i = i + 1;（以及 ++i;）。 1.1.4.3 单语句代码段 如果条件或循环语句的代码段只有一条语句，代码段的花括号可以省略。 1.1.4.4 for 语句 很多循环的模式都是这样的：初始化一个索引变量，然后使用 while 循环并将包含索引变量的 表达式作为循环的条件，while 循环的最后一条语句会将索引变量加 1。使用 Java 的 for 语句可以 更紧凑地表达这种循环：
for (<initialize>; <boolean expression>; <increment>) {
<block statements> }
除了几种特殊情况之外，这段代码都等价于：

10 第 1 章　基　　础

<initialize>; while (<boolean expression>) {
<block statements> <increment>; }

16

我们将使用 for 语句来表示对这种初始化—递增循环用法的支持。

表 1.1.3 总结了各种 Java 语句及其示例与定义。

表 1.1.3 Java 语句

语　　句

示　　例

定　　义

声明语句

int i; double c;

创建一个指定类型的变量并用标识符 命名

赋值语句

a = b + 3; discriminant = b * b - 4.0 * c;

将某一数据类型的值赋予一个变量

声明并初始化

int i = 1; double c = 3.14159265;

在声明时赋予变量初始值

隐式赋值

++i; i += 1;

i = i + 1;

条件语句（if）

if (x < 0) x = -x;

根据布尔表达式的值执行一条语句

条件语句（if-else） if (x > y) max = x;

else

max = y;

根据布尔表达式的值执行两条语句中 的一条

循环语句（while）

int v = 0; while(v <= N)
v = 2 * v; double t = c; while (Math.abs(t - c/t) > 1e-15*t)
t = (c/t + t) / 2.0;

执行语句，直至布尔表达式的值变为 假（false）

循环语句（for）

for (int i = 1; i <= N; i++) sum += 1.0/i;
for (int i = 0; i <= N; i++) StdOut.println(2*Math.PI*i/N);

while 语句的简化版

调用语句

int key = StdIn.readInt();

调用另一方法（请见 1.1.6.2 节）

17

返回语句

return false;

从方法中返回（请见 1.1.6.3 节）

1.1.5 数组
数组能够顺序存储相同类型的多个数据。除了存储数据，我们也希望能够访问数据。访问数组 中的某个元素的方法是将其编号然后索引。如果我们有 N 个值，它们的编号则为 0 至 N-1。这样 对于 0 到 N-1 之间任意的 i，我们就能够在 Java 代码中用 a[i] 唯一地表示第 i+1 个元素的值。在 Java 中这种数组被称为一维数组。 1.1.5.1 创建并初始化数组
在 Java 程序中创建一个数组需要三步：  声明数组的名字和类型；  创建数组；  初始化数组元素。 在声明数组时，需要指定数组的名称和它含有的数据的类型。在创建数组时，需要指定数组的 长度（元素的个数）。例如，在以下代码中，“完整模式”部分创建了一个有 N 个元素的 double 数组，

1.1　基础编程模型 11

所有的元素的初始值都是 0.0。第一条语句是数组的 声明，它和声明一个相应类型的原始数据类型变量 十分相似，只有类型名之后的方括号说明我们声明 的是一个数组。第二条语句中的关键字 new 使 Java 创建了这个数组。我们需要在运行时明确地创建数 组的原因是 Java 编译器在编译时无法知道应该为数 组预留多少空间（对于原始类型则可以）。for 语

完整模式

声明数组

double[] a;

创建数组

a = new double[N];

for (int i = 0; i < N; i++)

a[i] = 0.0;

简化写法

初始化数组

double[] a = new double[N];

句初始化了数组的 N 个元素，将它们的值置为 0.0。 声明初始化

在代码中使用数组时，一定要依次声明、创建并初

int[] a = { 1, 1, 2, 3, 5, 8 };

始化数组。忽略了其中的任何一步都是很常见的编

声明、创建并初始化一个数组

程错误。

1.1.5.2 简化写法

为了精简代码，我们常常会利用 Java 对数组默认的初始化来将三个步骤合为一条语句，即上例

中的简化写法。等号的左侧声明了数组，等号的右侧创建了数组。这种写法不需要 for 循环，因为

在一个 Java 数组中 double 类型的变量的默认初始值都是 0.0，但如果你想使用不同的初始值，那 18

么就需要使用 for 循环了。数值类型的默认初始值是 0，布尔型的默认初始值是 false。例子中的

第三种方式用花括号将一列由逗号分隔的值在编译时将数组初始化。

1.1.5.3 使用数组

典型的数组处理代码请见表 1.1.4。在声明并创建数组之后，在代码的任何地方都能通过数组

名之后的方括号中的索引来访问其中的元素。数组一经创建，它的大小就是固定的。程序能够通过

a.length 获取数组 a[] 的长度，而它的最后一个元素总是 a[a.length – 1]。Java 会自动进行边

界检查——如果你创建了一个大小为 N 的数组，但使用了一个小于 0 或者大于 N-1 的索引访问它，

程序会因为运行时抛出 ArrayIndexOutOfBoundsException 异常而终止。

表 1.1.4 典型的数组处理代码

任　　务 找出数组中最大的元素 计算数组元素的平均值
复制数组 颠倒数组元素的顺序

实现（代码片段）
double max = a[0]; for (int i = 1; i < a.length; i++)
if (a[i] > max) max = a[i];
int N = a.length; double sum = 0.0; for (int i = 0; i < N; i++)
sum += a[i]; double average = sum / N;
int N = a.length; double[] b = new double[N]; for (int i = 0; i < N; i++)
b[i] = a[i];
int N = a.length; for (int i = 0; i < N/2; i++) {
double temp = a[i]; a[i] = a[N-1-i]; a[N-i-1] = temp; }

12 第 1 章　基　　础

任　　务
矩阵相乘（方阵） a[][] * b[][] = c[][]

实现（代码片段）
int N = a.length; double[][] c = new double[N][N]; for (int i = 0; i < N; i++)
for (int j = 0; j < N; j++) { // 计算行 i 和列 j 的点乘
for (int k = 0; k < N; k++) c[i][j] += a[i][k]*b[k][j];
}

（续）

1.1.5.4 起别名 请注意，数组名表示的是整个数组——如果我们将一个数组变量赋予另一个变量，那么两个变
量将会指向同一个数组。例如以下这段代码：
int[] a = new int[N]; ... a[i] = 1234; ... int[] b = a; ... b[i] = 5678; // a[i] 的值也会变成 5678
这种情况叫做起别名，有时可能会导致难以察觉的问题。如果你是想将数组复制一份，那么应该声明、 创建并初始化一个新的数组，然后将原数组中的元素值挨个复制到新数组，如表 1.1.4 的第三个例 子所示。 1.1.5.5 二维数组
在 Java 中二维数组就是一维数组的数组。二维数组可以是参差不齐的（元素数组的长度可以不 一致），但大多数情况下（根据合适的参数 M 和 N）我们都会使用 M×N，即 M 行长度为 N 的数 组的二维数组（也可以称数组含有 N 列）。在 Java 中访问二维数组也很简单。二维数组 a[][] 的 第 i 行第 j 列的元素可以写作 a[i][j]。声明二维数组需要两对方括号。创建二维数组时要在类型 名之后分别在方括号中指定行数以及列数，例如：

double[][] a = new double[M][N];

我们将这样的数组称为 M×N 的数组。我们约定，第一维是行数，第二维是列数。和一维数组一样， Java 会将数值类型的数组元素初始化为 0，将布尔型的数组元素初始化为 false。默认的初始化对 二维数组更有用，因为可以节约更多的代码。下面这段代码和刚才只用一行就完成创建和初始化的 语句是等价的：

double[][] a; a = new double[M][N]; for (int i = 0; i < M; i++)
for (int j = 0; j < N; j++) a[i][j] = 0.0;

19

在将二维数组初始化为 0 时这段代码是多余的，但是如果想要初始化为其他值，我们就需要嵌

21 套的 for 循环了。

1.1.6 静态方法
本书中的所有 Java 程序要么是数据类型的定义（详见 1.2 节），要么是一个静态方法库。在许 多语言中，静态方法被称为函数，因为它们和数学函数的性质类似。静态方法是一组在被调用时会

~

1.1　基础编程模型 13

被顺序执行的语句。修饰符 static 将这类方法和 1.2 节的实例方法区别开来。当讨论两类方法共

有的属性时我们会使用不加定语的方法一词。

1.1.6.1 静态方法

方法封装了由一系列语句所描述的运 签名 算。方法需要参数（某种数据类型的值）并

返回值类型 方法名 参数类型 参数变量

根据参数计算出某种数据类型的返回值（例

public static double sqrt ( double c )

如数学函数的结果）或者产生某种副作用（例

{

如打印一个值）。BinarySearch 中的静态函 局部 数 rank() 是前者的一个例子；main() 则是 变量

后者的一个例子。每个静态方法都是由签名 函数体 （关键字 public static 以及函数的返回值，

方法名以及一串各种类型的参数）和函数体

}

（即包含在花括号中的代码）组成的，如图

if (c < 0) return Double.NaN; double err = 1e-15;
double t = c; while (Math.abs(t - c/t) > err * t)
t = (c/t + t) / 2.0; return t;

返回语句

调用另一个方法

1.1.2 所示。静态函数的例子请见表 1.1.5。

图 1.1.2 静态方法解析

表 1.1.5 典型静态方法的实现

任　　务 计算一个整数的绝对值 计算一个浮点数的绝对值 判定一个数是否是素数
计算平方根（牛顿迭代法）
计算直角三角形的斜边 计算调和级数（请见表 1.4.5）

实　　现

public static int abs(int x)

{

if (x < 0) return -x;

else

return x;

}

public static double abs(double x)

{

if (x < 0.0) return -x;

else

return x;

}

public static boolean isPrime(int N) {
if (N < 2) return false; for (int i = 2; i*i <= N; i++)
if (N % i == 0) return false; return true; }

public static double sqrt(double c) {
if (c < 0) return Double.NaN; double err = 1e-15; double t = c; while (Math.abs(t - c/t) > err * t)
t = (c/t + t) / 2.0; return t; }

public static double hypotenuse(double a, double b) { return Math.sqrt(a*a + b*b); }

public static double H(int N) {
double sum = 0.0; for (int i = 1; i <= N; i++)
sum += 1.0 / i; return sum; }

14 第 1 章　基　　础

~

1.1.6.2 调用静态方法

调用静态方法的方法是写出方法名并在后面的括号中列出参数值，用逗号分隔。当调用是表达

式的一部分时，方法的返回值将会替代表达式中的方法调用。例如，BinarySearch 中调用 rank()

返回了一个 int 值。仅由一个方法调用和一个分号组成的语句一般用于产生副作用。例如，

BinarySearch 的 main() 函数中对系统方法 Arrays.sort() 的调用产生的副作用，是将数组中的所

有条目有序地排列。调用方法时，它的参数变量将被初始化为调用时所给出的相应表达式的值。返 22 回语句将结束静态方法并将控制权交还给调用者。如果静态方法的目的是计算某个值，返回语句应

23 该指定这个值（如果这样的静态方法在执行完所有的语句之后都没有返回语句，编译器会报错）。

1.1.6.3 方法的性质

对方法所有性质的完整描述超出了本书的范畴，但以下几点值得一提。

 方法的参数按值传递：在方法中参数变量的使用方法和局部变量相同，唯一不同的是参数变

量的初始值是由调用方提供的。方法处理的是参数的值，而非参数本身。这种方式产生的

结果是在静态方法中改变一个参数变量的值对调用者没有影响。本书中我们一般不会修改

参数变量。值传递也意味着数组参数将会是原数组的别名（见 1.1.5.4 节）——方法中使用

的参数变量能够引用调用者的数组并改变其内容（只是不能改变原数组变量本身）。例如，

Arrays.sort() 将能够改变通过参数传递的数组的内容，将其排序。

 方法名可以被重载：例如，Java 的 Math 包使用这种方法为所有的原始数值类型实现了

Math.abs()、Math.min() 和 Math.max() 函数。重载的另一种常见用法是为函数定义两个

版本，其中一个需要一个参数而另一个则为该参数提供一个默认值。

 方法只能返回一个值，但可以包含多个返回语句：一个 Java 方法只能返回一个值，它的类

型是方法签名中声明的类型。静态方法第一次执行到一条返回语句时控制权将会回到调用代

码中。尽管可能存在多条返回语句，任何静态方法每次都只会返回一个值，即被执行的第一

条返回语句的参数。

 方法可以产生副作用：方法的返回值可以是 void，这表示该方法没有返回值。返回值为

void 的静态函数不需要明确的返回语句，方法的最后一条语句执行完毕后控制权将会返回

给调用方。我们称 void 类型的静态方法会产生副作用（接受输入、产生输出、修改数组或

者改变系统状态）。例如，我们的程序中的静态方法 main() 的返回值就是 void，因为它

24

的作用是向外输出。技术上来说，数学方法的返回值都不会是 void（Math.random() 虽然

不接受参数但也有返回值）。

2.1 节所述的实例方法也拥有这些性质，尽管两者在副作用方面大为不同。

1.1.6.4 递归

方法可以调用自己（如果你对递归概念感到奇怪，请完成练习 1.1.16 到练习 1.1.22）。例如，

下面给出了 BinarySearch 的 rank() 方法的另一种实现。我们会经常使用递归，因为递归代码比

相应的非递归代码更加简洁优雅、易懂。下面这种实现中的注释就言简意赅地说明了代码的作用。

我们可以用数学归纳法证明这段注释所解释的算法的正确性。我们会在 3.1 节中展开这个话题并为

二分查找提供一个这样的证明。

编写递归代码时最重要的有以下三点。

 递归总有一个最简单的情况——方法的第一条语句总是一个包含 return 的条件语句。

 递归调用总是去尝试解决一个规模更小的子问题，这样递归才能收敛到最简单的情况。在下

面的代码中，第四个参数和第三个参数的差值一直在缩小。

1.1　基础编程模型 15

 递归调用的父问题和尝试解决的子问题之间不应该有交集。在下面的代码中，两个子问题各 自操作的数组部分是不同的。

public static int rank(int key, int[] a) { return rank(key, a, 0, a.length - 1); }

public static int rank(int key, int[] a, int lo, int hi) { //如果key存在于a[]中，它的索引不会小于lo且不会大于hi

if (lo > hi) return -1;

int mid = lo + (hi - lo) / 2;

if

(key < a[mid]) return rank(key, a, lo, mid - 1);

else if (key > a[mid]) return rank(key, a, mid + 1, hi);

else

return mid;

}

二分查找的递归实现

25

违背其中任意一条都可能得到错误的结果或是低效的代码（见练习 1.1.19 和练习 1.1.27），而 坚持这些原则能写出清晰、正确且容易评估性能的程序。使用递归的另一个原因是我们可以使用数 学模型来估计程序的性能。我们会在 3.2 节的二分查找以及其他几个地方分析这个问题。 1.1.6.5 基础编程模型
静态方法库是定义在一个 Java 类中的一组静态方法。类的声明是 public class 加上类名，以 及用花括号包含的静态方法。存放类的文件的文件名和类名相同，扩展名是 .java。Java 开发的基本 模式是编写一个静态方法库（包含一个 main() 方法）来完成一个任务。输入 java 和类名以及一系 列字符串就能调用类中的 main() 方法，其参数为由输入的字符串组成的一个数组。main() 的最后 一条语句执行完毕之后程序终止。在本书中，当我们提到用于执行一项任务的 Java 程序时，我们指 的是用这种模式开发的代码（可能还包括对数据类型的定义，如 1.2 节所示）。例如，BinarySearch 就是一个由两个静态方法 rank() 和 main() 组成的 Java 程序，它的作用是将输入中所有不在通过 命令行指定的白名单中的数字打印出来。 1.1.6.6 模块化编程
这个模型的最重要之处在于通过静态方法库实现了模块化编程。我们可以构造许多个静态方法 库（模块），一个库中的静态方法也能够调用另一个库中定义的静态方法。这能够带来许多好处：
 程序整体的代码量很大时，每次处理的模块大小仍然适中；  可以共享和重用代码而无需重新实现；  很容易用改进的实现替换老的实现；  可以为解决编程问题建立合适的抽象模型；  缩小调试范围（请见 1.1.6.7 节关于单元测试的讨论）。 例如，BinarySearch 用到了三个独立的库，即我们的 StdOut 和 StdIn 以及 Java 的 Arrays，而这 三个库又分别用到了其他的库。 1.1.6.7 单元测试 Java 编程的最佳实践之一就是每个静态方法库中都包含一个 main() 函数来测试库中的所有方 法（有些编程语言不支持多个 main() 方法，因此不支持这种方式）。恰当的单元测试本身也是很 有挑战性的编程任务。每个模块的 main() 方法至少应该调用模块中的其他代码并在某种程度上保

16 第 1 章　基　　础

证它的正确性。随着模块的成熟，我们可以将 main() 方法作为一个开发用例，在开发过程中用它

来测试更多的细节；也可以把它编成一个测试用例来对所有代码进行全面的测试。当用例越来越复

杂时，我们可能会将它独立成一个模块。在本书中，我们用 main() 来说明模块的功能并将测试用

26 例留做练习。

1.1.6.8 外部库

我们会使用来自 4 个不同类型的库中的静态方法，重用每种库代码的方式都稍有不同。它们大

多都是静态方法库，但也有部分是数据类型的定义并包含了一些静态方法。

 系统标准库 java.lang.*：这其中包括 Math 库，实现了常用的数学函数；Integer 和 Double 库，

能够将字符串转化为 int 和 double 值；String 和 StringBuilder 库，我们稍后会在本节和第

5 章中详细讨论；以及其他一些我们没有用到的库。

 导入的系统库，例如 java.util.Arrays：每个标准的 Java 版本中都含有上千个这种类型的库，

不过本书中我们用到的并不多。要在程序的开头使用 import 语句导入才能使用这些库（我

们也是这样做的）。

 本书中的其他库：例如，其他程序也可以使用 BinarySearch 的 rank() 方法。要使用这些库，

请在本书的网站上下载它们的源代码并放入你的工作目录中。

 我们为本书（以及我们的另一本入门教材 An Introduction to Programming in Java: An Interdisciplinary Approach）开 发的标准库 Std*：我们会在下面简要地介绍这些库，它 们的源代码和使用方法都能够在本书的网站上找到。
要调用另一个库中的方法（存放在相同或者指定的目录中， 或是一个系统标准库，或是在类定义前用 import 语句导入的库）， 我 们 需 要 在 方 法 前 指 定 库 的 名 称。 例 如，BinarySearch 的 main() 方法调用了系统库 java.util.Arrays 的 sort() 方法，我 们的库 In 中的 readInts() 方法和 StdOut 库中的 println() 方法。
我们自己及他人使用模块化方式编写的方法库能够极大地扩 展我们的编程模型。除了在 Java 的标准版本中可用的所有库之外， 网上还有成千上万各种用途的代码库。为了将我们的编程模型限

系统标准库 Math Integer† Double† String† StringBuilder System
导入的系统库 java.util.Arrays
我们的标准库 StdIn StdOut StdDraw StdRandom StdStats In† Out†
† 含有静态方法的数据类型的定义

27 制在一个可控范围之内，以将精力集中在算法上，我们只会使用 本书使用的含有静态方法的库

以下所示的方法库，并在 1.1.7 节中列出了其中的部分方法。

1.1.7 API
模块化编程的一个重要组成部分就是记录库方法的用法并供其他人参考的文档。我们会统一使 用应用程序编程接口（API）的方式列出本书中使用的每个库方法名称、签名和简短的描述。我们 用用例来指代调用另一个库中的方法的程序，用实现描述实现了某个 API 方法的 Java 代码。 1.1.7.1 举例
在表 1.1.6 的例子中，我们用 java.lang 中 Math 库常用的静态方法说明 API 的文档格式。 这些方法实现了各种数学函数——它们通过参数计算得到某种类型的值（random() 除外，它 没有对应的数学函数，因为它不接受参数）。它们的参数都是 double 类型且返回值也都是 double 类型，因此可以将它们看做 double 数据类型的扩展——这种扩展的能力正是现代编程语言的特性

1.1　基础编程模型 17

之一。API 中的每一行描述了一个方法，提供了使用该方法所需要知道的所有信息。Math 库也定义 了常数 PI（圆周率 π）和 E（自然对数 e），你可以在自己的程序中通过这些变量名引用它们。例如， Math.sin(Math.PI/2) 的结果是 1.0，Math.log(Math.E) 的结果也是 1.0（因为 Math.sin() 的 参数是弧度而 Math.log() 使用的是自然对数函数）。

表 1.1.6 Java 的数学函数库的 API（节选）

public class Math

static double abs(double a)

a 的绝对值

static double max(double a, double b)

a 和 b 中的较大者

static double min(double a, double b)

a 和 b 中的较小者

注 1：abs()、max() 和 min() 也定义了 int、long 和 float 的版本。

static double sin(double theta)

正弦函数

static double cos(double theta)

余弦函数

static double tan(double theta)

正切函数

注 2：角用弧度表示，可以使用 toDegrees() 和 toRadians() 转换角度和弧度。 注 3：它们的反函数分别为 asin()、acos() 和 atan()。

static double exp(double a)

指数函数（ea）

static double log(double a) static double pow(double a, double b)

自然对数函数（logea，即 ln a） 求 a 的 b 次方（ab）

static double random()

[0, 1) 之间的随机数

static double sqrt(double a)

a 的平方根

static double E

常数 e（常数）

static double PI

常数 π（常数）

28

其他函数请见本书的网站。

1.1.7.2 Java 库 成千上万个库的在线文档是 Java 发布版本的一部分。为了更好地描述我们的编程模型，我们只
是从中节选了本书所用到的若干方法。例如，BinarySearch 中用到了 Java 的 Arrays 库中的 sort() 方法，我们对它的记录如表 1.1.7 所示。

表 1.1.7 Java 的 Arrays 库节选（java.util.Arrays）

public class Arrays static void sort(int[] a)

将数组按升序排序

注：其他原始类型和 Object 对象也有对应版本的方法。

Arrays 库不在 java.lang 中，因此我们需要用 import 语句导入后才能使用它，与 BinarySearch

中一样。事实上，本书的第 2 章讲的正是数组的各种 sort() 方法的实现，包括 Arrays.sort() 中

实现的归并排序和快速排序算法。Java 和很多其他编程语言都实现了本书讲解的许多基础算法。例

如，Arrays 库还包含了二分查找的实现。为避免混淆，我们一般会使用自己的实现，但对于你已经

掌握的算法使用高度优化的库实现当然也没有任何问题。

29

1.1.7.3 我们的标准库

为了介绍 Java 编程、为了科学计算以及算法的开发、学习和应用，我们也开发了若干库来提供

一些实用的功能。这些库大多用于处理输入输出。我们也会使用以下两个库来测试和分析我们的实

18 第 1 章　基　　础

现。第一个库扩展了 Math.random() 方法（见表 1.1.8），以根据不同的概率密度函数得到随机值； 第二个库则支持各种统计计算（见表 1.1.9）。

表 1.1.8 我们的随机数静态方法库的 API

public class StdRandom

static void setSeed(long seed)

static double random()

static

int uniform(int N)

static

int uniform(int lo, int hi)

static double uniform(double lo, double hi)

static boolean bernoulli(double p)

static double gaussian()

static double gaussian(double m, double s)

static

int discrete(double[] a)

static void shuffle(double[] a)

设置随机生成器的种子 0 到 1 之间的实数 0 到 N-1 之间的整数 lo 到 hi-1 之间的整数 lo 到 hi 之间的实数 返回真的概率为 p 正态分布，期望值为 0，标准差为 1 正态分布，期望值为 m，标准差为 s 返回 i 的概率为 a[i] 将数组 a 随机排序

注：库中也包含为其他原始类型和 Object 对象重载的 shuffle() 函数。

表 1.1.9 我们的数据分析静态方法库的 API

public class StdStats

static double max(double[] a)

static double min(double[] a)

static double mean(double[] a)

static double var(double[] a)

static double stddev(double[] a)

30

static double median(double[] a)

最大值 最小值 平均值 采样方差 采样标准差 中位数

　　StdRandom 的 setSeed() 方法为随机数生成器提供种子，这样我们就可以重复和随机数有关 的实验。以上一些方法的实现请参考表 1.1.10。有些方法的实现非常简单，为什么还要在方法库中 实现它们？设计良好的方法库对这个问题的标准回答如下。
 这些方法所实现的抽象层有助于我们将精力集中在实现和测试本书中的算法，而非生成随机 数或是统计计算。每次都自己写完成相同计算的代码，不如直接在用例中调用它们要更简洁 易懂。
 方法库会经过大量测试，覆盖极端和罕见的情况，是我们可以信任的。这样的实现需要大量 的代码。例如，我们经常需要使用的各种数据类型的实现，又比如 Java 的 Arrays 库针对不 同数据类型对 sort() 进行了多次重载。
这些是 Java 模块化编程的基础，不过在这里可能有些夸张。但这些方法库的方法名称简单、实现容易， 其中一些仍然能作为有趣的算法练习。因此，我们建议你到本书的网站上去学习一下 StdRandom. java 和 StdStats.java 的源代码并好好利用这些经过验证了的实现。使用这些库（以及检验它们）最 简单的方法就是从网站上下载它们的源代码并放入你的工作目录。网站上讲解了在各种系统上使用 它们的配置目录的方法。

1.1　基础编程模型 19

表 1.1.10 StdRandom 库中的静态方法的实现

期望的结果

实现

随机返回 [a,b) 之间的一个 double 值

public static double uniform(double a, double b) { return a + StdRandom.random() * (b-a); }

随机返回 [0..N) 之间的一个 int 值

public static int uniform(int N) { return (int) (StdRandom.random() * N); }

随机返回 [lo,hi) 之间的一个 int 值

public static int uniform(int lo, int hi) { return lo + StdRandom.uniform(hi - lo); }

根据离散概率随机返回的 int 值（出现 i 的概率为 a[i]）

public static int discrete(double[] a) { // a[] 中各元素之和必须等于 1
double r = StdRandom.random(); double sum = 0.0; for (int i = 0; i < a.length; i++) {
sum = sum + a[i]; if (sum >= r) return i; } return -1; }

随机将 double 数组中的元素排序（请见 练习 1.1.36）

public static void shuffle(double[] a) {
int N = a.length; for (int i = 0; i < N; i++) { // 将 a[i] 和 a[i..N-1] 中任意一个元素交换
int r = i + StdRandom.uniform(N-i); double temp = a[i]; a[i] = a[r]; a[r] = temp; } }

1.1.7.4 你自己编写的库

你应该将自己编写的每一个程序都当做一个日后可以重用的库。

 编写用例，在实现中将计算过程分解成可控的部分。

 明确静态方法库和与之对应的 API（或者多个库的多个 API）。

 实现 API 和一个能够对方法进行独立测试的 main() 函数。

这种方法不仅能帮助你实现可重用的代码，而且能够教会你如何运用模块化编程来解决一个复 31

~

杂的问题。

32

API 的目的是将调用和实现分离：除了 API 中给出的信息，调用者不需要知道实现的其他细节，

而实现也不应考虑特殊的应用场景。API 使我们能够广泛地重用那些为各种目的独立开发的代码。

没有任何一个 Java 库能够包含我们在程序中可能用到的所有方法，因此这种能力对于编写复杂的应

用程序特别重要。相应地，程序员也可以将 API 看做调用和实现之间的一份契约，它详细说明了每

个方法的作用。实现的目标就是能够遵守这份契约。一般来说，做到这一点有很多种方法，而且将

调用者的代码和实现的代码分离使我们可以将老算法替换为更新更好的实现。在学习算法的过程中，

这也使我们能够感受到算法的改进所带来的影响。

33

20 第 1 章　基　　础

1.1.8 字符串
字符串是由一串字符（char 类型的值）组成的。一个 String 类型的字面量包括一对双引号和 其中的字符，比如 "Hello, World"。String 类型是 Java 的一个数据类型，但并不是原始数据类型。 我们现在就讨论 String 类型是因为它非常基础，几乎所有 Java 程序都会用到它。 1.1.8.1 字符串拼接
和各种原始数据类型一样，Java 内置了一个串联 String 类型字符串的运算符（+）。表 1.1.11 是对表 1.1.2 的补充。拼接两个 String 类型的字符串将得到一个新的 String 值，其中第一个字符 串在前，第二个字符串在后。

类　　型 String

值　　域 一串字符

表 1.1.11 Java 的 String 数据类型

举　　例
"AB" "Hello" "2.5"

运　算　符 +（拼接）

表达式举例

表　达　式

值

"Hi," + "Bob" "12" + "34" "1" + "+" + "2"

"Hi, Bob" "1234" "1+2"

1.1.8.2 类型转换 字符串的两个主要用途分别是将用户从键盘输入的内容转换成相应数据类型的值以及将各种数
据类型的值转化成能够在屏幕上显示的内容。Java 的 String 类型为这些操作内置了相应的方法， 而且 Integer 和 Double 库还包含了分别和 String 类型相互转化的静态方法（见表 1.1.12）。

表 1.1.12 String 值和数字之间相互转换的 API

public class Integer

static int parseInt(String s) static String toString(int i) public class Double

将字符串 s 转换为整数 将整数 i 转换为字符串

static double parseDouble(String s)

将字符串 s 转换为浮点数

34

static String toString(double x)

将浮点数 x 转换为字符串

1.1.8.3 自动转换 我们很少明确使用刚才提到的 toString() 方法，因为 Java 在连接字符串的时候会自动将任
意数据类型的值转换为字符串：如果加号（+）的一个参数是字符串，那么 Java 会自动将其他参 数都转换为字符串（如果它们不是的话）。除了像 "The square root of 2.0 is " + Math. sqrt(2.0) 这样的使用方式之外，这种机制也使我们能够通过一个空字符串 "" 将任意数据类型的 值转换为字符串值。 1.1.8.4 命令行参数
在 Java 中字符串的一个重要的用途就是使程序能够接收到从命令行传递来的信息。这种机制很 简单。当你输入命令 java 和一个库名以及一系列字符串之后，Java 系统会调用库的 main() 方法 并将那一系列字符串变成一个数组作为参数传递给它。例如，BinarySearch 的 main() 方法需要一 个命令行参数，因此系统会创建一个大小为 1 的数组。程序用这个值，也就是 args[0]，来获取白

1.1　基础编程模型 21

名单文件的文件名并将其作为 StdIn.readInts() 的参数。另一种在我们的代码中常见的用法是当

命令行参数表示的是数字时，我们会用 parseInt() 和 parseDouble() 方法将其分别转换为整数

和浮点数。

字符串的用法是现代程序中的重要部分。现在我们还只是用 String 在外部表示为字符串的数

字和内部表示为数字类数据类型的值进行转换。在 1.2 节中我们会看到 Java 为我们提供了非常丰富

的字符串操作；在 1.4 节中我们会分析 String 类型在 Java 内部的表示方法；在第 5 章我们会深入

学习处理字符串的各种算法。这些算法是本书中最有趣、最复杂也是影响力最大的一部分算法。

35

1.1.9 输入输出

我们的标准输入、输出和绘图库的作用是建立一个 Java 程序和外界交流的简易模型。这些库的

基础是强大的 Java 标准库，但它们一般更加复杂，学习和使用起来都更加困难。我们先来简单地了

解一下这个模型。

在我们的模型中，Java 程序可以从命令行参数或者一个名为标准输入流的抽象字符流中获得输

入，并将输出写入另一个名为标准输出流的字符流中。

我们需要考虑 Java 和操作系统之间的接口，因此我 们要简要地讨论一下大多数操作系统和程序开发环境所

标准输入

命令行参数

提供的相应机制。本书网站上列出了关于你所使用的系

统的更多信息。默认情况下，命令行参数、标准输入和

标准输出是和应用程序绑定的，而应用程序是由能够接 受命令输入的操作系统或是开发环境所支持。我们笼统

标准输出

地用终端来指代这个应用程序提供的供输入和显示的窗

口。20 世纪 70 年代早期的 Unix 系统已经证明我们可以 用这个模型方便直接地和程序以及数据进行交互。我们 在经典的模型中加入了一个标准绘图模块用来可视化表 示对数据的分析，如图 1.1.3 所示。

文件I/O

标准绘图

图 1.1.3 Java 程序整体结构

1.1.9.1 命令和参数

终端窗口包含一个提示符，通过它我们能够向操作系统输入命令和参数。本书中我们只会用到

几个命令，如表 1.1.13 所示。我们会经常使用 java 命令来运行我们的程序。我们在 1.1.8.4 节中提到过，

Java 类都会包含一个静态方法 main()，它有一个 String 数组类型的参数 args[]。这个数组的内

容就是我们输入的命令行参数，操作系统会将它传递给 Java。Java 和操作系统都默认参数为字符串。

如果我们需要的某个参数是数字，我们会使用类似 Integer.parseInt() 的方法将其转换为适当的

数据类型的值。图 1.1.4 是对命令的分析。

命　　令 javac java
more

表 1.1.13 操作系统常用命令

参　　数

作　　用

.java 文件名

编译 Java 程序

.class 文件名（不需要扩展名） 和命令行参数

运行 Java 程序

任意文本文件名

打印文件内容

36

22 第 1 章　基　　础

1.1.9.2 标准输出 我们的 StdOut 库的作用是支持标准输出。一般
来说，系统会将标准输出打印到终端窗口。print() 方法会将它的参数放到标准输出中；println() 方法 会附加一个换行符；printf() 方法能够格式化输出 （见 1.1.9.3 节）。Java 在其 System.out 库中提供了类 似的方法，但我们会用 StdOut 库来统一处理标准输 入和输出（并进行了一些技术上的改进），见表 1.1.14。

提示符

调用RandomSeq中 的静态方法main()

% java RandomSeq 5 100.0 200.0

调用Java

args[0]
args[1] args[2]

图 1.1.4 命令详解

表 1.1.14 我们的标准输出库的静态方法的 API

public class StdOut static void print(String s) static void println(String s) static void println() static void printf(String f, ...)

打印 s 打印 s 并接一个换行符 打印一个换行符 格式化输出

注：其他原始类型和 Object 对象也有对应版本的方法。

要使用这些方法，请从本书的网站上将 StdOut.java 下载到你的工作目录，并像 StdOut.println

("Hello, World"); 这样在代码中调用它们。左下方的程序就是一个例子。

1.1.9.3 格式化输出

在最简单的情况下 printf() 方法接受两个参数。第一个参数是一个格式字符串，描述了第二

个参数应该如何在输出中被转换为一个字符串。最简单的格式字符串的第一个字符是 % 并紧跟一个

字符表示的转换代码。我们最常使用的转换代码包括 d（用于 Java 整型的十进制数）、f（浮点型）

public class RandomSeq {
public static void main(String[] args) { // 打印N个(lo, hi)之间的随机值
int N = Integer.parseInt(args[0]); double lo = Double.parseDouble(args[1]); double hi = Double.parseDouble(args[2]); for (int i = 0; i < N; i++) {
double x = StdRandom.uniform(lo, hi); StdOut.printf("%.2f\n", x); } } }
StdOut 的用例示例

和 s（字符串）。在 % 和转换代码之 间可以插入一个整数来表示转换之后 的值的宽度，即输出字符串的长度。 默认情况下，转换后会在字符串的左 边添加空格以达到需要的宽度，如果 我们想在右边加入空格则应该使用负 宽度（如果转换得到的字符串比设定 宽度要长，宽度会被忽略）。在宽度 之后我们还可以插入一个小数点以 及一个数值来指定转换后的 double 值 保 留 的 小 数 位 数（ 精 度 ） 或 是 String 字符串所截取的长度。使用

% java RandomSeq 5 100.0 200.0 123.43 153.13 144.38 155.18 104.02
37

printf() 方法时需要记住的最重要的一点就是，格式 字符串中的转换代码和对应参数的数据类型必须匹配。 也就是说，Java 要求参数的数据类型和转换代码表示 的数据类型必须相同。printf() 的第一个 String 字 符串参数也可以包含其他字符。所有非格式字符串的

1.1　基础编程模型 23

字符都会被传递到输出之中，而格式字符串则会被参数的值所替代（按照指定的方式转换为字符串）。 例如，这条语句：
StdOut.printf("PI is approximately %.2f\n", Math.PI);
会打印出：
PI is approximately 3.14
可以看到，在 printf() 中我们需要明确地在第一个参数的末尾加上 \n 来换行。printf() 函数 能够接受两个或者更多的参数。在这种情况下，在格式化字符串中每个参数都会有对应的转换代 码，这些代码之间可能隔着其他会被直接传递到输出中的字符。也可以直接使用静态方法 String. format() 来用和 printf() 相同的参数得到一个格式化字符串而无需打印它。我们可以用格式化 打印方便地将实验数据输出为表格形式（这是它们在本书中的主要用途），如表 1.1.15 所示。

表 1.1.15 printf() 的格式化方式（更多选项请见本书网站）

数据类型 转换代码

举　　例

格式化字符串举例

转换后输出的字符串

int

d

512

"%14d" "%-14d"

" "512

512" "

double

f e

1595.1680010754388

"%14.2f" "%.7f" "%14.4e"

"

1595.17"

"1 5 9 5 . 1 6 8 0 0 1 1 "

"

1.5952e+03"

String

s

"Hello, World"

"%14s" "%-14s" "%-14.5s"

" Hello, World"

"Hello, World "

"Hello

"

38

1.1.9.4 标准输入

我 们 的 StdIn 库 从 标 准 输 入 流中获取数据，这些数据可能为 空也可能是一系列由空白字符分 隔 的 值（ 空 格、 制 表 符、 换 行 符 等）。默认状态下系统会将标准 输出定向到终端窗口——你输入 的内容就是输入流（由 <ctrl-d> 或 <ctrl-z> 结 束， 取 决 于 你 使 用的终端应用程序）。这些值可 能 是 String 或 是 Java 的 某 种 原 始类型的数据。标准输入流最重

public class Average {
public static void main(String[] args) { // 取StdIn中所有数的平均值
double sum = 0.0; int cnt = 0; while (!StdIn.isEmpty()) { // 读取一个数并计算累计之和
sum += StdIn.readDouble(); cnt++; } double avg = sum / cnt; StdOut.printf("Average is %.5f\n", avg); } }

要的特点是这些值会在你的程序 读取它们之后消失。只要程序读

StdIn 的用例举例

取了一个值，它就不能回退并再次读取它。这个特点产生了一些 限制，但它反映了一些输入设备的物理特性并简化了对这些设备 的抽象。有了输入流模型，这个库中的静态方法大都是自文档化 的（它们的签名即说明了它们的用途）。右侧列出了 StdIn 的一 个用例。
表 1.1.16 详细说明了标准输入库中的静态方法的 API。

% java Average 1.23456 2.34567 3.45678 4.56789 <ctrl-d> Average is 2.90123

24 第 1 章　基　　础

表 1.1.16 标准输入库中的静态方法的 API

Public class StdIn

static boolean isEmpty()

static

int readInt()

static double readDouble()

static float readFloat()

static long readLong()

static boolean readBoolean()

static char readChar()

static byte readByte()

static String readString()

static boolean hasNextLine()

static String readLine()

39

static String readAll()

如果输入流中没有剩余的值则返回 true，否则返回 false 读取一个 int 类型的值 读取一个 double 类型的值 读取一个 float 类型的值 读取一个 long 类型的值 读取一个 boolean 类型的值 读取一个 char 类型的值 读取一个 byte 类型的值 读取一个 String 类型的值 输入流中是否还有下一行 读取该行的其余内容 读取输入流中的其余内容

1.1.9.5 重定向与管道 标准输入输出使我们能够利用许多操作系统都支持的命令行的扩展功能。只需要向启动程序的
命令中加入一个简单的提示符，就可以将它的标准输出重定向至一个文件。文件的内容既可以永久 保存也可以在之后作为另一个程序的输入：

% java RandomSeq 1000 100.0 200.0 > data.txt
这条命令指明标准输出流不是被打印至终端窗口，而是被写入一个叫做 data.txt 的文件。每次 调用 StdOut.print() 或是 StdOut.println() 都会向该文件追加一段文本。在这个例子中，我们 最后会得到一个含有 1000 个随机数的文件。终端窗口中不会出现任何输出：它们都被直接写入了 “>”号之后的文件中。这样我们就能将信息存储以备下次使用。请注意不需要改变 RandomSeq 的 任何内容——它使用的是标准输出的抽象，因此它不会因为我们使用了该抽象的另一种不同的实现 而受到影响。类似，我们可以重定向标准输入以使 StdIn 从文件而不是终端应用程序中读取数据：

% java Average < data.txt
这条命令会从文件 data.txt 中读取一系列数值并计算它们的平均值。具体来说，“<”号是一个 提示符，它告诉操作系统读取文本文件 data.txt 作为输入流而不是在终端窗口中等待用户的输入。 当程序调用 StdIn.readDouble() 时，操作系统读取的是文件中的值。将这些结合起来，将一个程 序的输出重定向为另一个程序的输入叫做管道：

40

% java RandomSeq 1000 100.0 200.0 | java Average

这条命令将 RandomSeq 的标准输出和 Average 的标准输入指定为同一个流。它的效果是好像 在 Average 运行时 RandomSeq 将它生成的数字输入了终端窗口。这种差别影响非常深远，因为它突 破了我们能够处理的输入输出流的长度限制。例如，即使计算机没有足够的空间来存储十亿个数， 我们仍然可以将例子中的 1000 换成 1 000 000 000 （当然我们还是需要一些时间来处理它们）。当 RandomSeq 调用 StdOut.println() 时，它就向输出流的末尾添加了一个字符串；当 Average 调用 StdIn.readInt() 时，它就从输入流的开头删除了一个字符串。这些动作发生的实际顺序取决于 操作系统：它可能会先运行 RandomSeq 并产生一些输出，然后再运行 Average，来消耗这些输出， 或者它也可以先运行 Average，直到它需要一些输入然后再运行 RandomSeq 来产生一些输出。虽然

1.1　基础编程模型 25

最后的结果都一样，但我们的程序就不 再需要担心这些细节，因为它们只会和 标准输入和标准输出的抽象打交道。
图 1.1.5 总 结 了 重 定 向 与 管 道 的 过程。 1.1.9.6 基于文件的输入输出
我们的 In 和 Out 库提供了一些静 态方法，来实现向文件中写入或从文件 中读取一个原始数据类型（或 String 类型）的数组的抽象。我们会使用 In 库 中 的 readInts()、readDoubles() 和 readStrings() 以 及 Out 库 中 重 载 的多个 write() 方 法，name 参 数 可 以 是 文 件 或 网 页， 如 表 1.1.17 所 示。 例 如，借此我们可以在同一个程序中分别 使用文件和标准输入达到两种不同的目 的，例如 BinarySearch。In 和 Out 两个 库也实现了一些数据类型和它们的实例 方法，这使我们能够将多个文件作为输 入输出流并将网页作为输入流，我们还 会在 1.2 节中再次考察它们。

将一个文件重定向为标准输入 % java Average < data.txt
data.txt 标准输入
Average

将标准输出重定向到一个文件 % java RandomSeq 1000 100.0 200.0 > data.txt

RandomSeq 标准输出

data.txt

将一个程序的输出通过管道作为另一个程序的输入 % java RandomSeq 1000 100.0 200.0 | java Average

RandomSeq

标准输出

标准输入

Average

图 1.1.5 命令行的重定向与管道

表 1.1.17 我们用于读取和写入数组的静态方法的 API

public class In static int[] readInts(String name) static double[] readDoubles(String name) static String[] readStrings(String name)
public class Out static void write(int[] a, String name) static void write(doule[] a, String name) static void write(String[] a, String name)

读取多个 int 值 读取多个 double 值 读取多个 String 值
写入多个 int 值 写入多个 double 值 写入多个 String 值

注 1：库也支持其他原始数据类型。 注 2：库也支持 StdIn 和 StdOut（忽略 name 参数）。
41 1.1.9.7 标准绘图库（基本方法）
目前为止，我们的输入输出抽象层的重点只有文本字符串。现在我们要介绍一个产生图像输
出的抽象层。这个库的使用非常简单并且允许我们利用可视化的方式处理比文字丰富得多的信息。
和我们的标准输入输出一样，标准绘图抽象层实现在库 StdDraw 中，可以从本书的网站上下载
StdDraw.java 到你的工作目录来使用它。标准绘图库很简单：我们可以将它想象为一个抽象的能够 在二维画布上画出点和直线的绘图设备。这个设备能够根据程序调用的 StdDraw 中的静态方法画
出一些基本的几何图形，这些方法包括画出点、直线、文本字符串、圆、长方形和多边形等。和

26 第 1 章　基　　础
标准输入输出中的方法一样， 这些方法几乎也都是自文档化

StdDraw.point(x0, y0); StdDraw.line(x1, y1, x2, y2);

(x1, y1)

(1, 1) (x0, y0)

(x1, y1)

r (1, 1) (x0, y0)

(x, y)

(0, 0)

(x2, y2)

StdDraw.point(x0, y0);

StdDraw.line(x1, y1, x2, y2);

StdDraw.circle(x, y, r);

(0, 0)

(x2, y2)

SSttddDDrraaww..csiqrucalree((xx,, yy,, rr));;

的：StdDraw.line() 能 够 根 据参数的坐标画出一条连接 点 (x0, y0) 和点 (x1, y1) 的线段， StdDraw.point() 能够根据参 数坐标画出一个以 (x, y) 为中

(1, 1)

(x1, y1)

r

(x0, y0)

　

(x, y) (0, 0)

(x2, y2)

r r r
(x(x, ,yy))

心的点，等等，如图 1.1.6 所示。 几何图形可以被填充（默认为 黑色）。默认的比例尺为单位

StdDraw.circle(x, y, r); StdDraw.square(x, y, r);

SdtoduDbrlaew[.]sqxua=re{(xx0,, yx,1,r)x;2, x3}; double[] y = {y0, y1, y2, y3};
StdDraw.polygon(x, y);

正方形（所有的坐标均在 0 和

r

(x0, y0)

r

1 之间）。标准的实现会将画

r

　

r(x1, y1)

布显示为屏幕上的一个窗口，

(x, y)

r

(x, y)

点和线为黑色，背景为白色。 表 1.1.18 是对标准绘图库
中静态方法 API 的汇总。 42
表 1.1.18 标准绘图库的静态

(x, y)

(x3, y3)

(x2, y2)

StdDraw.square(x, y, r);

double[] x = {x0, x1, x2, x3};

double[] y = {y0, y1, y2, y3};

double[] x = {x0,图x11,.1x.62, Sxt3}d;DraSwtd的Dr用aw法.p举oly例gon(x, y);

double[] y = {y0, y1, y2, y3};

StdDraw.polygon(x, y);
（绘图）方法r 的 API

(x0, y0)

public class StdDraw

(x0, y0)

r

(x1, y1)

static void line(double x0, double y0, double(x1x,1y,1) double y1) (x, y)
static void point(double x, double y)

static void static void static void static void

text(double x, double y, String s)

(x3, y3)

cfiirlclleed(Cdiorucbllee(dxo,uddboodluuoebbullbx(eelx,[[3e,]]dyy3oxy),ub==dloe{{xyu00by,,(l,xe2xy,d11yro,,2)u) bxyl22e,,

x3}; ry)3};

ellipse(double xS,tddDoruabwl.epoyl,ygodno(uxb,ley)r;w, double rh)

(x2, y2)

static void static void static void

filledEllipse(double(xx0,, y0d)ouble y, double rw, double rh)
square(double x, double y, double(x1r,)y1)
filledSquare(double x, double y, double r)

static void rectangle(double x, double y, double rw, double rh)

static void static void static void

filledRectangle(double x, double y, double rw, double rh)
polygon(double[] x, d(xo3u, by3l)e[] y)(x2, y2)
filledPolygon(double[] x, double[] y)

1.1.9.8 标准绘图库（控制方法） 标准绘图库中还包含一些方法来改变画布的大小和比例、直线的颜色和宽度、文本字体、绘图
时间（用于动画）等。可以使用在 StdDraw 中预定义的 BLACK、BLUE、CYAN、DARK_GRAY、GRAY、 GREEN、LIGHT_GRAY、MAGENTA、ORANGE、PINK、RED、BOOK_RED、WHITE 和 YELLOW 等颜色常数 作为 setPenColor() 方法的参数（可以用 StdDraw.RED 这样的方式调用它们）。画布窗口的菜单 还包含一个选项用于将图像保存为适于在网上传播的文件格式。表 1.1.19 总结了 StdDraw 中静态控 制方法的 API。

1.1　基础编程模型 27

表 1.1.19 标准绘图库的静态（控制）方法的 API

public class StdDraw

static void setXscale(double x0, double x1) static void setYscale(double y0, double y1) static void setPenRadius(double r)

将 x 的范围设为 (x0, x1) 将 y 的范围设为 (y0 , y1) 将画笔的粗细半径设为 r

static void setPenColor(Color c)

将画笔的颜色设为 c

static void setFont(Font f)

将文本字体设为 f

static void setCanvasSize(int w, int h)

将画布窗口的宽和高分别设为 w 和 h

static void clear(Color c)

清空画布并用颜色 c 将其填充

static void show(int dt)

显示所有图像并暂停 dt 毫秒

43

在本书中，我们会在数据分析和算法的可视化中使用 StdDraw。表 1.1.20 是一些例子，我们在

本书的其他章节和练习中还会遇到更多的例子。绘图库也支持动画——当然，这个话题只能在本书

的网站上展开了。

44

表 1.1.20 StdDraw 绘图举例

数　　据 函数值
随机数组
已排序的随 机数组

绘图的实现（代码片段）
int N = 100; StdDraw.setXscale(0, N); StdDraw.setYscale(0, N*N); StdDraw.setPenRadius(.01); for (int i = 1; i <= N; i++) {
StdDraw.point(i, i); StdDraw.point(i, i*i); StdDraw.point(i, i*Math.log(i)); }
int N = 50; double[] a = new double[N]; for (int i = 0; i < N; i++)
a[i] = StdRandom.random(); for (int i = 0; i < N; i++) {
double x = 1.0*i/N; double y = a[i]/2.0; double rw = 0.5/N; double rh = a[i]/2.0; StdDraw.filledRectangle(x, y, rw, rh); }
int N = 50; double[] a = new double[N]; for (int i = 0; i < N; i++)
a[i] = StdRandom.random(); Arrays.sort(a); for (int i = 0; i < N; i++) {
double x = 1.0*i/N; double y = a[i]/2.0; double rw = 0.5/N; double rh = a[i]/2.0; StdDraw.filledRectangle(x, y, rw, rh); }

结　　果 45

28 第 1 章　基　　础

1.1.10 二分查找
我们要学习的第一个 Java 程序的示例程序就是著名、高效并且应用广泛的二分查找算法，如下 所示。这个例子将会展示本书中学习新算法的基本方法。和我们将要学习的所有程序一样，它既是 算法的准确定义，又是算法的一个完整的 Java 实现，而且你还能够从本书的网站上下载它。

二分查找

import java.util.Arrays;

public class BinarySearch

{

public static int rank(int key, int[] a)

{ // 数组必须是有序的

int lo = 0;

int hi = a.length - 1;

while (lo <= hi)

{ // 被查找的键要么不存在，要么必然存在于 a[lo..hi] 之中

int mid = lo + (hi - lo) / 2;

if

(key < a[mid]) hi = mid - 1;

else if (key > a[mid]) lo = mid + 1;

else

return mid;

}

return -1;

}

public static void main(String[] args)

{

int[] whitelist = In.readInts(args[0]);

Arrays.sort(whitelist);

while (!StdIn.isEmpty())

{ // 读取键值，如果不存在于白名单中则将其打印

int key = StdIn.readInt();

if (rank(key, whitelist) < 0)

StdOut.println(key);

}

}

}

这段程序接受一个白名单文件（一列整数） 作为参数，并会过滤掉标准输入中的所有存在 于白名单中的条目，仅将不在白名单上的整数 打印到标准输出中。它在 rank() 静态方法中实

% java BinarySearch tinyW.txt < tinyT.txt 50 99 13

现了二分查找算法并高效地完成了这个任务。

关于二分查找算法的完整讨论，包括它的正确性、性能分析及其应用，请见 3.1 节。

1.1.10.1 二分查找 我们会在 3.2 节中详细学习二分查找算法，但此处先简单地描述一下。算法是由静态方法
rank() 实现的，它接受一个整数键和一个已经有序的 int 数组作为参数。如果该键存在于数组中 则返回它的索引，否则返回 -1。算法使用两个变量 lo 和 hi，并保证如果键在数组中则它一定在 a[lo..hi] 中，然后方法进入一个循环，不断将数组的中间键（索引为 mid）和被查找的键比较。 如果被查找的键等于 a[mid]，返回 mid；否则算法就将查找范围缩小一半，如果被查找的键小于 a[mid] 就继续在左半边查找，如果被查找的键大于 a[mid] 就继续在右半边查找。算法找到被查找 的键或是查找范围为空时该过程结束。二分查找之所以快是因为它只需检查很少几个条目（相对于 数组的大小）就能够找到目标元素（或者确认目标元素不存在）。在有序数组中进行二分查找的示

1.1　基础编程模型 29

例如图 1.1.7 所示。 1.1.10.2 开发用例
对于每个算法的实现，我们都会开发一个用例 main() 函数，并在书中或是本书的网站上提供一 个示例输入文件来帮助读者学习该算法并检测它的性能。在这个例子中，这个用例会从命令行指定的 文件中读取多个整数，并会打印出标准输入中所有不存在于该文件中的整数。我们使用了图 1.1.8 所 示的几个较小的测试文件来展示它的行为，这些文件也是图 1.1.7 中的跟踪和例子的基础。我们会使 用较大的测试文件来模拟真实应用并测试算法的性能（请见 1.1.10.3 节）。

对23的命中查找

lo

mid

hi

10 11 12 16 18 23 29 33 48 54 57 68 77 84 98

lo

mid

hi

10 11 12 16 18 23 29 33 48 54 57 68 77 84 98 lo mid hi

10 11 12 16 18 23 29 33 48 54 57 68 77 84 98

对50的未命中查找

lo

mid

hi

10 11 12 16 18 23 29 33 48 54 57 68 77 84 98

lo

mid

hi

10 11 12 16 18 23 29 33 48 54 57 68 77 84 98 lo mid hi

10 11 12 16 18 23 29 33 48 54 57 68 77 84 98 lo mid hi

10 11 12 16 18 23 29 33 48 54 57 68 77 84 98 hi lo

10 11 12 16 18 23 29 33 48 54 57 68 77 84 98

图 1.1.7 有序数组中的二分查找

tinyW.txt tinyT.txt

84

23

48

50

68

10

10

99

18

18

98

23

12

98 不存在于

23

84 tinyW.txt

54

11

57

10

33

48

16

77

77

13

11

54

29

98

77

77

68

图 1.1.8 为 BinarySearch 的测试用例

~

46

准备的小型测试文件

47

1.1.10.3 白名单过滤 如果可能，我们的测试用例都会通过模拟实际情况来展示当前算法的必要性。这里该过程被称
为白名单过滤。具体来说，可以想象一家信用卡公司，它需要检查客户的交易账号是否有效。为此， 它需要：
 将客户的账号保存在一个文件中，我们称它为白名单；  从标准输入中得到每笔交易的账号；  使用这个测试用例在标准输出中打印所有与任何客户无关的账号，公司很可能拒绝此类交易。 在一家有上百万客户的大公司中，需要处理数百万甚至更多的交易都是很正常的。为了模拟这 种情况，我们在本书的网站上提供了文件 largeW.txt（100 万个整数）和 largeT.txt（1000 万个整数） 其基本情况如图 1.1.9 所示。 1.1.10.4 性能 一个程序只是可用往往是不够的。例如，以下 rank() 的实现也可以很简单，它会检查数组的 每个元素，甚至都不需要数组是有序的：

30 第 1 章　基　　础

public static int rank(int key, int[] a) {
for (int i = 0; i < a.length; i++) if (a[i] == key) return i;
return -1; }
有了这个简单易懂的解决方案，我们为什 么还需要归并排序和二分查找呢？你在完成练 习 1.1.38 时会看到，计算机用 rank() 方法的 暴力实现处理大量输入（比如含有 100 万个条 目的白名单和 1000 万条交易）非常慢。没有 如二分查找或者归并排序这样的高效算法，解 决大规模的白名单问题是不可能的。良好的性 能常常是极为重要的，因此我们会在 1.4 节中 为性能研究做一些铺垫，并会分析我们学习的

largeW.txt largeT.txt

489910 18940
774392 490636 125544 407391 115771 992663 923282 176914 217904 571222 519039 395667
...
100万个int值

944443 293674 572153 600579 499569 984875 763178 295754
44696 207807 138910 903531 140925 699418 759984 199694 774549 635871 161828 805380
...

不存在于 largeW.txt

所有算法的性能特点（包括 2.2 节的归并排序 和 3.1 节中的二分查找）。

1000万个int值

目 前， 我 们 在 这 里 粗 略 地 勾 勒 出 我 们 的 编程模型的目标是，确保你能够在计算机上运 行类似于 BinarySearch 的代码，使用它处理我 们的测试数据并为适应各种情况修改它（比如 本节练习中所描述的一些情况）以完全理解它 的 可 应 用 性。 我 们 的 编 程 模 型 就 是 设 计 用 来

% java BinarySearch largeW.txt < largeT.txt 499569 984875 295754 207807 140925 161828
...

48 简化这些活动的，这对各种算法的学习至关 49 重要。

3 675 966个int值

图 1.1.9 为 BinarySearch 测试用例准备的大型文件

1.1.11 展望

在本节中，我们描述了一个精巧而完整的编程模型，数十年来它一直在（并且现在仍在）为广 大程序员服务。但现代编程技术已经更进一步。前进的这一步被称为数据抽象，有时也被称为面向 对象编程，它是我们下一节的主题。简单地说，数据抽象的主要思想是鼓励程序定义自己的数据类 型（一系列值和对这些值的操作），而不仅仅是那些操作预定义的数据类型的静态方法。
面向对象编程在最近几十年得到了广泛的应用，数据抽象已经成为现代程序开发的核心。我们 在本书中“拥抱”数据抽象的原因主要有三。
 它允许我们通过模块化编程复用代码。例如，第 2 章中的排序算法和第 3 章中的二分查找以 及其他算法，都允许调用者用同一段代码处理任意类型的数据（而不仅限于整数），包括调 用者自定义的数据类型。
 它使我们可以轻易构造多种所谓的链式数据结构，它们比数组更灵活，在许多情况下都是高 效算法的基础。
 借助它我们可以准确地定义所面对的算法问题。比如 1.5 节中的 union-ﬁnd 算法、2.4 节中的 优先队列算法和第 3 章中的符号表算法，它们解决问题的方式都是定义数据结构并高效地实 现它们的一组操作。这些问题都能够用数据抽象很好地解决。

~

1.1　基础编程模型 31

尽管如此，但我们的重点仍然是对算法的研究。在了解了这些知识以后，我们将学习面向对象

编程中和我们的使命相关的另一个重要特性。

50

答疑

问 什么是 Java 的字节码？

答 它是程序的一种低级表示，可以运行于 Java 的虚拟机。将程序抽象为字节码可以保证 Java 程序员的

代码能够运行在各种设备之上。

问 Java 允许整型溢出并返回错误值的做法是错误的。难道 Java 不应该自动检查溢出吗？

答 这个问题在程序员中一直是有争议的。简单的回答是它们之所以被称为原始数据类型就是因为缺乏

此类检查。避免此类问题并不需要很高深的知识。我们会使用 int 类型表示较小的数（小于 10 个十

进制位）而使用 long 表示 10 亿以上的数。

问 Math.abs(-2147483648) 的返回值是什么？

答 -2147483648。这个奇怪的结果（但的确是真的）就是整数溢出的典型例子。

问 如何才能将一个 double 变量初始化为无穷大？

答 可以使用 Java 的内置常数：Double.POSITIVE_INFINITY 和 Double.NEGATIVE_INFINITY。

问 能够将 double 类型的值和 int 类型的值相互比较吗？

答 不通过类型转换是不行的，但请记住 Java 一般会自动进行所需的类型转换。例如，如果 x 的类型是

int 且值为 3，那么表达式 (x<3.1) 的值为 true——Java 会在比较前将 x 转换为 double 类型（因为 3.1

是一个 double 类型的字面量）。

问 如果使用一个变量前没有将它初始化，会发生什么？

答 如果代码中存在任何可能导致使用未经初始化的变量的执行路径，Java 都会抛出一个编译异常。

问 Java 表达式 1/0 和 1.0/0.0 的值是什么？

答 第一个表达式会产生一个运行时除以零异常（它会终止程序，因为这个值是未定义的）；第二个表

达式的值是 Infinity（无穷大）。

51

问 能够使用 < 和 > 比较 String 变量吗？

答 不行，只有原始数据类型定义了这些运算符。请见 1.1.2.3 节。

问 负数的除法和余数的结果是什么？

答 表达式 a/b 的商会向 0 取整；a % b 的余数的定义是 (a/b)*b + a % b 恒等于 a。例如 -14/3 和

14/-3 的商都是 -4，但 -14 % 3 是 -2，而 14 % -3 是 2。

问 为什么使用 (a && b) 而非 (a & b) ？

答 运算符 &、| 和 ^ 分别表示整数的位逻辑操作与、或和异或。因此，10|6 的值为 14，10^6 的值为

12。在本书中我们很少（偶尔）会用到这些运算符。&& 和 || 运算符仅在独立的布尔表达式中有效，

原因是短路求值法则：表达式从左向右求值，一旦整个表达式的值已知则停止求值。

问 嵌套 if 语句中的二义性有问题吗？

答 是的。在 Java 中，以下语句：

if <expr1> if <expr2> <stmntA> else <stmntB>
　　等价于：

if <expr1> { if <expr2> <stmntA> else <stmntB> }

32 第 1 章　基　　础

　　即使你想表达的是：

if <expr1> { if <expr2> <stmntA> } else <stmntB>

　　避免这种“无主的”else 陷阱的最好办法是显式地写明所有大括号。

问 一个 for 循环和它的 while 形式有什么区别？

答 for 循环头部的代码和 for 循环的主体代码在同一个代码段之中。在一个典型的 for 循环中，递

增变量一般在循环结束之后都是不可用的；但在和它等价的 while 循环中，递增变量在循环结束

52

之后仍然是可用的。这个区别常常是使用 while 而非 for 循环的主要原因。

问 有些 Java 程序员用 int a[] 而不是 int[] a 来声明一个数组。这两者有什么不同？

答 在 Java 中，两者等价且都是合法的。前一种是 C 语言中数组的声明方式。后者是 Java 提倡的方式，

因为变量的类型 int[] 能更清楚地说明这是一个整型的数组。

问 为什么数组的起始索引是 0 而不是 1 ？

答 这个习惯来源于机器语言，那时要计算一个数组元素的地址需要将数组的起始地址加上该元素的索

引。将起始索引设为 1 要么会浪费数组的第一个元素的空间，要么会花费额外的时间来将索引减 1。

问 如 果 a[] 是 一 个 数 组， 为 什 么 StdOut.println(a) 打 印 出 的 是 一 个 十 六 进 制 的 整 数， 比 如 @

f62373，而不是数组中的元素呢？

答 问得好。该方法打印出的是这个数组的地址，不幸的是你一般都不需要它。

问 我们为什么不使用标准的 Java 库来处理输入和图形？

答 我们的确用到了它们，但我们希望使用更简单的抽象模型。StdIn 和 StdDraw 背后的 Java 标准库是

为实际生产设计的，这些库和它们的 API 都有些笨重。要想知道它们真正的模样，请查看 StdIn.java

和 StdDraw.java 的代码。

问 我的程序能够重新读取标准输入中的值吗？

答 不行，你只有一次机会，就好像你不能撤销 println() 的结果一样。

问 如果我的程序在标准输入为空之后仍然尝试读取，会发生什么？

答 会得到一个错误。StdIn.isEmpty() 能够帮助你检查是否还有可用的输入以避免这种错误。

问 这条出错信息是什么意思？

Exception in thread "main" java.lang.NoClassDefFoundError: StdIn
答 你可能忘记把 StdIn.java 文件放到工作目录中去了。 问 在 Java 中，一个静态方法能够将另一个静态方法作为参数吗？ 53 答 不行，但问得好，因为有很多语言都能够这么做。

练习
1.1.1 给出以下表达式的值： a. ( 0 + 15 ) / 2 b. 2.0e-6 * 100000000.1 c. true && false || true && true
1.1.2 给出以下表达式的类型和值： a. (1 + 2.236)/2 b. 1 + 2 + 3 + 4.0

1.1　基础编程模型 33

c. 4.1 >= 4

d. 1 + 2 + "3"

1.1.3　编写一个程序，从命令行得到三个整数参数。如果它们都相等则打印 equal，否则打印 not

equal。

1.1.4　下列语句各有什么问题（如果有的话）？

a. if (a > b) then c = 0;

b. if a > b { c = 0; }

c. if (a > b) c = 0;

d. if (a > b) c = 0 else b = 0; 1.1.5　编写一段程序，如果 double 类型的变量 x 和 y 都严格位于 0 和 1 之间则打印 true，否则打印

false。

1.1.6 下面这段程序会打印出什么？

int f = 0;

int g = 1;

for (int i = 0; i <= 15; i++)

{

StdOut.println(f);

f = f + g;

g = f - g;

54

}

1.1.7 分别给出以下代码段打印出的值：

a. double t = 9.0; while (Math.abs(t - 9.0/t) > .001) t = (9.0/t + t) / 2.0; StdOut.printf("%.5f\n", t);

b. int sum = 0; for (int i = 1; i < 1000; i++) for (int j = 0; j < i; j++) sum++; StdOut.println(sum);

c. int sum = 0; for (int i = 1; i < 1000; i *= 2) for (int j = 0; j < 1000; j++) sum++; StdOut.println(sum);

1.1.8 下列语句会打印出什么结果？给出解释。

a. System.out.println('b');

b. System.out.println('b' + 'c');

c. System.out.println((char) ('a' + 4));

1.1.9 编写一段代码，将一个正整数 N 用二进制表示并转换为一个 String 类型的值 s。

解答：Java 有一个内置方法 Integer.toBinaryString(N) 专门完成这个任务，但该题的目的就

是给出这个方法的其他实现方法。下面就是一个特别简洁的答案：

String s = "";

for (int n = N; n > 0; n /= 2)

55

s = (n % 2) + s;

34 第 1 章　基　　础

1.1.10 下面这段代码有什么问题？
int[] a; for (int i = 0; i < 10; i++)
a[i] = i * i;
解答：它没有用 new 为 a[] 分配内存。这段代码会产生一个 variable a might not have
been initialized 的编译错误。
1.1.11　编写一段代码，打印出一个二维布尔数组的内容。其中，使用 * 表示真，空格表示假。打印出
行号和列号。
1.1.12 以下代码段会打印出什么结果？
int[] a = new int[10]; for (int i = 0; i < 10; i++)
a[i] = 9 - i; for (int i = 0; i < 10; i++)
a[i] = a[a[i]]; for (int i = 0; i < 10; i++)
System.out.println(i);

1.1.13 编写一段代码，打印出一个 M 行 N 列的二维数组的转置（交换行和列）。

1.1.14 编写一个静态方法 lg()，接受一个整型参数 N，返回不大于 log2N 的最大整数。不要使用 Math 库。 1.1.15　编写一个静态方法 histogram()，接受一个整型数组 a[] 和一个整数 M 为参数并返回一个大小

为 M 的数组，其中第 i 个元素的值为整数 i 在参数数组中出现的次数。如果 a[] 中的值均在 0 到 M-1

之间，返回数组中所有元素之和应该和 a.length 相等。

1.1.16 给出 exR1(6) 的返回值：

public static String exR1(int n)

{

if (n <= 0) return "";

56

return exR1(n-3) + n + exR1(n-2) + n; }

1.1.17

找出以下递归函数的问题：
public static String exR2(int n) {
String s = exR2(n-3) + n + exR2(n-2) + n; if (n <= 0) return ""; return s; }

答：这段代码中的基础情况永远不会被访问。调用 exR2(3) 会产生调用 exR2(0)、exR2(-3) 和

exR2(-6)，循环往复直到发生 StackOverflowError。

1.1.18 请看以下递归函数：

public static int mystery(int a, int b)

{

if (b == 0)

return 0;

if (b % 2 == 0) return mystery(a+a, b/2);

return mystery(a+a, b/2) + a;

}

mystery(2, 25) 和 mystery(3, 11) 的返回值是多少？给定正整数 a 和 b，mystery(a,b) 计算的结果是什么？将代码中的 + 替换为 * 并将 return 0 改为 return 1，然后回答相同 的问题。 1.1.19 在计算机上运行以下程序：

1.1　基础编程模型 35

public class Fibonacci

{

public static long F(int N)

{

if (N == 0) return 0;

if (N == 1) return 1;

return F(N-1) + F(N-2);

}

public static void main(String[] args)

{

for (int N = 0; N < 100; N++)

StdOut.println(N + " " + F(N));

}

}

57

计算机用这段程序在一个小时之内能够得到 F(N) 结果的最大 N 值是多少？开发 F(N) 的一

个更好的实现，用数组保存已经计算过的值。

1.1.20 编写一个递归的静态方法计算 ln(N!) 的值。

1.1.21　编 写 一 段 程 序， 从 标 准 输 入 按 行 读 取 数 据， 其 中 每 行 都 包 含 一 个 名 字 和 两 个 整 数。 然 后 用

printf() 打印一张表格，每行的若干列数据包括名字、两个整数和第一个整数除以第二个整数

的结果，精确到小数点后三位。可以用这种程序将棒球球手的击球命中率或者学生的考试分数

制成表格。

1.1.22　使用 1.1.6.4 节中的 rank() 递归方法重新实现 BinarySearch 并跟踪该方法的调用。每当该方法

被调用时，打印出它的参数 lo 和 hi 并按照递归的深度缩进。提示：为递归方法添加一个参数

来保存递归的深度。

1.1.23　为 BinarySearch 的测试用例添加一个参数：+ 打印出标准输入中不在白名单上的值；-，则打

印出标准输入中在白名单上的值。

1.1.24　给出使用欧几里得算法计算 105 和 24 的最大公约数的过程中得到的一系列 p 和 q 的值。扩展该

算法中的代码得到一个程序 Euclid，从命令行接受两个参数，计算它们的最大公约数并打印出每

次调用递归方法时的两个参数。使用你的程序计算 1 111 111 和 1 234 567 的最大公约数。

1.1.25 使用数学归纳法证明欧几里得算法能够计算任意一对非负整数 p 和 q 的最大公约数。

58

提高题
1.1.26　将三个数字排序。假设 a、b、c 和 t 都是同一种原始数字类型的变量。证明以下代码能够将 a、 b、c 按照升序排列：
if (a > b) { t = a; a = b; b = t; } if (a > c) { t = a; a = c; c = t; } if (b > c) { t = b; b = c; c = t; }
1.1.27 二项分布。估计用以下代码计算 binomial(100, 50, 0.25) 将会产生的递归调用次数：
public static double binomial(int N, int k, double p) {
if (N == 0 && k == 0) return 1.0; if (N < 0 || k < 0) return 0.0; return (1.0 - p)*binomial(N-1, k, p) + p*binomial(N-1, k-1, p); }
将已经计算过的值保存在数组中并给出一个更好的实现。 1.1.28 删除重复元素。修改 BinarySearch 类中的测试用例来删去排序之后白名单中的所有重复元素。

36 第 1 章　基　　础

1.1.29　等值键。为 BinarySearch 类添加一个静态方法 rank()，它接受一个键和一个整型有序数组（可

能存在重复键）作为参数并返回数组中小于该键的元素数量，以及一个类似的方法 count() 来

返回数组中等于该键的元素的数量。注意：如果 i 和 j 分别是 rank(key,a) 和 count(key,a)

的返回值，那么 a[i..i+j-1] 就是数组中所有和 key 相等的元素。

1.1.30　数组练习。编写一段程序，创建一个 N×N 的布尔数组 a[][]。其中当 i 和 j 互质时（没有相同

因子），a[i][j] 为 true，否则为 false。

1.1.31　随机连接。编写一段程序，从命令行接受一个整数 N 和 double 值 p（0 到 1 之间）作为参数，

59

在一个圆上画出大小为 0.05 且间距相等的 N 个点，然后将每对点按照概率 p 用灰线连接。

1.1.32　直方图。假设标准输入流中含有一系列 double 值。编写一段程序，从命令行接受一个整数 N 和

两个 double 值 l 和 r。将 (l，r) 分为 N 段并使用 StdDraw 画出输入流中的值落入每段的数量的

直方图。

1.1.33 矩阵库。编写一个 Matrix 库并实现以下 API：

public class Matrix

static

double

static double[][]

static double[][]

static double[]

static double[]

dot(double[] x, double[] y) mult(double[][] a, double[][] b) transpose(double[][] a) mult(double[][] a, double[] x) mult(double[] y, double[][] a)

向量点乘 矩阵和矩阵之积 转置矩阵 矩阵和向量之积 向量和矩阵之积

编写一个测试用例，从标准输入读取矩阵并测试所有方法。

1.1.34　过滤。以下哪些任务需要（在数组中，比如）保存标准输入中的所有值？哪些可以被实现为一

个过滤器且仅使用固定数量的变量和固定大小的数组（和 N 无关）？在每个问题中，输入都来

自于标准输入且含有 N 个 0 到 1 的实数。

 打印出最大和最小的数

 打印出所有数的中位数

 打印出第 k 小的数，k 小于 100

 打印出所有数的平方和

 打印出 N 个数的平均值

 打印出大于平均值的数的百分比

 将 N 个数按照升序打印

60

 将 N 个数按照随机顺序打印

实验题

1.1.35

模拟掷骰子。以下代码能够计算每种两个骰子之和的准确概率分布：
int SIDES = 6; double[] dist = new double[2*SIDES+1]; for (int i = 1; i <= SIDES; i++)
for (int j = 1; j <= SIDES; j++) dist[i+j] += 1.0;

for (int k = 2; k <= 2*SIDES; k++) dist[k] /= 36.0;

1.1　基础编程模型 37

dist[i] 的值就是两个骰子之和为 i 的概率。用实验模拟 N 次掷骰子，并在计算两个 1 到

6 之间的随机整数之和时记录每个值的出现频率以验证它们的概率。N 要多大才能够保证你

的经验数据和准确数据的吻合程度达到小数点后三位？

1.1.36　乱序检查。通过实验检查表 1.1.10 中的乱序代码是否能够产生预期的效果。编写一个程序

ShufﬂeTest，接受命令行参数 M 和 N，将大小为 M 的数组打乱 N 次且在每次打乱之前都将数组

重新初始化为 a[i] = i。打印一个 M×M 的表格，对于所有的列 j，行 i 表示的是 i 在打乱后

落到 j 的位置的次数。数组中的所有元素的值都应该接近于 N/M。

1.1.37　糟糕的打乱。假设在我们的乱序代码中你选择的是一个 0 到 N-1 而非 i 到 N-1 之间的随机整数。

证明得到的结果并非均匀地分布在 N! 种可能性之间。用上一题中的测试检验这个版本。

1.1.38　二分查找与暴力查找。根据 1.1.10.4 节给出的暴力查找法编写一个程序 BruteForceSearch，在你

的计算机上比较它和 BinarySearch 处理 largeW.txt 和 largeT.txt 所需的时间。

61

1.1.39　随机匹配。编写一个使用 BinarySearch 的程序，它从命令行接受一个整型参数 T，并会分别针 对 N=103、104、105 和 106 将以下实验运行 T 遍：生成两个大小为 N 的随机 6 位正整数数组并找

出同时存在于两个数组中的整数的数量。打印一个表格，对于每个 N，给出 T 次实验中该数量

的平均值。

62

38 第 1 章　基　　础
1.2 数据抽象
数据类型指的是一组值和一组对这些值的操作的集合。目前，我们已经详细讨论过 Java 的原始 数据类型：例如，原始数据类型 int 的取值范围是 -231 到 231-1 之间的整数，int 的操作包括 +、*、-、 /、%、< 和 >。原则上所有程序都只需要使用原始数据类型即可，但在更高层次的抽象上编写程序 会更加方便。在本节中，我们将重点学习定义和使用数据类型，这个过程也被称为数据抽象（它是 对 1.1 节所述的函数抽象风格的补充）。
Java 编程的基础主要是使用 class 关键字构造被称为引用类型的数据类型。这种编程风格也称 为面向对象编程，因为它的核心概念是对象，即保存了某个数据类型的值的实体。如果只有 Java 的 原始数据类型，我们的程序会在很大程度上被限制在算术计算上，但有了引用类型，我们就能编写 操作字符串、图像、声音以及 Java 的标准库中或者本书的网站上的数百种抽象类型的程序。比各种 库中预定义的数据类型更重要的是 Java 编程中的数据类型的种类是无限的，因为你能够定义自己的 数据类型来抽象任意对象。
抽象数据类型（ADT）是一种能够对使用者隐藏数据表示的数据类型。用 Java 类来实现抽象 数据类型和用一组静态方法实现一个函数库并没有什么不同。抽象数据类型的主要不同之处在于它 将数据和函数的实现关联，并将数据的表示方式隐藏起来。在使用抽象数据类型时，我们的注意力 集中在 API 描述的操作上而不会去关心数据的表示；在实现抽象数据类型时，我们的注意力集中在 数据本身并将实现对该数据的各种操作。
抽象数据类型之所以重要是因为在程序设计上它们支持封装。在本书中，我们将通过它们：  以适用于各种用途的 API 形式准确地定义问题；  用 API 的实现描述算法和数据结构。 我们研究同一个问题的不同算法的主要原因在于它们的性能特点不同。抽象数据类型正适合于 63 对算法的这种研究，因为它确保我们可以随时将算法性能的知识应用于实践中：可以在不修改任何 64 用例代码的情况下用一种算法替换另一种算法并改进所有用例的性能。
1.2.1 使用抽象数据类型
要使用一种数据类型并不一定非得知道它是如何实现的，所以我们首先来编写一个使用一种名 为 Counter（计数器）的简单数据类型的程序。它的值是一个名称和一个非负整数，它的操作有创 建对象并初始化为 0、当前值加 1 和获取当前值。这个抽象对象在许多场景中都会用到。例如，这 样一个数据类型可以用于电子记票软件，它能够保证投票者所能进行的唯一操作就是将他选择的候 选人的计数器加一。我们也可以在分析算法性能时使用 Counter 来记录基本操作的调用次数。要使 用 Counter 对象，首先需要了解应该如何定义数据类型的操作，以及在 Java 语言中应该如何创建 和使用某个数据类型的对象。这些机制在现代编程中都非常重要，我们在全书中都会用到它们，因 此请仔细学习我们的第一个例子。 1.2.1.1　抽象数据类型的 API
我们使用应用程序编程接口（API）来说明抽象数据类型的行为。它将列出所有构造函数和实 例方法（即操作）并简要描述它们的功用，如表 1.2.1 中 Counter 的 API 所示。
尽管数据类型定义的基础是一组值的集合，但在 API 可见的仅是对它们的操作，而非它们的意 义。因此，抽象数据类型的定义和静态方法库（请见 1.1.6.3 节）之间有许多共同之处：
 两者的实现均为 Java 类；

~

1.2 数据抽象 39

 实例方法可能接受 0 个或多个指定类型的参数，由括号表示并由逗号分隔；

 它们可能会返回一个指定类型的值，也可能不会（用 void 表示）。

当然，它们也有三个显著的不同。

 API 中可能会出现若干个名称和类名相同且没有返回值的函数。这些特殊的函数被称为构造

函数。在本例中，Counter 对象有一个接受一个 String 参数的构造函数。

65

 实例方法不需要 static 关键字。它们不是静态方法——它们的目的就是操作该数据类型中

的值。

 某些实例方法的存在是为了尊重 Java 的习惯——我们将此类方法称为继承的方法并在 API

中将它们显示为灰色。

public class Counter Counter(String id)
void increment() int tally()
String toString()

表 1.2.1　计数器的 API
创建一个名为 id 的计数器 将计数器的值加 1 该对象创建之后计数器被加 1 的次数 对象的字符串表示

和静态方法库的 API 一样，抽象数据类型的 API 也是和用例之间的一份契约，因此它是开

发任何用例代码以及实现任意数据类型的起点。在本例中，这份 API 告诉我们可以通过构造函数

Counter()、实例方法 increment() 和 tally()，以及继承的 toString() 方法使用 Counter 类

型的对象。

1.2.1.2 继承的方法

根据 Java 的约定，任意数据类型都能通过在 API 中包含特定的方法从 Java 的内在机制中获

益。例如，Java 中的所有数据类型都会继承 toString() 方法来返回用 String 表示的该类型的

值。Java 会在用 + 运算符将任意数据类型的值和 String 值连接时调用该方法。该方法的默认实

现并不实用（它会返回用字符串表示的该数据类型值的内存地址），因此我们常常会提供实现来

重载默认实现，并在此时在 API 中加上 toString() 方法。此类方法的例子还包括 equals()、

compareTo() 和 hashCode()（请见 1.2.5.5 节）。

1.2.1.3 用例代码

和基于静态方法的模块化编程一样，API 允许我们在不知道实现细节的情况下编写调用它的代

码（以及在不知道任何用例代码的情况下编写实现代码）。1.1.7 节介绍的将程序组织为独立模块的

机制可以应用于所有的 Java 类，因此它对基于抽象数据类型的模块化编程与对静态函数库一样有效。

这样，只要抽象数据类型的源代码 .java 文件和我们的程序文件在同一个目录下，或是在标准 Java

库中，或是可以通过 import 语句访问，或是可以通过本书网站上介绍的 classpath 机制之一访问，

该程序就能够使用这个抽象数据类型，模块化编程的所有优势就都能够继续发挥。通过将实现某种

数据类型的全部代码封装在一个 Java 类中，我们可以将用例代码推向更高的抽象层次。在用例代码

中，你需要声明变量、创建对象来保存数据类型的值并允许通过实例方法来操作它们。尽管你也会

注意到它们的一些相似之处，但这种方式和原始数据类型的使用方式非常不同。

66

1.2.1.4 对象

一般来说，可以声明一个变量 heads 并将它通过以下代码和 Counter 类型的数据关联起来：

Counter heads；

40 第 1 章　基　　础

但如何为它赋值或是对它进行操作呢？这个问题的答 案涉及数据抽象中的一个基础概念：对象是能够承载数据类

一个Counter对象

型的值的实体。所有对象都有三大重要特性：状态、标识 和行为。对象的状态即数据类型中的值。对象的标识能够将

heads 460

引用

一个对象区别于另一个对象。可以认为对象的标识就是它 在内存中的位置。对象的行为就是数据类型的操作。数据类

标识（细节 已经被隐藏）

型的实现的唯一职责就是维护一个对象的身份，这样用例

460

代码在使用数据类型时只需遵守描述对象行为的 API 即可，

而无需关注对象状态的表示方法。对象的状态可以为用例代

码提供信息，或是产生某种副作用，或是被数据类型的操作

所改变。但数据类型的值的表示细节和用例代码是无关的。 引用是访问对象的一种方式。Java 使用术语引用类型以示

两个Counter对象

和原始数据类型（变量和值相关联）的区别。不同的 Java

实现中引用的实现细节也各不相同，但可以认为引用就是内 存地址，如图 1.2.1 所示（简洁起见，图中的内存地址为三

heads 460 tails 612

位数）。

heads的标识

1.2.1.5 创建对象

460

每种数据类型中的值都存储于一个对象中。要创建（或

实例化）一个对象，我们用关键字 new 并紧跟类名以及 ()

tails的标识

（或在括号中指定一系列的参数，如果构造函数需要的话）

612

来触发它的构造函数。构造函数没有返回值，因为它总是返

回它的数据类型的对象的引用。每当用例调用了 new()，系

统都会：

 为新的对象分配内存空间；  调用构造函数初始化对象中的值；

图 1.2.1 对象的表示

 返回该对象的一个引用。

在用例代码中，我们一般都会在一条声明语句中创建一个对象并通过将它和一个变量关联来

初始化该变量，和使用原始数据类型时一样。和原始数据类型不同的是，变量关联的是指向对象的

67 引用而并非数据类型的值本身。我们可以用同一个类创建无数对象——每个对象都有自己的标识，

且所存储的值和另一个相同类型的对象可以相同也可以不同。例如，以下代码创建了两个不同的

Counter 对象：

Counter heads = new Counter("heads"); Counter tails = new Counter("tails");

抽象数据类型向用例隐藏了值的表示细节。可以假定每个 Counter 对象中的值是一个 String

类型的名称和一个 int 计数器，但不能编写依赖于任何特定表示方法的代码（即使知道假定是否正

将变量和对象的引 用关联的声明语句 调用构造函数来创建一个对象

确——也许计数器是一个 long 值呢）对象 的创建过程如图 1.2.2 所示。

Counter heads = new Counter("heads");

1.2.1.6 调用实例方法 实例方法的意义在于操作数据类型中的

图 1.2.2 创建对象

值，因此 Java 语言提供了一种特别的机制来

1.2 数据抽象 41

触发实例方法，它突出了实例方法和对象之间的联系。 具体来说，我们调用一个实例方法的方式是先写出对 象的变量名，紧接着是一个句点，然后是实例方法的 名称，之后是 0 个或多个在括号中并由逗号分隔的参 数。实例方法可能会改变数据类型中的值，也可能只 是访问数据类型中的值。实例方法拥有我们在 1.1.6.3 节讨论过的静态方法的所有性质——参数按值传递，

Counter heads;

声明语句

通过new关键字（触发构造函数） heads = new Counter ("heads");

触发构造函数（创建一个对象） 通过语句（没有返回值）
heads .increment();

方法名可以被重载，方法可以有返回值，它们也许还 会产生一些副作用。但它们还有一个特别的性质：方

对象名

触发一个实例方 法并改变对象的值

法的每次触发都是和一个对象相关的。例如，以下代 码调用了实例方法 increment() 来操作 Counter 对 象 heads（在这里该操作会将计数器的值加 1）：
heads.increment();
而以下代码会调用实例方法 tally() 两次，第一 次操作的是 Counter 对象 heads，第二次是 Counter 对象 tails（这里该操作会返回计数器的 int 值）：
heads.tally() - tails.tally();
以上示例的调用过程见图 1.2.3。

通过表达式 heads .tally() - tails.tally()

对象名

触发一个实例方 法并访问对象的值

通过自动类型转换（toString()）

StdOut.println( heads );

触发heads.toString()

图 1.2.3 触发实例方法的各种方式

正如这些例子所示，在用例中实例方法和静态方法的调用方式完全相同——可以通过语句（void

方法）也可以通过表达式（有返回值的方法）。静态方法的主要作用是实现函数；非静态（实例） 68

方法的主要作用是实现数据类型的操作。两者都可能出现在用例代码中，但很容易就可以区分它们，

因为静态方法调用的开头是类名（按习惯为大写），而非静态方法调用的开头总是对象名（按习惯

为小写）。表 1.2.2 总结了这些不同之处。

举例 调用方式 参量 主要作用

表 1.2.2 实例方法与静态方法 实例方法
heads.increment() 对象名 对象的引用和方法的参数 访问或改变对象的值

静态方法 Math.sqrt(2.0) 类名 方法的参数 计算返回值

1.2.1.7 使用对象 通过声明语句可以将变量名赋给对象，在代码中，我们不仅可以用该变量创建对象和调用实例
方法，也可以像使用整数、浮点数和其他原始数据类型的变量一样使用它。要开发某种给定数据类 型的用例，我们需要：
 声明该类型的变量，以用来引用对象；  使用关键字 new 触发能够创建该类型的对象的一个构造函数；  使用变量名在语句或表达式中调用实例方法。 例如，下面用例代码中的 Flips 类就使用了 Counter 类。它接受一个命令行参数 T 并模拟 T 次掷硬币（它还调用了 StdRandom 类）。除了这些直接用法外，我们可以和使用原始数据类型的

42 第 1 章　基　　础

变量一样使用和对象关联的变量：  赋值语句；  向方法传递对象或是从方法中返回对象；  创建并使用对象的数组。
public class Flips {
public static void main(String[] args) {
int T = Integer.parseInt(args[0]); Counter heads = new Counter("heads"); Counter tails = new Counter("tails"); for (int t = 0; t < T; t++)
if (StdRandom.bernoulli(0.5)) heads.increment();
else tails.increment(); StdOut.println(heads); StdOut.println(tails); int d = heads.tally() - tails.tally(); StdOut.println("delta: " + Math.abs(d)); } }
Counter 类的用例，模拟 T 次掷硬币

% java Flips 10 5 heads 5 tails delta: 0
% java Flips 10 8 heads 2 tails delta: 6
% java Flips 1000000 499710 heads 500290 tails delta: 580

接下来将逐个分析它们。你会发现，你需要从引用而非值的 角度去考虑问题才能理解这些用法的行为。 1.2.1.8 赋值语句
使用引用类型的赋值语句将会创建该引用的一个副本。赋值 语句不会创建新的对象，而只是创建另一个指向某个已经存在的 对象的引用。这种情况被称为别名：两个变量同时指向同一个对 象。别名的效果可能会出乎你的意料，因为对于原始数据类型的 变量，情况不同，你必须理解其中的差异。如果 x 和 y 是原始数 据类型的变量，那么赋值语句 x = y 会将 y 的值复制到 x 中。对 于引用类型，复制的是引用（而非实际的值）。在 Java 中，别名 是 bug 的常见原因，如下例所示（图 1.2.4）：
Counter c1 = new Counter("ones"); c1.increment(); Counter c2 = c1; c2.increment(); StdOut.println(c1);
对 于 一 般 的 toString() 实 现， 这 段 代 码 将 会 打 印 出 "2 ones"。这可能并不是我们想要的，而且乍一看有些奇怪。这种 问题经常出现在使用对象经验不足的人所编写的程序之中（可能 就是你，所以请集中注意力！）。改变一个对象的状态将会影响 到所有和该对象的别名有关的代码。我们习惯于认为两个不同的

Counter c1; c1 = new Counter("ones"); c1.increment(); Counter c2 = c1; c2.increment();

c1 811 c2 811

指向同一个 对象的引用

811 2

指向"ones" 的引用

图 1.2.4 别名

1.2 数据抽象 43

原始数据类型的变量是相互独立的，但这种感觉对于引用类型的变量并不适用。

69

~

1.2.1.9　将对象作为参数

70

可以将对象作为参数传递给方法，这一般都能简化用例代码。例如，当我们使用 Counter 对

象作为参数时，本质上我们传递的是一个名称和一个计数器，但我们只需要指定一个变量。当我

们调用一个需要参数的方法时，该动作在 Java 中的效果相当于每个参数值都出现在了一个赋值

语句的右侧，而参数名则在该赋值语句的左侧。也就是说，Java 将参数值的一个副本从调用端

传递给了方法，这种方式称为按值传递（请见 1.1.6.3 节）。这种方式的一个重要后果是方法无

法改变调用端变量的值。对于原始数据类型来说，这种策略正是我们所期望的（两个变量互相独

立），但每当使用引用类型作为参数时我们创建的都是别名，所以就必须小心。换句话说，这种

约定将会传递引用的值（复制引用），也就是传递对象的引用。例如，如果我们传递了一个指向

Counter 类型的对象的引用，那么方法虽然无法改变原始的引用（比如将它指向另一个 Counter

对象），但它能够改变该对象的值，比如通过该引用调用 increment() 方法。

1.2.1.10 将对象作为返回值

当然也能够将对象作为方法的返回值。方法可以将它的参数对象返回，如下面的例子所示，也

可以创建一个对象并返回它的引用。这种能力非常重要，因为 Java 中的方法只能有一个返回值——

有了对象我们的代码实际上就能返回多个值。

% java FlipsMax 1000000 500281 tails wins

public class FlipsMax

{

public static Counter max(Counter x, Counter y)

{

if (x.tally() > y.tally()) return x;

else

return y;

}

public static void main(String[] args) {
int T = Integer.parseInt(args[0]); Counter heads = new Counter("heads"); Counter tails = new Counter("tails"); for (int t = 0; t < T; t++)
if (StdRandom.bernoulli(0.5)) heads.increment();
else tails.increment();

if (heads.tally() == tails.tally()) StdOut.println("Tie");
else StdOut.println(max(heads, tails) + " wins"); } }

一个接受对象作为参数并将对象作为返回值的静态方法的例子

71

1.2.1.11 数组也是对象 在 Java 中，所有非原始数据类型的值都是对象。也就是说，数组也是对象。和字符串一样，
Java 语言对于数组的某些操作有特殊的支持：声明、初始化和索引。和其他对象一样，当我们将数 组传递给一个方法或是将一个数组变量放在赋值语句的右侧时，我们都是在创建该数组引用的一个 副本，而非数组的副本。对于一般情况，这种效果正合适，因为我们期望方法能够重新安排数组的

44 第 1 章　基　　础

条目并修改数组的内容，如 java.util.Array.sort() 或表 1.1.10 讨论的 shuffle() 方法。 1.2.1.12 对象的数组
我们已经看到，数组元素可以是任意类型的数据：我们实现的 main() 方法的 args[] 参数就 是一个 String 对象的数组。创建一个对象的数组需要以下两个步骤：
 使用方括号语法调用数组的构造函数创建数组；  对于每个数组元素调用它的构造函数创建相应的对象。 例如，下面这段代码模拟的是掷骰子。它使用了一个 Counter 对象的数组来记录每种可能的值 的出现次数。在 Java 中，对象数组即是一个由对象的引用组成的数组，而非所有对象本身组成的数 组。如果对象非常大，那么在移动它们时由于只需要操作引用而非对象本身，这就会大大提高效率； 如果对象很小，每次获取信息时都需要通过引用反而会降低效率。

public class Rolls {
public static void main(String[] args) {
int T = Integer.parseInt(args[0]); int SIDES = 6; Counter[] rolls = new Counter[SIDES+1]; for (int i = 1; i <= SIDES; i++)
rolls[i] = new Counter(i + "'s");
for (int t = 0; t < T; t++) {
int result = StdRandom.uniform(1, SIDES+1); rolls[result].increment(); } for (int i = 1; i <= SIDES; i++) StdOut.println(rolls[i]); } }

72

模拟 T 次掷骰子的 Counter 对象的用例

% java Rolls 1000000 167308 1's 166540 2's 166087 3's 167051 4's 166422 5's 166592 6's

有了这些对象的知识，运用数据抽象的思想编写代码（定义和使用数据类型，将数据类型的

值封装在对象中）的方式称为面向对象编程。刚才学习的基本概念是我们面向对象编程的起点，

因此有必要对它们进行简单的总结。数据类型指的是一组值和一组对值的操作的集合。我们会将

数据类型实现在独立的 Java 类模块中并编写它们的用例。对象是能够存储任意该数据类型的值的

实体，或数据类型的实例。对象有三大关键性质：状态、标识和行为。一个数据类型的实现所支

持的操作如下。

 创建对象（创造它的标识）：使用 new 关键字触发构造函数并创建对象，初始化对象中的

值并返回对它的引用。

 操作对象中的值（控制对象的行为，可能会改变对象的状态）：使用和对象关联的变量调用

实例方法来对对象中的值进行操作。

 操作多个对象：创建对象的数组，像原始数据类型的值一样将它们传递给方法或是从方法中

返回，只是变量关联的是对象的引用而非对象本身。

73

这些能力是这种灵活且应用广泛的现代编程方式的基础，也是我们在本书中对算法研究的基础。

1.2 数据抽象 45

1.2.2 抽象数据类型举例

Java 语言内置了上千种抽象数据类型，我们也会为了辅助算法研究创建许多其他抽象数据类型。

实际上，我们编写的每一个 Java 程序实现的都是某种数据类型（或是一个静态方法库）。为了控制

复杂度，我们会明确地说明在本书中用到的所有抽象数据类型的 API（实际上并不多）。

在本节中，我们会举一些抽象数据类型的例子，以及它们的一些用例。在某些情况下，我们会

节选一些含有数十个方法的 API 的一部分。我们将会用这些 API 展示一些实例以及在本书中会用到

的一些方法，并用它们说明要使用一个抽象数据类型并不需要了解其实现细节。

作为参考，下页显示了我们在本书中将会用到或开发的所有数据类型。它们可以被分为以下

几类。

 java.lang.* 中的标准系统抽象数据类型，可以被任意 Java 程序调用。

 Java 标准库中的抽象数据类型，如 java.swt、java.net 和 java.io，它们也可以被任意 Java 程

序调用，但需要 import 语句。

 I/O 处理类抽象数据类型，和 StdIn 和 StdOut 类似，允许我们处理多个输入输出流。

 面向数据类抽象数据类型，它们的主要作用是通过封装数据的表示简化数据的组织和处理。

稍后在本节中我们将介绍在计算几何和信息处理中的几个实际应用的例子，并会在以后将它

们作为抽象数据类型用例的范例 。

 集合类抽象数据类型，它们的主要用途是简化对同一类型的一组数据的操作。我们将会在 1.3

节中介绍基本的 Bag、Stack 和 Queue 类，在第 2 章中介绍优先队列（PQ）及其相关的类，

在第 3 章和第 5 章中分别介绍符号表（ST）和集合（SET）以及相关的类。

 面向操作的抽象数据类型，我们用它们分析各种算法，如 1.4 节和 1.5 节所述。

 图算法相关的抽象数据类型，它们包括一些用来封装各种图的表示的面向数据的抽象数据类

型，和一些提供图的处理算法的面向操作的抽象数据类型。

这个列表中并没有包含我们将在练习中遇到的某些抽象数据类型，读者可以在本书的索引中找

到它们。另外，如 1.2.4.1 节所述，我们常常通过描述性的前缀来区分各种抽象数据类型的多种实现。

从整体上来说，我们使用的抽象数据类型说明组织并理解你所使用的数据结构是现代编程中的重要

因素。

一般的应用程序可能只会使用这些抽象数据类型中的 5 ～ 10 个。在本书中，开发和组织抽象

数据类型的主要目标是使程序员们在编写用例时能够轻易地利用它们的一小部分。

74

1.2.2.1 几何对象

面向对象编程的一个典型例子是为几何对象设计数据类型。例如，表 1.2.3 至表 1.2.5 中的 API

为三种常见的几何对象定义了相应的抽象数据类型：Point2D（平面上的点）、Interval1D（直线

上的间隔）、Interval2D（平面上的二维间隔，即和数轴对齐的长方形）。和以前一样，这些 API

都是自文档化的，它们的用例十分容易理解，列在了表 1.2.5 的后面。这段代码从命令行读取一个

Interval2D 的边界和一个整数 T，在单位正方形内随机生成 T 个点并统计落在间隔之内的点数（用

来估计该长方形的面积）。为了表现效果，用例还画出了间隔和落在间隔之外的所有点。这种计算

方法是一个模型，它将计算几何图形的面积和体积的问题转化为了判定一个点是否落在该图形中（稍

稍简单，但仍然不那么容易）。我们当然也能为其他几何对象定义 API，比如线段、三角形、多边形、

圆等，不过实现它们的相关操作可能十分有挑战性。本节末尾的练习会考察其中几个例子。

46 第 1 章　基　　础

java.lang 中的标准 Java 系统类型

Integer

int 的封装类

Double

double 的封装类

String

可由索引访问的 char 值序列

StringBuilder

字符串构造类

其他 Java 数据类型

java.awt.Color

颜色

java.awt.Font

字体

java.net.URL

URL

java.io.File

文件

我们的标准 I/O 类型

In

输入流

Out

输出流

Draw

绘图类

用于用例的面向数据的数据类型

Point2D

平面上的点

Interval1D

一维间隔

Interval2D

二维间隔

Date

日期

Transaction

交易

用于算法分析的数据类型

Counter

计数器

Accumulator

累加器

VisualAccumulator 可视累加器

Stopwatch

计时器

75

集合类数据类型 Stack Queue Bag MinPQ, MaxPQ IndexMinPQ IndexMaxPQ ST SET StringST 面向数据的图数据类型 Graph Digraph Edge EdgeWeightedGraph DirectedEdge EdgeWeightedDigraph 面向操作的图数据类型 UF DepthFirstPaths CC BreadthFirstPaths DirectedDFS DirectedBFS TransitiveClosure Topological DepthFirstOrder
DirectedCycle SCC MST SP

下压栈 先进先出（FIFO）队列 包 优先队列 索引优先队列 符号表 集合 符号表（字符串键）
无向图 有向图 边（加权） 无向图（加权） 边（有向，加权） 图（有向，加权）
动态连通性 路径的深度优先搜索 连通分量 路径的广度优先搜索 有向图路径的深度优先搜索 有向图路径的广度优先搜索 所有路径 拓扑排序 深度优先搜索顶点被访问的 顺序 环的搜索 强连通分量 最小生成树 最短路径

本书中使用的部分抽象数据类型

表 1.2.3 平面上的点的 API

public class Point2D Point2D(double x, double y)
double x() double y() double r() double theta() double distTo(Point2D that)
void draw()

创建一个点 x 坐标 y 坐标 极径（极坐标） 极角（极坐标） 从该点到 that 的欧几里得距离 用 StdDraw 绘出该点

1.2 数据抽象 47

表 1.2.4 直线上间隔的 API

public class Interval1D Interval1D(double lo, double hi)
double length() boolean contains(double x) boolean intersect(Interval1D that)
void draw()

创建一个间隔 间隔长度 x 是否在间隔中 该间隔是否和间隔 that 相交 用 StdDraw 绘出该间隔

表 1.2.5 平面上的二维间隔的 API

public class Interval2D Interval2D(Interval1D x, Interval1D y)
double area() boolean contains(Point2D p) boolean intersect(Interval2D that)
void draw()

创建一个二维间隔 二维间隔的面积 p 是否在二维间隔中 该间隔是否和二维间隔 that 相交 用 StdDraw 绘出该二维间隔

public static void main(String[] args) {
double xlo = Double.parseDouble(args[0]); double xhi = Double.parseDouble(args[1]); double ylo = Double.parseDouble(args[2]); double yhi = Double.parseDouble(args[3]); int T = Integer.parseInt(args[4]);

Interval1D xinterval = new Interval1D(xlo, xhi); Interval1D yinterval = new Interval1D(ylo, yhi); Interval2D box = new Interval2D(xinterval, yinterval); box.draw();

Counter c = new Counter("hits");

for (int t = 0; t < T; t++)

{

double x = Math.random();

double y = Math.random();

Point2D p = new Point2D(x, y);

if (box.contains(p)) c.increment();

else

p.draw();

}

StdOut.println(c); StdOut.println(box.area()); }

Interval2D 的测试用例

处理几何对象的程序在自然世界模型、科学计算、电子游戏、电影等许多应用的计算中有着广

泛的应用。此类程序的研发已经发展成了计算几何学的这门影响深远的研究学科。在贯穿全书的众

多例子中你会看到，我们在本书中学习的许多算法在这个领域都有应用。在这里我们要说明的是直

接表示几何对象的抽象数据类型的定义并不困难且在用例中的应用也十分简洁。本书网站和本节末 76

~

尾的若干练习都证明了这一点。

77

1.2.2.2 信息处理

无论是需要处理数百万信用卡交易的银行，还是需要处理数十亿点击的网络分析公司，或是需

48 第 1 章　基　　础

要处理数百万实验观察结果的科学研究小组，无数应用的核心都是组织和处理信息。抽象数据类型 是组织信息的一种自然方式。虽然没有给出细节，表 1.2.6 中的两份 API 也展示了商业应用程序中 的一种典型做法。这里的主要思想是定义和真实世界中的物体相对应的对象。一个日期就是一个日、 月和年的集合，一笔交易就是一个客户、日期和金额的集合。这只是两个例子，我们也可以为客户、 时间、地点、商品、服务和其他任何东西定义对象以保存相关的信息。每种数据类型都包含能够创 建对象的构造函数和用于访问其中数据的方法。为了简化用例的代码，我们为每个类型都提供了两 个构造函数，一个接受适当类型的数据，另一个则能够解析字符串中的数据（细节请见练习 1.2.19）。 和以前一样，用例并不需要知道数据的表示方法。用这种方式组织数据最常见的理由是将一个对象 和它相关的数据变成一个整体：我们可以维护一个 Transaction 对象的数组，将 Date 值作为参数 或是某个方法的返回值等。这些数据类型的重点在于封装数据，同时它们也可以确保用例的代码不 依赖于数据的表示方法。我们不会深究这种组织信息的方式，需要注意的只是这种做法，以及实现 继承的方法 toString()、compareTo()、equals() 和 hashCode() 可以使我们的算法处理任意类 型的数据。我们会在 1.2.5.4 节中详细讨论继承的方法。例如，我们已经注意到，根据 Java 的习惯， 在数据结构中包含一个 toString() 的实现可以帮助用例打印出由对象中的值组成的一个字符串。 我们会在 1.3 节、2.5 节、3.4 节和 3.5 节中用 Date 类和 Transaction 类作为例子考察其他继承的 方法所对应的习惯用法。1.3 节给出了有关数据类型和 Java 语言的类型参数（泛型）机制的几个经 典例子，它们都遵循了这些习惯用法。第 2 章和第 3 章也都利用了泛型和继承的方法来实现可以处 理任意数据类型的高效排序和查找算法。

表 1.2.6 商业应用程序中的示例 API（日期和交易）

public class Date implements Comparable<Date>

int int int String boolean int int

Date(int month, int day, int year) Date(String date) month() day() year() toString() equals(Object that) compareTo(Date that) hashCode()

创建一个日期 创建一个日期（解析字符串的构造函数） 月 日 年 对象的字符串表示 该日期和 that 是否相同 将该日期和 that 比较 散列值

public class
String Date
double String boolean
int int

Transaction implements Comparable<Transaction>

Transaction(String who, Date when, double amount)

Transaction(String transaction)

创建一笔交易（解析字符串的构造函数）

who()

客户名

when()

交易日期

amount()

交易金额

toString()

对象的字符串表示

equals(Object that)

该笔交易和 that 是否相同

compareTo(Transaction that)

将该笔交易和 that 比较

hashCode()

散列值

1.2 数据抽象 49

每当遇到逻辑上相关的不同类型的数据时，你都应该考虑像刚才的例子那样定义一个抽象数据

类型。这么做能够帮助我们组织数据并在一般应用程序中极大地简化使用者的代码。它是我们在通 78

~

向数据抽象之路上迈出的重要一步。

79

1.2.2.3 字符串

Java 的 String 是一种重要而实用的抽象数据类型。一个 String 值是一串可以由索引访问的

char 值。String 对象拥有许多实例方法，如表 1.2.7 所示。

表 1.2.7 Java 的字符串 API（部分）

Public class String

String() int length() int charAt(int i) int indexOf(String p) int indexOf(String p, int i) String concat(String t) String substring(int i, int j) String[] split(String delim) int compareTo(String t) boolean equals(String t) int hashCode()

创建一个空字符串 字符串长度 第 i 个字符 p 第一次出现的位置（如果没有则返回 -1） p 在 i 个字符后第一次出现的位置（如果没有则返回 -1） 将 t 附在该字符串末尾 该字符串的子字符串（第 i 个字符到第 j-1 个字符） 使用 delim 分隔符切分字符串 比较字符串 该字符串的值和 t 的值是否相同 散列值

String 值和字符数组类似，但两者是不同的。数组能够通过 Java 语言的内置语法访问每个字

符，String 则为索引访问、字符串长度以及其他许多操作准备了实例方法。另一方面，Java 语言

为 String 的初始化和连接提供了特别的支持：我们可以直接使用字符串字面量而非构造函数来创

建并初始化一个字符串，还可以直接使用 + 运算符代替 concat() 方法。我们不需要了解实现的细

节，但是在第 5 章中你会看到，了解某些方法的性能特点

String a = "now is ";

在开发字符串处理算法时是非常重要的。为什么不直接使 用字符数组代替 String 值？对于任何抽象数据类型，这 个问题的答案都是一样的：为了使代码更加简洁清晰。有

String b = "the time "; String c = "to"
方法 返回值 a.length() 7

了 String 类型，我们可以写出清晰干净的用例代码而无

a.charAt(4) i

需关心字符串的表示方式。先看一下右侧这段短小的列表， 其中甚至含有一些需要我们在第 5 章才会学到的高级算法

a.concat(c) a.indexOf("is") a.substring(2, 5)

"now is to" 4 "w i"

才能实现的强大操作。例如，split() 方法的参数可以是

a.split(" ")[0] "now"

正则表达式（请见 5.4 节），“典型的字符串处理代码”（显 示在下页）中 split() 的参数是 "\\s+"，它表示“一个或

a.split(" ")[1] "is" b.equals(c) false

多个制表符、空格、换行符或回车”。

字符串操作举例

80

50 第 1 章　基　　础

任　　务

实　　现

判断字符串是否是一条回文

public static boolean isPalindrome(String s) {
int N = s.length(); for (int i = 0; i < N/2; i++)
if (s.charAt(i) != s.charAt(N-1-i)) return false;
return true; }

从一个命令行参数中提取文件名和 扩展名

String s = args[0]; int dot = s.indexOf("."); String base = s.substring(0, dot); String extension = s.substring(dot + 1, s.length());

打印出标准输入中所有含有通过命 令行指定的字符串的行

String query = args[0]; while (!StdIn.isEmpty()) {
String s = StdIn.readLine(); if (s.contains(query)) StdOut.println(s); }

以空白字符为分隔符从 StdIn 中创 String input = StdIn.readAll();

建一个字符串数组

String[] words = input.split("\\s+");

检查一个字符串数组中的元素是否 已按照字母表顺序排列

public boolean isSorted(String[] a) {
for (int i = 1; i < a.length; i++) {
if (a[i-1].compareTo(a[i]) > 0) return false;
} return true; }

81

典型的字符串处理代码

1.2.2.4 再谈输入输出 1.1 节中的 StdIn、StdOut 和 StdDraw 标准库的一个缺点是对于任意程序，我们只能接受一个
输入文件、向一个文件输出或是产生一幅图像。有了面向对象编程，我们就能定义类似的机制来在 一个程序中同时处理多个输入流、输出流和图像。具体来说，我们的标准库定义了数据类型 In、 Out 和 Draw，它们的 API 如表 1.2.8 至表 1.2.10 所示。当使用一个 String 类型的参数调用它们的 构造函数时，In 和 Out 会首先尝试在当前目录下查找指定的文件。如果找不到，它会假设该参数 是一个网站的名称并尝试连接到那个网站（如果该网站不存在，它会抛出一个运行时异常）。无论 哪种情况，指定的文件或网站都会成为被创建的输入或输出流对象的来源或目标，所有 read*() 和 print*() 方法都会指向那个文件或网站（如果你使用的是无参数的构造函数，对象将会使用标准 的输入输出流）。这种机制使得单个程序能够处理多个文件和图像；你也能将这些对象赋给变量， 将它们当做方法的参数、作为方法的返回值或是创建它们的数组，可以像操作任何类型的对象那样 操作它们。下页所示的程序 Cat 就是一个 In 和 Out 的用例，它使用了多个输入流来将多个输入文 件归并到同一个输出文件中。In 和 Out 类也包括将仅含 int、double 或 String 类型值的文件读 取为一个数组的静态方法（请见 1.3.1.5 节和练习 1.2.15）。

1.2 数据抽象 51

public class Cat

{

public static void main(String[] args)

{ // 将所有输入文件复制到输出流（最后一个参数）中 Out out = new Out(args[args.length-1]); for (int i = 0; i < args.length - 1; i++)

% more in1.txt This is

{ // 将第i个输入文件复制到输出流中

% more in2.txt

In in = new In(args[i]);

a tiny

String s = in.readAll();

test.

out.println(s); in.close();

% java Cat in1.txt in2.txt out.txt

} out.close(); } }

% more out.txt This is a tiny test.
82

In和Out的用例示例

表 1.2.8 我们的输入流数据类型的 API

public class In In() In(String name)
boolean isEmpty() int readInt()
double readDouble() ...
void close() 注：In 对象也支持 StdIn 所支持的所有操作。

从标准输入创建输入流 从文件或网站创建输入流 如果输入流为空则返回 true，否则返回 false 读取一个 int 类型的值 读取一个 double 类型的值
关闭输入流

表 1.2.9 我们的输出流数据类型的 API

public class Out Out() Out(String name)
void print(String s) void println(String s) void println() void printf(String f, ...) void close()

从标准输出创建输出流 从文件创建输出流 将 s 添加到输出流中 将 s 和一个换行符添加到输出流中 将一个换行符添加到输出流中 格式化并打印到输出流中 关闭输出流

注：Out 对象也支持 StdOut 所支持的所有操作。

表 1.2.10 我们的绘图数据类型的 API

public class Draw

Draw()

void line(double x0, double y0, double x1, double y1)

void point(double x, double y)

...

注：Draw 对象也支持 StdDraw 所支持的所有操作。

83

52 第 1 章　基　　础

1.2.3 抽象数据类型的实现

和静态方法库一样，我们也需要使用 Java 的类（class）实现抽象数据类型并将所有代码放入

一个和类名相同并带有 .java 扩展名的文件中。文件的第一部分语句会定义表示数据类型的值的实

例变量。它们之后是实现对数据类型的值的操作的构造函数和实例方法。实例方法可以是公共的（在

API 中说明）或是私有的（用于辅助计算，用例无法使用）。一个数据类型的定义中可能含有多个

构造函数，而且也可能含有静态方法，特别是单元测试用例 main()，它通常在调试和测试中很实

用。作为第一个例子，我们来学习 1.2.1.1 节定义的 Counter 抽象数据类型的实现。它的完整实现（带有 注释）如图 1.2.5 所示，在对它的各个部分的讨论中， 我们还将该图作为参考。本书后面开发的每个抽象数 据类型的实现都会含有和这个简单例子相同的元素。

实例变 量的声明

public class Counter {
private final String name; private int count; ... }

抽象数据类型中的实例变量是私有的

实例变量

public class Counter {
private final String name; private int count;

类名

构造函数

public Counter(String id) { name = id; }

public void increment() { count++; }

实例方法

public int tally() { return count; }
public String toString() { return count + " " + name ; }

实例变量名

测试用例
创建并初 始化对象

public static void main(String[] args) {
Counter heads = new Counter("heads"); Counter tails = new Counter("tails");

heads.increment(); heads.increment(); tails.increment();

触发构造函数 自动调用toString()方法

对象名 StdOut.println(heads + " " + tails); StdOut.println(heads.tally() + tails.tally() );

} }

调用 方法

图 1.2.5 详解数据类型的定义类
1.2.3.1 实例变量 要定义数据类型的值（即每个对象的状态），我们需要声明实例变量，声明的方式和局部变量差
不多。实例变量和你所熟悉的静态方法或是某个代码段中的局部变量最关键的区别在于：每一时刻每 个局部变量只会有一个值，但每个实例变量则对应着无数值（数据类型的每个实例对象都会有一个）。

1.2 数据抽象 53

这并不会产生二义性，因为我们在访问实例变量时都需要通过一个对象——我们访问的是这个对象的

值。同样，每个实例变量的声明都需要一个可见性修饰符。在抽象数据类型的实现中，我们会使用

private，也就是使用 Java 语言的机制来保证向使用者隐藏抽象数据类型中的数据表示，如下面的示

例所示。如果该值在初始化之后不应该再被改变，我们也会使用 final。Counter 类型含有两个实例

变量，一个 String 类型的值 name 和一个 int 类型的值 count。如果我们使用 public 修饰这些实例

变量（在 Java 中是允许的），那么根据定义，这种数据类型就不再是抽象的了，因此我们不会这么做。

1.2.3.2 构造函数

每个 Java 类都至少含有一个构造函数以创建一个对象的标识。构造函数类似于一个静态方法，但 它能够直接访问实例变量且没有返回值。一般来说，构造函数的作用是初始化实例变量。每个构造函 84 数都将创建一个对象并向调用者返回一个该对象的引用。构造函数的名称总是和类名相同。我们可以 85

~

和重载方法一样重载这个名称并定义签名不同的多 个构造函数。如果没有定义构造函数，类将会隐式 定义一个默认情况下不接受任何参数的构造函数并 将所有实例变量初始化为默认值。原始数字类型的 实例变量默认值为 0，布尔类型变量为 false，引 用类型变量为 null。我们可以在声明语句中初始

public class Counter {
private final String name; private int count; ...
可见性 没有指定返 构造函数名称 修饰符 回值的类型 （和类名相同）

参数 变量

化这些实例变量并改变这些默认值。当用例使用关 键字 new 时，Java 会自动触发一个构造函数。重载 构造函数一般用于将实例变量由默认值初始化为用 例提供的值。例如，Counter 类型有个接受一个参 数的构造函数，它将实例变量 name 初始化为由参 数给定的值（实例变量 count 仍将被初始化为默认 值 0）。构造函数解析如图 1.2.6 所示。

public Counter ( String id )

{ name = id; }

签名

初始化实例变量的代码 （coun.t.将. 会被初始化为默认值0）
}

图 1.2.6 详解构造函数

1.2.3.3 实例方法

实现数据类型的实例方法（即每个对象的行为）的代码和 1.1 节中实现静态方法（函数）的代码

完全相同。每个实例方法都有一个返回值类型、一个签名（它指定了方法名、所有参数变量的类型

和名称）和一个主体（它由一系列语句组成，包括一个返回语句来将一个返回类型的值传递给调用

者）。当调用者触发了一个方法时，方法的参数（如果有）均会被初始化为调用者所提供的值，方法

的语句会被执行，直到得到一个返回值并且将该值返回给调用者。它的效果就好像调用者代码中的函

数调用被替换为了这个返回值。实例方法的所有这些行为都和静态方法相同，只有一点关键的不同：

它们可以访问并操作实例变量。如何指定我们希望使用的对象的实例变量？只要稍加思考，就能够得

到合理的答案：在一个实例方法中对变量的引用指的是调用该方法的对象中的值。当我们调用 heads.

increment() 时，increment() 方法中的代码访问的是 heads 中的实例变量。换句话说，面向对象编 86

程为 Java 程序增加了另一种使用变量的重要方式。

可见性 返回

 通过触发一个实例方法来操作该对象的值。

修饰符 值类型 方法名

签名

这与调用静态方法仅仅是语法上的区别（请 见答疑），但在许多情况下它颠覆了现代程序员 对程序开发的思维方式。你会看到，这种方式与 算法和数据结构的研究非常契合。实例方法解析

public void increment() { count++; }
实例变量名

如图 1.2.7 所示。

图 1.2.7 详解实例方法

54 第 1 章　基　　础

1.2.3.4 作用域

总的来说，我们在实现实例方法的 Java 代码中使用了三种变量：

 参数变量；  局部变量；  实例变量。 前两者的用法和静态方法中一样：方法

public class Example {
private int var; ...

实例变量

的签名定义了参数变量，在方法被调用时参 数变量会被初始化为调用者提供的值；局部 变量的声明和初始化都在方法的主体中。参 数变量的作用域是整个方法；局部变量的作

private void method1()

{

局部变量

int var; ... var

调用的是局部变 ..量.而非实例变量

... this.var ...

用域是当前代码段中它的定义之后的所有语 句。实例变量则完全不同（如右侧示例所示）： 它们为该类的对象保存了数据类型的值，它 们的作用域是整个类（如果出现二义性，可 以使用 this 前缀来区别实例变量）。理解 实例方法中这三种变量的区别是理解面向对

调用实例变量 }

private void method2()

{

... var

...

}

调用实例变量

...

}

87 象编程的关键。 1.2.3.5 API、用例与实现

实例方法中的实例变量和局部变量的作用范围

这些都是你要在 Java 中构造并使用抽象数据类型所需要理解的基本组件。我们将要学习的每

个抽象数据类型的实现都会是一个含有若干私有实例变量、构造函数、实例方法和一个测试用例

的 Java 类。要完全理解一个数据类型，我们需要它的 API、典型的用例和它的实现。Counter 类型

的总结请见表 1.2.11。为了强调用例和实现的分离，我们一般会将用例独立成为含有一个静态方法

main() 的类，并将数据类型定义中的 main() 方法预留为一个用于开发和最小单元测试的测试用例

（至少调用每个实例方法一次）。我们开发的每种数据类型都会遵循相同的步骤。我们思考的不是

应该采取什么行动来达成某个计算性的目的（如同我们第一次学习编程时那样），而是用例的需求。

我们会按照下面三步走的方式用抽象数据类型满足它们。

 定义一份 API：API 的作用是将使用和实现分离，以实现模块化编程。我们制定一份 API 的目

标有二：第一，我们希望用例的代码清晰而正确，事实上，在最终确定 API 之前就编写一些

用例代码来确保所设计的数据类型操作正是用例所需要的是很好的主意；第二，我们希望能

够实现这些操作，定义一些无法实现的操作是没有意义的。

 用一个 Java 类实现 API 的定义：首先我们选择适当的实例变量，然后再编写构造函数和实

例方法。

 实现多个测试用例来验证前两步做出的设计决定。

表 1.2.11 一个简单计数器的抽象数据类型

API public class Counter Counter(String id)
void increment() int tally()
String toString()

创建一个名为 id 的计数器 将计数器的值加 1 计数器的值 对象的字符串表示

1.2 数据抽象 55

典型的用例

public class Flips {
public static void main(String[] args) {
int T = Integer.parseInt(args[0]); Counter heads = new Counter("heads"); Counter tails = new Counter("tails"); for (int t = 0; t < T; t++)
if (StdRandom.bernoulli(0.5)) heads.increment();
else tails.increment(); StdOut.println(heads); StdOut.println(tails); int d = heads.tally() - tails.tally(); StdOut.println("delta: " + Math.abs(d)); } }

（续）

数据类型的实现

public class Counter

{

private final String name;

private int count;

邮

public Counter(String id)

　

{ name = id; }

电

public void increment()

{ count++; }

public int tally()

{ return count; }

public String toString()

{ return count + " " + name; }

}

使用方法
% java Flips 1000000 500172 heads 499828 tails delta: 344

用例一般需要什么操作？数据类型的值应该是什么才能最好地支持这些操作？这些基本的判断 88

~

是我们开发的每种实现的核心内容。

89

1.2.4 更多抽象数据类型的实现

和任何编程概念一样，理解抽象数据类型的威力和用法的最好办法就是仔细研究更多的例子和 实现。本书中大量代码是通过抽象数据类型实现的，因此你的机会很多，但是一些更简单的例子能 够帮助我们为研究抽象数据类型打好基础。 1.2.4.1 日期
表 1.2.12 是 我 们 在 表 1.2.6 中 定 义 的 Date 抽 象 数 据 类 型 的 两 种 实 现。 简 单 起 见， 我 们 省 略 了 解 析 字 符 串 的 构 造 函 数（ 请 见 练 习 1.2.19） 和 继 承 的 方 法 equals()（ 请 见 1.2.5.8 节）、 compareTo()（请见 2.1.1.4 节）和 hashCode()（请见练习 3.4.22）。表 1.2.12 中左侧的简单实现 将日、月和年设为实例变量，这样实例方法就可以直接返回适当的值；右侧的实现更加节省空间， 仅使用了一个 int 变量来表示一个日期。它将 d 日、m 月和 y 年的一个日期表示为一个混合进制的 整数 512y+32m+d。用例分辨这两种实现的区别的一种方法可能是打破我们对日期的隐式假设：第

56 第 1 章　基　　础

二种实现的正确性基于日的值在 0 到 31 之间，月的值在 0 到 15 之间，年的值为正（在实际应用中， 两种实现都应该检查月份的值是否在 1 到 12 之间，日的值是否在 1 到 31 之间，以及例如 2009 年 6 月 31 日和 2 月 29 日这样的非法日期，尽管这么做要费些工夫）。这个例子的主要意思是说明我们 在 API 中极少完整地指定对实现的要求（一般来说我们都会尽力而为，这里还可以做得更好）。用 例要分辨出这两种实现的区别的另一种方法是性能：右侧的实现中保存数据类型的值所需的空间较 少，代价是在向用例按照约定的格式提供这些值时花费的时间更多（需要进行一两次算术运算）。 这种交换是很常见的：某些用例可能偏爱其中一种实现，而另一些用例可能更喜欢另一种，因此我 们两者都要满足。事实上，本书中反复出现的一个主题就是我们需要理解各种实现对空间和时间的 需求以及它们对各种用例的适用性。在实现中使用数据抽象的一个关键优势是我们可以将一种实现 替换为另一种而无需改变用例的任何代码。

表 1.2.12 一种封装日期的抽象数据类型以及它的两种实现

API public class Date Date(int month, int day, int year)
int day() int month() int year() String toString()

创建一个日期 日 月 年 对象的字符串表示

测试用例
public static void main(String[] args) {
int m = Integer.parseInt(args[0]); int d = Integer.parseInt(args[1]); int y = Integer.parseInt(args[2]); Date date = new Date(m, d, y); StdOut.println(date); }

使用方法
% java Date 12 31 1999 12/31/1999

数据类型的实现
public class Date {
private final int month; private final int day; private final int year; public Date(int m, int d, int y) { month = m; day = d; year = y; } public int month() { return month; } public int day() { return day; } public int year() { return year; } public String toString() { return month() + "/" + day()
+ "/" + year(); } }

数据类型的另一种实现
public class Date {
private final int value; public Date(int m, int d, int y) { value = y*512 + m*32 + d; } public int month() { return (value / 32) % 16; } public int day() { return value % 32; } public int year() { return value / 512; }
public String toString() { return month() + "/" + day()
+ "/" + year(); } }

1.2 数据抽象 57

~

1.2.4.2 维护多个实现 同一份 API 的多个实现可能会产生维护和命名问题。在某些情况下，我们可能只是想将较老的实
现替换为改进的实现。而在另一些情况下，我们可能需要维护两种实现，一种适用于某些用例，另一 种适用于另一些用例。实际上，本书的一个主要目标就是深入讨论若干种基本抽象数据结构的实现并 90 衡量它们的性能的不同。在本书中，我们经常会比较同一份 API 的两种不同实现在同一个用例中的性 91 能表现。为此，我们通常采用一种非正式的命名约定。
 通过前缀的描述性修饰符区别同一份 API 的不同实现。例如，我们可以将表 1.2.12 中的 Date 实现命名为 BasicDate 和 SmallDate，我们可能还希望实现一种能够验证日期是否合 法的 SmartDate。
 维护一个没有前缀的参考实现，它应该适合于大多数用例的需求。在这里，大多数用例应该 直接会使用 Date。
在一个庞大的系统中，这种解决方案并不理想，因为它可能会需要修改用例的代码。例如，如 果需要开发一个新的实现 ExtraSmallDate，那么我们只能修改用例的代码或是让它成为所有用例 的参考实现。Java 有许多高级语言特性来保证在无需修改用例代码的情况下维护多个实现，但我们 很少会使用它们，因为即使 Java 专家使用起它们来也十分困难（有时甚至是有争议的），尤其是同 我们极为需要的其他高级语言特性（泛型和迭代器）一起使用时。这些问题很重要（例如，忽略它 们会导致千禧年著名的 Y2K 问题，因为许多程序使用的都是它们自己对日期的抽象实现，且并没 有考虑到年份的头两位数字），但是深究它们会使我们大大偏离对算法的研究。 1.2.4.3 累加器
表 1.2.13 中的累加器 API 定义了一种能够为用例计算一组数据的实时平均值的抽象数据类型。 例如，本书中经常会使用该数据类型来处理实验结果（请见 1.4 节）。它的实现很简单：它维护一个 int 类型的实例变量来记录已经处理过的数据值的数量，以及一个 double 类型的实例变量来记录所 有数据值之和，将和除以数据数量即可得到平均值。请注意该实现并没有保存数据的值——它可以用 于处理大规模的数据（甚至是在一个无法全部保存它们的设备上），而一个大型系统也可以大量使用

表 1.2.13 一种能够累加数据的抽象数据类型

API public class Accumulator Accumulator()
void addDataValue(double val) double mean() String toString()

创建一个累加器 添加一个新的数据值 所有数据值的平均值 对象的字符串表示

典型的用例

使用方法

public class TestAccumulator {
public static void main(String[] args) {
int T = Integer.parseInt(args[0]); Accumulator a = new Accumulator(); for (int t = 0; t < T; t++)
a.addDataValue(StdRandom.random()); StdOut.println(a); } }

% java TestAccumulator 1000 Mean (1000 values): 0.51829
% java TestAccumulator 1000000 Mean (1000000 values): 0.49948
% java TestAccumulator 1000000 Mean (1000000 values): 0.50014

58 第 1 章　基　　础

数据类型的实现
public class Accumulator {
private double total; private int N; public void addDataValue(double val) {
N++; total += val; } public double mean() { return total/N; } public String toString() { return "Mean (" + N + " values): "
+ String.format("%7.5f", mean()); } }

（续）

~

92 累加器。这种性能特点很容易被忽视，所以也许应该在 API 中注明，因为一种存储所有数据值的实现 93 可能会使调用它的应用程序用光所有内存。
1.2.4.4 可视化的累加器 表 1.2.14 所示的可视化累加器的实现继承了 Accumulator 类并展示了一种实用的副作用：它
用 StdDraw 画出了所有数据（灰色）和实时的平均值（红色），见图 1.2.8。完成这项任务最简单 的办法是添加一个构造函数来指定需要绘出的点数和它们的最大值（用于调整图像的比例）。严格 说来，VisualAccumulator 并不是 Accumulator 的 API 的实现（它的构造函数的签名不同且产生
使用方法

　
左起第N个红点的高度为最 靠左的N个灰点的平均高度

灰点的高度
即数据点的值 % java TestVisualAccumulator 2000 Mean (2000 values): 0.509789

94

图 1.2.8 可视化累加器图像（另见彩插）

1.2 数据抽象 59

了一种不同的副作用）。一般来说，我们会仔细而完整地设计 API，并且一旦定型就不愿再对它做 任何改动，因为这有可能会涉及修改无数用例（和实现）的代码。但添加一个构造函数来取得某些 功能有时能够获得通过，因为它对用例的影响和改变类名所产生的变化相同。在本例中，如果已经 开发了一个使用 Accumulator 的用例并大量调用了 addDataValue() 和 mean()，只需改变用例的 一行代码就能享受到 VisualAccumulator 的优势。

表 1.2.14 一种能够累加数据的抽象数据类型（可视版本，另见彩插）

API public class VisualAccumulator VisualAccumulator(int trials, double max)
void addDataValue(double val) double mean() String toString()

添加一个新的数据值 所有数据的平均值 对象的字符串表示

典型的用例

public class TestVisualAccumulator {
public static void main(String[] args) {
int T = Integer.parseInt(args[0]); VisualAccumulator a = new VisualAccumulator(T, 1.0); for (int t = 0; t < T; t++)
a.addDataValue(StdRandom.random()); StdOut.println(a); } }

数据类型的实现

public class VisualAccumulator

{

private double total;

private int N;

public VisualAccumulator(int trials, double max)

{

StdDraw.setXscale(0, trials);

StdDraw.setYscale(0, max);

StdDraw.setPenRadius(.005);

}

public void addDataValue(double val)

{

N++;

total += val;

StdDraw.setPenColor(StdDraw.DARK_GRAY);

StdDraw.point(N, val);

StdDraw.setPenColor(StdDraw.RED);

StdDraw.point(N, total/N);

}

public double mean()

public String toString()

// 和 Accumulator 相同

}
95

60 第 1 章　基　　础
1.2.5 数据类型的设计
抽象数据类型是一种向用例隐藏内部表示的数据类型。这种思想强有力地影响了现代编程。我 们遇到过的众多例子为我们研究抽象数据类型的高级特性和它们的 Java 实现打下了基础。简单看来， 下面的许多话题和算法的学习关系不大，因此你可以跳过本节，在今后实现抽象数据类型中遇到特 定问题时再回过头来参考它。我们的目的是将关于设计数据类型的重要知识集中起来以供参考，并 为本书中的所有抽象数据类型的实现做铺垫。 1.2.5.1 封装
面向对象编程的特征之一就是使用数据类型的实现封装数据，以简化实现和隔离用例开发。封 装实现了模块化编程，它允许我们：
 独立开发用例和实现的代码；  切换至改进的实现而不会影响用例的代码；  支持尚未编写的程序（对于后续用例，API 能够起到指南的作用）。 封装同时也隔离了数据类型的操作，这使我们可以：  限制潜在的错误；  在实现中添加一致性检查等调试工具；  确保用例代码更明晰。 一个封装的数据类型可以被任意用例使用，因此它扩展了 Java 语言。我们所提倡的编程风格是 将大型程序分解为能够独立开发和调试的小型模块。这种方式将修改代码的影响限制在局部区域， 改进了我们的软件质量。它也促进了代码复用，因为我们可以用某种数据类型的新实现代替老的实 现来改进它的性能、准确度或是内存消耗。同样的思想也适用于许多其他领域。我们在使用系统库 时常常从封装中受益。Java 系统的新实现往往更新了多种数据类型或静态方法库的实现，但它们的 API 并没有变化。在算法和数据结构的学习中，我们总是希望开发出更好的算法，因为只需用抽象 数据类型的改进实现替换老的实现即可在不改变任何用例代码的情况下改进所有用例的性能。模块 化编程成功的关键在于保持模块之间的独立性。我们坚持将 API 作为用例和实现之间唯一的依赖点 来做到这一点。并不需要知道一个数据类型是如何实现的才能使用它，实现数据类型时也应该假设 96 使用者除了 API 什么也不知道。封装是获得所有这些优势的关键。 1.2.5.2 设计 API 构建现代软件最重要也最有挑战的一项任务就是设计 API。它需要经验、思考和反复的修改， 但设计一份优秀的 API 所付出的所有时间都能从调试和代码复用所节省的时间中获得回报。为一个 小程序给出一份 API 似乎有些多余，但你应该按照能够复用的方式编写每个程序。理想情况下，一 份 API 应该能够清楚地说明所有可能的输入和副作用，然后我们应该先写出检查实现是否与 API 相 符的程序。但不幸的是，计算机科学理论中一个叫做说明书问题（speciﬁcation problem）的基础结 论说明这个目标是不可能实现的。简单地说，这样一份说明书应该用一种类似于编程语言的形式语 言编写。而从数学上可以证明，判定这样两个程序进行的计算是否相同是不可能的。因此，我们的 API 将是与抽象数据类型相关联的值以及一系列构造函数和实例方法的目的和副作用的自然语言描 述。为了验证我们的设计，我们会在 API 附近的正文中给出一些用例代码。但是，这些宏观概述之 中也隐藏着每一份 API 设计都可能落入的无数陷阱。  API 可能会难以实现：实现的开发非常困难，甚至不可能。

1.2 数据抽象 61

 API 可能会难以使用：用例代码甚至比没有 API 时更复杂。

 API 的范围可能太窄：缺少用例所需的方法。

 API 的范围可能太宽：包含许多不会被任何用例调用的方法。这种缺陷可能是最常见的，并且

也是最难以避免的。API 的大小一般会随着时间而增长，因为向已有的 API 中添加新方法很

简单，但在不破坏已有用例程序的前提下从中删除方法却很困难。

 API 可能会太粗略：无法提供有效的抽象。

 API 可能会太详细：抽象过于细致或是发散而无法使用。

 API 可能会过于依赖某种特定的数据表示：用例代码可能会因此无法从数据表示的细节中解

脱出来。要避免这种缺陷也是很困难的，因为数据表示显然是抽象数据类型实现的核心。

97

这些考虑有时又被总结为另一句格言：只为用例提供它们所需要的，仅此而已。

1.2.5.3 算法与抽象数据类型

数据抽象天生适合算法研究，因为它能够为我们提供一个框架，在其中能够准确地说明一个算

法的目的以及其他程序应该如何使用该算法。在本书中，算法一般都是某个抽象数据类型的一个实

例方法的实现。例如，本章开头的白名单例子就很自然地被实现为一个抽象数据类型的用例。它进

行了以下操作：

 由一组给定的值构造了一个 SET（集合）对象；

 判定一个给定的值是否存在于该集合中。

这些操作封装在 StaticSETofInts 抽象数据类型中，和 Whitelist 用例一起显示在表 1.2.15 中。

StaticSETofInts 是更一般也更有用的符号表抽象数据类型的一种特殊情况，符号表抽象数据类

型将是第 3 章的重点。在我们研究过的所有算法中，二分查找是较为适合用于实现这些抽象数据类

型的一种。和 1.1.10 节中的 BinarySearch 实现比较起来，这里的实现所产生的用例代码更加清晰和

高效。例如，StaticSETofInts 强制要求数组在 rank() 方法被调用之前排序。有了抽象数据类型，

我们可以将抽象数据类型的调用和实现区分开来，并确保任意遵守 API 的用例程序都能受益于二分

查找算法（使用 BinarySearch 的程序在调用 rank() 之前必须能够将数组排序）。白名单应用是众

多二分查找算法的用例之一。 每个 Java 程序都是一组静态方法和（或）一种 应用

数据类型的实现的集合。在本书中我们主要关注的是 抽象数据类型的实现中的操作和向用例隐藏其中的数 据表示，例如 StaticSETofInts。正如这个例子所示， 数据抽象使我们能够：
 准确定义算法能为用例提供什么；  隔离算法的实现和用例的代码；  实现多层抽象，用已知算法实现其他算法。

% java Whitelist largeW.txt < largeT.txt 499569 984875 295754 207807 140925 161828
...

表 1.2.15 将二分查找重写为一段面向对象的程序（用于在整数集合中进行查找的一种抽象数据类型）

API public class StaticSETofInts StaticSETofInts(int[] a)
boolean contains(int key)

根据 a[] 中的所有值创建一个集合 key 是否存在于集合中

